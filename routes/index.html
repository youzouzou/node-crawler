<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Gitbook爬取</title>
  <style type="text/css">
    body {
      width: 100%;
      max-width: 800px;
      margin: 0 auto;
      overflow-x: hidden;
      padding: 0
    }

    img {
      max-width: 80%;
      text-align: center;
    }

    .theme-default-content {
      padding: 20px;
    }

    code {
      color: #476582;
      padding: .25rem .5rem;
      margin: 0;
      font-size: .85em;
      background-color: rgba(27, 31, 35, .05);
      border-radius: 3px;
    }

    code[class*=language-],
    pre[class*=language-] {
      color: #ccc;
      background: none;
      font-family: Consolas, Monaco, Andale Mono, Ubuntu Mono, monospace;
      font-size: 1em;
      text-align: left;
      white-space: pre;
      word-spacing: normal;
      word-break: normal;
      word-wrap: normal;
      line-height: 1.5;
      -moz-tab-size: 4;
      -o-tab-size: 4;
      tab-size: 4;
      -webkit-hyphens: none;
      -ms-hyphens: none;
      hyphens: none
    }

    pre[class*=language-] {
      padding: 1em;
      margin: .5em 0;
      overflow: auto
    }

    :not(pre)>code[class*=language-],
    pre[class*=language-] {
      background: #2d2d2d
    }

    :not(pre)>code[class*=language-] {
      padding: .1em;
      border-radius: .3em;
      white-space: normal
    }

    .token.block-comment,
    .token.cdata,
    .token.comment,
    .token.doctype,
    .token.prolog {
      color: #999
    }

    .token.punctuation {
      color: #ccc
    }

    .token.attr-name,
    .token.deleted,
    .token.namespace,
    .token.tag {
      color: #e2777a
    }

    .token.function-name {
      color: #6196cc
    }

    .token.boolean,
    .token.function,
    .token.number {
      color: #f08d49
    }

    .token.class-name,
    .token.constant,
    .token.property,
    .token.symbol {
      color: #f8c555
    }

    .token.atrule,
    .token.builtin,
    .token.important,
    .token.keyword,
    .token.selector {
      color: #cc99cd
    }

    .token.attr-value,
    .token.char,
    .token.regex,
    .token.string,
    .token.variable {
      color: #7ec699
    }

    .token.entity,
    .token.operator,
    .token.url {
      color: #67cdcc
    }

    .token.bold,
    .token.important {
      font-weight: 700
    }

    .token.italic {
      font-style: italic
    }

    .token.entity {
      cursor: help
    }

    .token.inserted {
      color: green
    }

    .theme-default-content code {
      color: #476582;
      padding: .25rem .5rem;
      margin: 0;
      font-size: .85em;
      background-color: rgba(27, 31, 35, .05);
      border-radius: 3px
    }

    .theme-default-content code .token.deleted {
      color: #ec5975
    }

    .theme-default-content code .token.inserted {
      color: #3eaf7c
    }

    .theme-default-content pre,
    .theme-default-content pre[class*=language-] {
      line-height: 1.4;
      padding: 1.25rem 1.5rem;
      margin: .85rem 0;
      background-color: #282c34;
      border-radius: 6px;
      overflow: auto
    }

    .theme-default-content pre[class*=language-] code,
    .theme-default-content pre code {
      color: #fff;
      padding: 0;
      background-color: transparent;
      border-radius: 0
    }

    div[class*=language-] {
      position: relative;
      background-color: #282c34;
      border-radius: 6px;
    }

    div[class*=language-] .highlight-lines {
      -webkit-user-select: none;
      user-select: none;
      padding-top: 1.3rem;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      line-height: 1.4
    }

    div[class*=language-] .highlight-lines .highlighted {
      background-color: rgba(0, 0, 0, .66)
    }

    div[class*=language-] pre,
    div[class*=language-] pre[class*=language-] {
      background: transparent;
      position: relative;
      z-index: 1;
    }

    div[class*=language-]:before {
      position: absolute;
      z-index: 3;
      top: .8em;
      right: 1em;
      font-size: .75rem;
      color: hsla(0, 0%, 100%, .4)
    }

    div[class*=language-]:not(.line-numbers-mode) .line-numbers-wrapper {
      display: none
    }

    div[class*=language-].line-numbers-mode .highlight-lines .highlighted {
      position: relative
    }

    div[class*=language-].line-numbers-mode .highlight-lines .highlighted:before {
      content: " ";
      position: absolute;
      z-index: 3;
      left: 0;
      top: 0;
      display: block;
      width: 3.5rem;
      height: 100%;
      background-color: rgba(0, 0, 0, .66)
    }

    div[class*=language-].line-numbers-mode pre {
      padding-left: 4.5rem;
      vertical-align: middle
    }

    div[class*=language-].line-numbers-mode .line-numbers-wrapper {
      position: absolute;
      top: 0;
      width: 3.5rem;
      text-align: center;
      color: hsla(0, 0%, 100%, .3);
      padding: 1.25rem 0;
      line-height: 1.4
    }

    div[class*=language-].line-numbers-mode .line-numbers-wrapper br {
      -webkit-user-select: none;
      user-select: none
    }

    div[class*=language-].line-numbers-mode .line-numbers-wrapper .line-number {
      position: relative;
      z-index: 4;
      -webkit-user-select: none;
      user-select: none;
      font-size: .85em
    }

    div[class*=language-].line-numbers-mode:after {
      content: "";
      position: absolute;
      z-index: 2;
      top: 0;
      left: 0;
      width: 3.5rem;
      height: 100%;
      border-radius: 6px 0 0 6px;
      border-right: 1px solid rgba(0, 0, 0, .66);
      background-color: #282c34
    }

    div[class~=language-js]:before {
      content: "js"
    }

    div[class~=language-ts]:before {
      content: "ts"
    }

    div[class~=language-html]:before {
      content: "html"
    }

    div[class~=language-md]:before {
      content: "md"
    }

    div[class~=language-vue]:before {
      content: "vue"
    }

    div[class~=language-css]:before {
      content: "css"
    }

    div[class~=language-sass]:before {
      content: "sass"
    }

    div[class~=language-scss]:before {
      content: "scss"
    }

    div[class~=language-less]:before {
      content: "less"
    }

    div[class~=language-stylus]:before {
      content: "stylus"
    }

    div[class~=language-go]:before {
      content: "go"
    }

    div[class~=language-java]:before {
      content: "java"
    }

    div[class~=language-c]:before {
      content: "c"
    }

    div[class~=language-sh]:before {
      content: "sh"
    }

    div[class~=language-yaml]:before {
      content: "yaml"
    }

    div[class~=language-py]:before {
      content: "py"
    }

    div[class~=language-docker]:before {
      content: "docker"
    }

    div[class~=language-dockerfile]:before {
      content: "dockerfile"
    }

    div[class~=language-makefile]:before {
      content: "makefile"
    }

    div[class~=language-javascript]:before {
      content: "js"
    }

    div[class~=language-typescript]:before {
      content: "ts"
    }

    div[class~=language-markup]:before {
      content: "html"
    }

    div[class~=language-markdown]:before {
      content: "md"
    }

    div[class~=language-json]:before {
      content: "json"
    }

    div[class~=language-ruby]:before {
      content: "rb"
    }

    div[class~=language-python]:before {
      content: "py"
    }

    div[class~=language-bash]:before {
      content: "sh"
    }

    div[class~=language-php]:before {
      content: "php"
    }

    .custom-block .custom-block-title {
      font-weight: 600;
      margin-bottom: -.4rem
    }

    .custom-block.danger,
    .custom-block.tip,
    .custom-block.warning {
      padding: .1rem 1.5rem;
      border-left-width: .5rem;
      border-left-style: solid;
      margin: 1rem 0
    }

    .custom-block.tip {
      background-color: #f3f5f7;
      border-color: #42b983
    }

    .custom-block.warning {
      background-color: rgba(255, 229, 100, .3);
      border-color: #e7c000;
      color: #6b5900
    }

    .custom-block.warning .custom-block-title {
      color: #b29400
    }

    .custom-block.warning a {
      color: #2c3e50
    }

    .custom-block.danger {
      background-color: #ffe6e6;
      border-color: #c00;
      color: #4d0000
    }

    .custom-block.danger .custom-block-title {
      color: #900
    }

    .custom-block.danger a {
      color: #2c3e50
    }

    .custom-block.details {
      display: block;
      position: relative;
      border-radius: 2px;
      margin: 1.6em 0;
      padding: 1.6em;
      background-color: #eee
    }

    .custom-block.details h4 {
      margin-top: 0
    }

    .custom-block.details figure:last-child,
    .custom-block.details p:last-child {
      margin-bottom: 0;
      padding-bottom: 0
    }

    .custom-block.details summary {
      outline: none;
      cursor: pointer
    }

    .arrow {
      display: inline-block;
      width: 0;
      height: 0
    }

    .arrow.up {
      border-bottom: 6px solid #ccc
    }

    .arrow.down,
    .arrow.up {
      border-left: 4px solid transparent;
      border-right: 4px solid transparent
    }

    .arrow.down {
      border-top: 6px solid #ccc
    }

    .arrow.right {
      border-left: 6px solid #ccc
    }

    .arrow.left,
    .arrow.right {
      border-top: 4px solid transparent;
      border-bottom: 4px solid transparent
    }

    .arrow.left {
      border-right: 6px solid #ccc
    }

    .theme-default-content:not(.custom) {
      max-width: 740px;
      margin: 0 auto;
      padding: 2rem 2.5rem
    }

    @media (max-width:959px) {
      .theme-default-content:not(.custom) {
        padding: 2rem
      }
    }

    @media (max-width:419px) {
      .theme-default-content:not(.custom) {
        padding: 1.5rem
      }
    }

    .table-of-contents .badge {
      vertical-align: middle
    }

    body,
    html {
      padding: 0;
      margin: 0;
      background-color: #fff
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      font-size: 16px;
      color: #2c3e50
    }

    .page {
      padding-left: 20rem
    }

    .navbar {
      z-index: 20;
      right: 0;
      height: 3.6rem;
      background-color: #fff;
      box-sizing: border-box;
      border-bottom: 1px solid #eaecef
    }

    .navbar,
    .sidebar-mask {
      position: fixed;
      top: 0;
      left: 0
    }

    .sidebar-mask {
      z-index: 9;
      width: 100vw;
      height: 100vh;
      display: none
    }

    .sidebar {
      font-size: 16px;
      background-color: #fff;
      width: 20rem;
      position: fixed;
      z-index: 10;
      margin: 0;
      top: 3.6rem;
      left: 0;
      bottom: 0;
      box-sizing: border-box;
      border-right: 1px solid #eaecef;
      overflow-y: auto
    }

    .theme-default-content:not(.custom)>:first-child {
      margin-top: 3.6rem
    }

    .theme-default-content:not(.custom) a:hover {
      text-decoration: underline
    }

    .theme-default-content:not(.custom) p.demo {
      padding: 1rem 1.5rem;
      border: 1px solid #ddd;
      border-radius: 4px
    }

    .theme-default-content:not(.custom) img {
      max-width: 100%
    }

    .theme-default-content.custom {
      padding: 0;
      margin: 0
    }

    .theme-default-content.custom img {
      max-width: 100%
    }

    a {
      font-weight: 500;
      text-decoration: none
    }

    a,
    p a code {
      color: #3eaf7c
    }

    p a code {
      font-weight: 400
    }

    kbd {
      background: #eee;
      border: .15rem solid #ddd;
      border-bottom: .25rem solid #ddd;
      border-radius: .15rem;
      padding: 0 .15em
    }

    blockquote {
      font-size: 1rem;
      color: #999;
      border-left: .2rem solid #dfe2e5;
      margin: 1rem 0;
      padding: .25rem 0 .25rem 1rem
    }

    blockquote>p {
      margin: 0
    }

    ol,
    ul {
      padding-left: 1.2em
    }

    strong {
      font-weight: 600
    }

    h1,
    h2,
    h3,
    h4,
    h5,
    h6 {
      font-weight: 600;
      line-height: 1.25
    }

    .theme-default-content:not(.custom)>h1,
    .theme-default-content:not(.custom)>h2,
    .theme-default-content:not(.custom)>h3,
    .theme-default-content:not(.custom)>h4,
    .theme-default-content:not(.custom)>h5,
    .theme-default-content:not(.custom)>h6 {
      margin-top: -3.1rem;
      padding-top: 4.6rem;
      margin-bottom: 0
    }

    .theme-default-content:not(.custom)>h1:first-child,
    .theme-default-content:not(.custom)>h2:first-child,
    .theme-default-content:not(.custom)>h3:first-child,
    .theme-default-content:not(.custom)>h4:first-child,
    .theme-default-content:not(.custom)>h5:first-child,
    .theme-default-content:not(.custom)>h6:first-child {
      margin-top: -1.5rem;
      margin-bottom: 1rem
    }

    .theme-default-content:not(.custom)>h1:first-child+.custom-block,
    .theme-default-content:not(.custom)>h1:first-child+p,
    .theme-default-content:not(.custom)>h1:first-child+pre,
    .theme-default-content:not(.custom)>h2:first-child+.custom-block,
    .theme-default-content:not(.custom)>h2:first-child+p,
    .theme-default-content:not(.custom)>h2:first-child+pre,
    .theme-default-content:not(.custom)>h3:first-child+.custom-block,
    .theme-default-content:not(.custom)>h3:first-child+p,
    .theme-default-content:not(.custom)>h3:first-child+pre,
    .theme-default-content:not(.custom)>h4:first-child+.custom-block,
    .theme-default-content:not(.custom)>h4:first-child+p,
    .theme-default-content:not(.custom)>h4:first-child+pre,
    .theme-default-content:not(.custom)>h5:first-child+.custom-block,
    .theme-default-content:not(.custom)>h5:first-child+p,
    .theme-default-content:not(.custom)>h5:first-child+pre,
    .theme-default-content:not(.custom)>h6:first-child+.custom-block,
    .theme-default-content:not(.custom)>h6:first-child+p,
    .theme-default-content:not(.custom)>h6:first-child+pre {
      margin-top: 2rem
    }

    h1:focus .header-anchor,
    h1:hover .header-anchor,
    h2:focus .header-anchor,
    h2:hover .header-anchor,
    h3:focus .header-anchor,
    h3:hover .header-anchor,
    h4:focus .header-anchor,
    h4:hover .header-anchor,
    h5:focus .header-anchor,
    h5:hover .header-anchor,
    h6:focus .header-anchor,
    h6:hover .header-anchor {
      opacity: 1
    }

    h1 {
      font-size: 2.2rem
    }

    h2 {
      font-size: 1.65rem;
      padding-bottom: .3rem;
      border-bottom: 1px solid #eaecef
    }

    h3 {
      font-size: 1.35rem
    }

    a.header-anchor {
      font-size: .85em;
      float: left;
      margin-left: -.87em;
      padding-right: .23em;
      margin-top: .125em;
      opacity: 0
    }

    a.header-anchor:focus,
    a.header-anchor:hover {
      text-decoration: none
    }

    .line-number,
    code,
    kbd {
      font-family: source-code-pro, Menlo, Monaco, Consolas, Courier New, monospace
    }

    ol,
    p,
    ul {
      line-height: 1.7
    }

    hr {
      border: 0;
      border-top: 1px solid #eaecef
    }

    table {
      border-collapse: collapse;
      margin: 1rem 0;
      display: block;
      overflow-x: auto
    }

    tr {
      border-top: 1px solid #dfe2e5
    }

    tr:nth-child(2n) {
      background-color: #f6f8fa
    }

    td,
    th {
      border: 1px solid #dfe2e5;
      padding: .6em 1em
    }

    .theme-container.sidebar-open .sidebar-mask {
      display: block
    }

    .theme-container.no-navbar .theme-default-content:not(.custom)>h1,
    .theme-container.no-navbar h2,
    .theme-container.no-navbar h3,
    .theme-container.no-navbar h4,
    .theme-container.no-navbar h5,
    .theme-container.no-navbar h6 {
      margin-top: 1.5rem;
      padding-top: 0
    }

    .theme-container.no-navbar .sidebar {
      top: 0
    }

    @media (min-width:720px) {
      .theme-container.no-sidebar .sidebar {
        display: none
      }

      .theme-container.no-sidebar .page {
        padding-left: 0
      }
    }

    @media (max-width:959px) {
      .sidebar {
        font-size: 15px;
        width: 16.4rem
      }

      .page {
        padding-left: 16.4rem
      }
    }

    @media (max-width:719px) {
      .sidebar {
        top: 0;
        padding-top: 3.6rem;
        transform: translateX(-100%);
        transition: transform .2s ease
      }

      .page {
        padding-left: 0
      }

      .theme-container.sidebar-open .sidebar {
        transform: translateX(0)
      }

      .theme-container.no-navbar .sidebar {
        padding-top: 0
      }
    }

    @media (max-width:419px) {
      h1 {
        font-size: 1.9rem
      }

      .theme-default-content div[class*=language-] {
        margin: .85rem -1.5rem;
        border-radius: 0
      }
    }

    mark {
      display: none
    }

    #nprogress {
      pointer-events: none
    }

    #nprogress .bar {
      background: #3eaf7c;
      position: fixed;
      z-index: 1031;
      top: 0;
      left: 0;
      width: 100%;
      height: 2px
    }

    #nprogress .peg {
      display: block;
      position: absolute;
      right: 0;
      width: 100px;
      height: 100%;
      box-shadow: 0 0 10px #3eaf7c, 0 0 5px #3eaf7c;
      opacity: 1;
      transform: rotate(3deg) translateY(-4px)
    }

    #nprogress .spinner {
      display: block;
      position: fixed;
      z-index: 1031;
      top: 15px;
      right: 15px
    }

    #nprogress .spinner-icon {
      width: 18px;
      height: 18px;
      box-sizing: border-box;
      border-color: #3eaf7c transparent transparent #3eaf7c;
      border-style: solid;
      border-width: 2px;
      border-radius: 50%;
      -webkit-animation: nprogress-spinner .4s linear infinite;
      animation: nprogress-spinner .4s linear infinite
    }

    .nprogress-custom-parent {
      overflow: hidden;
      position: relative
    }

    .nprogress-custom-parent #nprogress .bar,
    .nprogress-custom-parent #nprogress .spinner {
      position: absolute
    }

    @-webkit-keyframes nprogress-spinner {
      0% {
        transform: rotate(0deg)
      }

      to {
        transform: rotate(1turn)
      }
    }

    @keyframes nprogress-spinner {
      0% {
        transform: rotate(0deg)
      }

      to {
        transform: rotate(1turn)
      }
    }

    .icon.outbound {
      color: #aaa;
      display: inline-block;
      vertical-align: middle;
      position: relative;
      top: -1px
    }

    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border-width: 0
    }

    .home {
      padding: 3.6rem 2rem 0;
      max-width: 960px;
      margin: 0 auto;
      display: block
    }

    .home .hero {
      text-align: center
    }

    .home .hero img {
      max-width: 100%;
      max-height: 280px;
      display: block;
      margin: 3rem auto 1.5rem
    }

    .home .hero h1 {
      font-size: 3rem
    }

    .home .hero .action,
    .home .hero .description,
    .home .hero h1 {
      margin: 1.8rem auto
    }

    .home .hero .description {
      max-width: 35rem;
      font-size: 1.6rem;
      line-height: 1.3;
      color: #6a8bad
    }

    .home .hero .action-button {
      display: inline-block;
      font-size: 1.2rem;
      color: #fff;
      background-color: #3eaf7c;
      padding: .8rem 1.6rem;
      border-radius: 4px;
      transition: background-color .1s ease;
      box-sizing: border-box;
      border-bottom: 1px solid #389d70
    }

    .home .hero .action-button:hover {
      background-color: #4abf8a
    }

    .home .features {
      border-top: 1px solid #eaecef;
      padding: 1.2rem 0;
      margin-top: 2.5rem;
      display: flex;
      flex-wrap: wrap;
      align-items: flex-start;
      align-content: stretch;
      justify-content: space-between
    }

    .home .feature {
      flex-grow: 1;
      flex-basis: 30%;
      max-width: 30%
    }

    .home .feature h2 {
      font-size: 1.4rem;
      font-weight: 500;
      border-bottom: none;
      padding-bottom: 0;
      color: #3a5169
    }

    .home .feature p {
      color: #4e6e8e
    }

    .home .footer {
      padding: 2.5rem;
      border-top: 1px solid #eaecef;
      text-align: center;
      color: #4e6e8e
    }

    @media (max-width:719px) {
      .home .features {
        flex-direction: column
      }

      .home .feature {
        max-width: 100%;
        padding: 0 2.5rem
      }
    }

    @media (max-width:419px) {
      .home {
        padding-left: 1.5rem;
        padding-right: 1.5rem
      }

      .home .hero img {
        max-height: 210px;
        margin: 2rem auto 1.2rem
      }

      .home .hero h1 {
        font-size: 2rem
      }

      .home .hero .action,
      .home .hero .description,
      .home .hero h1 {
        margin: 1.2rem auto
      }

      .home .hero .description {
        font-size: 1.2rem
      }

      .home .hero .action-button {
        font-size: 1rem;
        padding: .6rem 1.2rem
      }

      .home .feature h2 {
        font-size: 1.25rem
      }
    }

    .search-box {
      display: inline-block;
      position: relative;
      margin-right: 1rem
    }

    .search-box input {
      cursor: text;
      width: 10rem;
      height: 2rem;
      color: #4e6e8e;
      display: inline-block;
      border: 1px solid #cfd4db;
      border-radius: 2rem;
      font-size: .9rem;
      line-height: 2rem;
      padding: 0 .5rem 0 2rem;
      outline: none;
      transition: all .2s ease;
      background: #fff url(/assets/img/search.83621669.svg) .6rem .5rem no-repeat;
      background-size: 1rem
    }

    .search-box input:focus {
      cursor: auto;
      border-color: #3eaf7c
    }

    .search-box .suggestions {
      background: #fff;
      width: 20rem;
      position: absolute;
      top: 2rem;
      border: 1px solid #cfd4db;
      border-radius: 6px;
      padding: .4rem;
      list-style-type: none
    }

    .search-box .suggestions.align-right {
      right: 0
    }

    .search-box .suggestion {
      line-height: 1.4;
      padding: .4rem .6rem;
      border-radius: 4px;
      cursor: pointer
    }

    .search-box .suggestion a {
      white-space: normal;
      color: #5d82a6
    }

    .search-box .suggestion a .page-title {
      font-weight: 600
    }

    .search-box .suggestion a .header {
      font-size: .9em;
      margin-left: .25em
    }

    .search-box .suggestion.focused {
      background-color: #f3f4f5
    }

    .search-box .suggestion.focused a {
      color: #3eaf7c
    }

    @media (max-width:959px) {
      .search-box input {
        cursor: pointer;
        width: 0;
        border-color: transparent;
        position: relative
      }

      .search-box input:focus {
        cursor: text;
        left: 0;
        width: 10rem
      }
    }

    @media (-ms-high-contrast:none) {
      .search-box input {
        height: 2rem
      }
    }

    @media (max-width:959px) and (min-width:719px) {
      .search-box .suggestions {
        left: 0
      }
    }

    @media (max-width:719px) {
      .search-box {
        margin-right: 0
      }

      .search-box input {
        left: 1rem
      }

      .search-box .suggestions {
        right: 0
      }
    }

    @media (max-width:419px) {
      .search-box .suggestions {
        width: calc(100vw - 4rem)
      }

      .search-box input:focus {
        width: 8rem
      }
    }

    .sidebar-button {
      cursor: pointer;
      display: none;
      width: 1.25rem;
      height: 1.25rem;
      position: absolute;
      padding: .6rem;
      top: .6rem;
      left: 1rem
    }

    .sidebar-button .icon {
      display: block;
      width: 1.25rem;
      height: 1.25rem
    }

    @media (max-width:719px) {
      .sidebar-button {
        display: block
      }
    }

    .dropdown-enter,
    .dropdown-leave-to {
      height: 0 !important
    }

    .dropdown-wrapper {
      cursor: pointer
    }

    .dropdown-wrapper .dropdown-title,
    .dropdown-wrapper .mobile-dropdown-title {
      display: block;
      font-size: .9rem;
      font-family: inherit;
      cursor: inherit;
      padding: inherit;
      line-height: 1.4rem;
      background: transparent;
      border: none;
      font-weight: 500;
      color: #2c3e50
    }

    .dropdown-wrapper .dropdown-title:hover,
    .dropdown-wrapper .mobile-dropdown-title:hover {
      border-color: transparent
    }

    .dropdown-wrapper .dropdown-title .arrow,
    .dropdown-wrapper .mobile-dropdown-title .arrow {
      vertical-align: middle;
      margin-top: -1px;
      margin-left: .4rem
    }

    .dropdown-wrapper .mobile-dropdown-title {
      display: none;
      font-weight: 600
    }

    .dropdown-wrapper .mobile-dropdown-title font-size inherit:hover {
      color: #3eaf7c
    }

    .dropdown-wrapper .nav-dropdown .dropdown-item {
      color: inherit;
      line-height: 1.7rem
    }

    .dropdown-wrapper .nav-dropdown .dropdown-item h4 {
      margin: .45rem 0 0;
      border-top: 1px solid #eee;
      padding: 1rem 1.5rem .45rem 1.25rem
    }

    .dropdown-wrapper .nav-dropdown .dropdown-item .dropdown-subitem-wrapper {
      padding: 0;
      list-style: none
    }

    .dropdown-wrapper .nav-dropdown .dropdown-item .dropdown-subitem-wrapper .dropdown-subitem {
      font-size: .9em
    }

    .dropdown-wrapper .nav-dropdown .dropdown-item a {
      display: block;
      line-height: 1.7rem;
      position: relative;
      border-bottom: none;
      font-weight: 400;
      margin-bottom: 0;
      padding: 0 1.5rem 0 1.25rem
    }

    .dropdown-wrapper .nav-dropdown .dropdown-item a.router-link-active,
    .dropdown-wrapper .nav-dropdown .dropdown-item a:hover {
      color: #3eaf7c
    }

    .dropdown-wrapper .nav-dropdown .dropdown-item a.router-link-active:after {
      content: "";
      width: 0;
      height: 0;
      border-left: 5px solid #3eaf7c;
      border-top: 3px solid transparent;
      border-bottom: 3px solid transparent;
      position: absolute;
      top: calc(50% - 2px);
      left: 9px
    }

    .dropdown-wrapper .nav-dropdown .dropdown-item:first-child h4 {
      margin-top: 0;
      padding-top: 0;
      border-top: 0
    }

    @media (max-width:719px) {
      .dropdown-wrapper.open .dropdown-title {
        margin-bottom: .5rem
      }

      .dropdown-wrapper .dropdown-title {
        display: none
      }

      .dropdown-wrapper .mobile-dropdown-title {
        display: block
      }

      .dropdown-wrapper .nav-dropdown {
        transition: height .1s ease-out;
        overflow: hidden
      }

      .dropdown-wrapper .nav-dropdown .dropdown-item h4 {
        border-top: 0;
        margin-top: 0;
        padding-top: 0
      }

      .dropdown-wrapper .nav-dropdown .dropdown-item>a,
      .dropdown-wrapper .nav-dropdown .dropdown-item h4 {
        font-size: 15px;
        line-height: 2rem
      }

      .dropdown-wrapper .nav-dropdown .dropdown-item .dropdown-subitem {
        font-size: 14px;
        padding-left: 1rem
      }
    }

    @media (min-width:719px) {
      .dropdown-wrapper {
        height: 1.8rem
      }

      .dropdown-wrapper.open .nav-dropdown,
      .dropdown-wrapper:hover .nav-dropdown {
        display: block !important
      }

      .dropdown-wrapper.open:blur {
        display: none
      }

      .dropdown-wrapper .nav-dropdown {
        display: none;
        height: auto !important;
        box-sizing: border-box;
        max-height: calc(100vh - 2.7rem);
        overflow-y: auto;
        position: absolute;
        top: 100%;
        right: 0;
        background-color: #fff;
        padding: .6rem 0;
        border: 1px solid;
        border-color: #ddd #ddd #ccc;
        text-align: left;
        border-radius: .25rem;
        white-space: nowrap;
        margin: 0
      }
    }

    .nav-links {
      display: inline-block
    }

    .nav-links a {
      line-height: 1.4rem;
      color: inherit
    }

    .nav-links a.router-link-active,
    .nav-links a:hover {
      color: #3eaf7c
    }

    .nav-links .nav-item {
      position: relative;
      display: inline-block;
      margin-left: 1.5rem;
      line-height: 2rem
    }

    .nav-links .nav-item:first-child {
      margin-left: 0
    }

    .nav-links .repo-link {
      margin-left: 1.5rem
    }

    @media (max-width:719px) {

      .nav-links .nav-item,
      .nav-links .repo-link {
        margin-left: 0
      }
    }

    @media (min-width:719px) {

      .nav-links a.router-link-active,
      .nav-links a:hover {
        color: #2c3e50
      }

      .nav-item>a:not(.external).router-link-active,
      .nav-item>a:not(.external):hover {
        margin-bottom: -2px;
        border-bottom: 2px solid #46bd87
      }
    }

    .navbar {
      padding: .7rem 1.5rem;
      line-height: 2.2rem
    }

    .navbar a,
    .navbar img,
    .navbar span {
      display: inline-block
    }

    .navbar .logo {
      height: 2.2rem;
      min-width: 2.2rem;
      margin-right: .8rem;
      vertical-align: top
    }

    .navbar .site-name {
      font-size: 1.3rem;
      font-weight: 600;
      color: #2c3e50;
      position: relative
    }

    .navbar .links {
      padding-left: 1.5rem;
      box-sizing: border-box;
      background-color: #fff;
      white-space: nowrap;
      font-size: .9rem;
      position: absolute;
      right: 1.5rem;
      top: .7rem;
      display: flex
    }

    .navbar .links .search-box {
      flex: 0 0 auto;
      vertical-align: top
    }

    @media (max-width:719px) {
      .navbar {
        padding-left: 4rem
      }

      .navbar .can-hide {
        display: none
      }

      .navbar .links {
        padding-left: 1.5rem
      }

      .navbar .site-name {
        width: calc(100vw - 9.4rem);
        overflow: hidden;
        white-space: nowrap;
        text-overflow: ellipsis
      }
    }

    .page-edit {
      max-width: 740px;
      margin: 0 auto;
      padding: 2rem 2.5rem
    }

    @media (max-width:959px) {
      .page-edit {
        padding: 2rem
      }
    }

    @media (max-width:419px) {
      .page-edit {
        padding: 1.5rem
      }
    }

    .page-edit {
      padding-top: 1rem;
      padding-bottom: 1rem;
      overflow: auto
    }

    .page-edit .edit-link {
      display: inline-block
    }

    .page-edit .edit-link a {
      color: #4e6e8e;
      margin-right: .25rem
    }

    .page-edit .last-updated {
      float: right;
      font-size: .9em
    }

    .page-edit .last-updated .prefix {
      font-weight: 500;
      color: #4e6e8e
    }

    .page-edit .last-updated .time {
      font-weight: 400;
      color: #767676
    }

    @media (max-width:719px) {
      .page-edit .edit-link {
        margin-bottom: .5rem
      }

      .page-edit .last-updated {
        font-size: .8em;
        float: none;
        text-align: left
      }
    }

    .page-nav {
      max-width: 740px;
      margin: 0 auto;
      padding: 2rem 2.5rem
    }

    @media (max-width:959px) {
      .page-nav {
        padding: 2rem
      }
    }

    @media (max-width:419px) {
      .page-nav {
        padding: 1.5rem
      }
    }

    .page-nav {
      padding-top: 1rem;
      padding-bottom: 0
    }

    .page-nav .inner {
      min-height: 2rem;
      margin-top: 0;
      border-top: 1px solid #eaecef;
      padding-top: 1rem;
      overflow: auto
    }

    .page-nav .next {
      float: right
    }

    .page {
      padding-bottom: 2rem;
      display: block
    }

    .sidebar-group .sidebar-group {
      padding-left: .5em
    }

    .sidebar-group:not(.collapsable) .sidebar-heading:not(.clickable) {
      cursor: auto;
      color: inherit
    }

    .sidebar-group.is-sub-group {
      padding-left: 0
    }

    .sidebar-group.is-sub-group>.sidebar-heading {
      font-size: .95em;
      line-height: 1.4;
      font-weight: 400;
      padding-left: 2rem
    }

    .sidebar-group.is-sub-group>.sidebar-heading:not(.clickable) {
      opacity: .5
    }

    .sidebar-group.is-sub-group>.sidebar-group-items {
      padding-left: 1rem
    }

    .sidebar-group.is-sub-group>.sidebar-group-items>li>.sidebar-link {
      font-size: .95em;
      border-left: none
    }

    .sidebar-group.depth-2>.sidebar-heading {
      border-left: none
    }

    .sidebar-heading {
      color: #2c3e50;
      transition: color .15s ease;
      cursor: pointer;
      font-size: 1.1em;
      font-weight: 700;
      padding: .35rem 1.5rem .35rem 1.25rem;
      width: 100%;
      box-sizing: border-box;
      margin: 0;
      border-left: .25rem solid transparent
    }

    .sidebar-heading.open,
    .sidebar-heading:hover {
      color: inherit
    }

    .sidebar-heading .arrow {
      position: relative;
      top: -.12em;
      left: .5em
    }

    .sidebar-heading.clickable.active {
      font-weight: 600;
      color: #3eaf7c;
      border-left-color: #3eaf7c
    }

    .sidebar-heading.clickable:hover {
      color: #3eaf7c
    }

    .sidebar-group-items {
      transition: height .1s ease-out;
      font-size: .95em;
      overflow: hidden
    }

    .sidebar .sidebar-sub-headers {
      padding-left: 1rem;
      font-size: .95em
    }

    a.sidebar-link {
      font-size: 1em;
      font-weight: 400;
      display: inline-block;
      color: #2c3e50;
      border-left: .25rem solid transparent;
      padding: .35rem 1rem .35rem 1.25rem;
      line-height: 1.4;
      width: 100%;
      box-sizing: border-box
    }

    a.sidebar-link:hover {
      color: #3eaf7c
    }

    a.sidebar-link.active {
      font-weight: 600;
      color: #3eaf7c;
      border-left-color: #3eaf7c
    }

    .sidebar-group a.sidebar-link {
      padding-left: 2rem
    }

    .sidebar-sub-headers a.sidebar-link {
      padding-top: .25rem;
      padding-bottom: .25rem;
      border-left: none
    }

    .sidebar-sub-headers a.sidebar-link.active {
      font-weight: 500
    }

    .sidebar ul {
      padding: 0;
      margin: 0;
      list-style-type: none
    }

    .sidebar a {
      display: inline-block
    }

    .sidebar .nav-links {
      display: none;
      border-bottom: 1px solid #eaecef;
      padding: .5rem 0 .75rem
    }

    .sidebar .nav-links a {
      font-weight: 600
    }

    .sidebar .nav-links .nav-item,
    .sidebar .nav-links .repo-link {
      display: block;
      line-height: 1.25rem;
      font-size: 1.1em;
      padding: .5rem 0 .5rem 1.5rem
    }

    .sidebar>.sidebar-links {
      padding: 1.5rem 0
    }

    .sidebar>.sidebar-links>li>a.sidebar-link {
      font-size: 1.1em;
      line-height: 1.7;
      font-weight: 700
    }

    .sidebar>.sidebar-links>li:not(:first-child) {
      margin-top: .75rem
    }

    @media (max-width:719px) {
      .sidebar .nav-links {
        display: block
      }

      .sidebar .nav-links .dropdown-wrapper .nav-dropdown .dropdown-item a.router-link-active:after {
        top: calc(1rem - 2px)
      }

      .sidebar>.sidebar-links {
        padding: 1rem 0
      }
    }

    .badge[data-v-15b7b770] {
      display: inline-block;
      font-size: 14px;
      height: 18px;
      line-height: 18px;
      border-radius: 3px;
      padding: 0 6px;
      color: #fff
    }

    .badge.green[data-v-15b7b770],
    .badge.tip[data-v-15b7b770],
    .badge[data-v-15b7b770] {
      background-color: #42b983
    }

    .badge.error[data-v-15b7b770] {
      background-color: #da5961
    }

    .badge.warn[data-v-15b7b770],
    .badge.warning[data-v-15b7b770],
    .badge.yellow[data-v-15b7b770] {
      background-color: #e7c000
    }

    .badge+.badge[data-v-15b7b770] {
      margin-left: 5px
    }

    .theme-code-block[data-v-759a7d02] {
      display: none
    }

    .theme-code-block__active[data-v-759a7d02] {
      display: block
    }

    .theme-code-block>pre[data-v-759a7d02] {
      background-color: orange
    }

    .theme-code-group__nav[data-v-deefee04] {
      margin-bottom: -35px;
      background-color: #282c34;
      padding-bottom: 22px;
      border-top-left-radius: 6px;
      border-top-right-radius: 6px;
      padding-left: 10px;
      padding-top: 10px
    }

    .theme-code-group__ul[data-v-deefee04] {
      margin: auto 0;
      padding-left: 0;
      display: inline-flex;
      list-style: none
    }

    .theme-code-group__nav-tab[data-v-deefee04] {
      border: 0;
      padding: 5px;
      cursor: pointer;
      background-color: transparent;
      font-size: .85em;
      line-height: 1.4;
      color: hsla(0, 0%, 100%, .9);
      font-weight: 600
    }

    .theme-code-group__nav-tab-active[data-v-deefee04] {
      border-bottom: 1px solid #42b983
    }

    .pre-blank[data-v-deefee04] {
      color: #42b983
    }
  </style>
</head>

<body>
  <div class="theme-default-content content__default">
    <p>本书的宗旨是打造一本严谨、易懂的<code>React</code>源码分析教程。</p>
    <p>为了达到这个目标，在行文上，本书会遵循：</p>
    <ol>
      <li>
        <p>不预设观点 —— 所有观点来自<code>React</code>核心团队成员在公开场合的分享。</p>
      </li>
      <li>
        <p>丰富的参考资料 —— 包括在线Demo、文章、视频。</p>
      </li>
      <li>
        <p>保持更新 —— 在<code>React</code>版本更新后会及时补充。当前版本<code>v17.0.0-alpha</code>。</p>
      </li>
    </ol>
    <h2 id="导学视频"><a href="#导学视频" class="header-anchor">#</a> 导学视频</h2>
    <p>每位同学的基础、学习目的、可支配的学习时间都不同，对于“学习源码”这种需要长期投入的事情，需要慎重考虑投入产出比。</p>
    <p>为此，我在B站录了一期<a href="https://www.bilibili.com/video/BV1Ki4y1u7Vr" target="_blank"
        rel="noopener noreferrer">导学视频<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false"
            x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a>。</p>
    <p>在视频的前半部分，我将“学习源码”划分为5个层次，阐述了：</p>
    <ul>
      <li>
        <p>达到每个层次需要掌握哪些知识</p>
      </li>
      <li>
        <p>怎样最快的掌握这些知识</p>
      </li>
      <li>
        <p>达到这一层次后会收获什么</p>
      </li>
    </ul>
    <p>在学习本书前，你可以结合自身情况做出取舍，有的放矢。</p>
    <p>在视频的后半部分，我会以一个<code>Demo</code>演示<code>React</code>源码的运行流程，为你学习本书内容打下基础。</p>
    <div class="custom-block warning">
      <p class="custom-block-title">视频课程</p>
      <p>文字包含的信息量有限，追求效率的同学可以考虑<a href="https://ke.sifou.com/course/1650000023864436" target="_blank"
          rel="noopener noreferrer">视频课程<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>，由我带着你一起debug源码。</p>
    </div>
    <h2 id="章节说明"><a href="#章节说明" class="header-anchor">#</a> 章节说明</h2>
    <p>
      我们并没有从如<code>ReactDOM.render</code>、<code>this.setState</code>或<code>Hooks</code>等这些日常开发耳熟能详的<code>API</code>入手，而是从<strong>理念</strong>这样比较高的抽象层次开始学习，这是有意为之的。
    </p>
    <p>从理念到架构，从架构到实现，从实现到具体代码。</p>
    <p>这是一个自顶向下、抽象程度递减，符合认知的过程。如果直接讲解API，那么很容易陷入源码的汪洋大海。</p>
    <p>基于此，本书划分为<code>理念篇</code>、<code>架构篇</code>、<code>实现篇</code>。</p>
    <h2 id="章节列表"><a href="#章节列表" class="header-anchor">#</a> 章节列表</h2>
    <h3 id="理念篇"><a href="#理念篇" class="header-anchor">#</a> 理念篇</h3>
    <h4 id="第一章-react理念"><a href="#第一章-react理念" class="header-anchor">#</a> 第一章 React理念</h4>
    <p>✅ React理念</p>
    <p>✅ 老的React架构</p>
    <p>✅ 新的React架构</p>
    <p>✅ Fiber架构的心智模型</p>
    <p>✅ Fiber架构的实现原理</p>
    <p>✅ Fiber架构的工作原理</p>
    <p>✅ 总结</p>
    <h4 id="第二章-前置知识"><a href="#第二章-前置知识" class="header-anchor">#</a> 第二章 前置知识</h4>
    <p>✅ 源码的文件结构</p>
    <p>✅ 调试源码</p>
    <p>✅ 深入理解JSX</p>
    <h3 id="架构篇"><a href="#架构篇" class="header-anchor">#</a> 架构篇</h3>
    <h4 id="第三章-render阶段"><a href="#第三章-render阶段" class="header-anchor">#</a> 第三章 render阶段</h4>
    <p>✅ 流程概览</p>
    <p>✅ beginWork</p>
    <p>✅ completeWork</p>
    <h4 id="第四章-commit阶段"><a href="#第四章-commit阶段" class="header-anchor">#</a> 第四章 commit阶段</h4>
    <p>✅ 流程概览</p>
    <p>✅ before mutation阶段</p>
    <p>✅ mutation阶段</p>
    <p>✅ layout阶段</p>
    <h3 id="实现篇"><a href="#实现篇" class="header-anchor">#</a> 实现篇</h3>
    <h4 id="第五章-diff算法"><a href="#第五章-diff算法" class="header-anchor">#</a> 第五章 Diff算法</h4>
    <p>✅ 概览</p>
    <p>✅ 单节点Diff</p>
    <p>✅ 多节点Diff</p>
    <h4 id="第六章-状态更新"><a href="#第六章-状态更新" class="header-anchor">#</a> 第六章 状态更新</h4>
    <p>✅ 流程概览</p>
    <p>✅ 心智模型</p>
    <p>✅ Update</p>
    <p>✅ 深入理解优先级</p>
    <p>✅ ReactDOM.render</p>
    <p>✅ this.setState</p>
    <h4 id="第七章-hooks"><a href="#第七章-hooks" class="header-anchor">#</a> 第七章 Hooks</h4>
    <p>✅ Hooks理念</p>
    <p>✅ 极简Hooks实现</p>
    <p>✅ Hooks数据结构</p>
    <p>✅ useState与useReducer</p>
    <p>✅ useEffect</p>
    <p>✅ useRef</p>
    <p>✅ useMemo与useCallback</p>
    <h4 id="第八章-concurrent-mode"><a href="#第八章-concurrent-mode" class="header-anchor">#</a> 第八章 Concurrent Mode</h4>
    <p>✅ 概览</p>
    <p>✅ Scheduler的原理与实现</p>
    <p>✅ lane模型</p>
    <p>📝 异步可中断更新</p>
    <p>📝 高优任务打断机制</p>
    <p>📝 batchedUpdates</p>
    <p>📝 Suspense</p>
  </div>
  <div class="theme-default-content content__default">
    <p>软件的设计是为了服务理念。只有懂了设计理念，才能明白为了实现这样的理念需要如何架构。</p>
    <p>所以，在我们深入源码架构之前，先来聊聊<code>React</code>理念。</p>
    <h2 id="react理念"><a href="#react理念" class="header-anchor">#</a> React理念</h2>
    <p>我们可以从<a href="https://zh-hans.reactjs.org/docs/thinking-in-react.html" target="_blank"
        rel="noopener noreferrer">官网<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false"
            x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a>看到<code>React</code>的理念：</p>
    <blockquote>
      <p>我们认为，React 是用 JavaScript 构建<strong>快速响应</strong>的大型 Web 应用程序的首选方式。它在 Facebook 和 Instagram 上表现优秀。</p>
    </blockquote>
    <p>可见，关键是实现<code>快速响应</code>。那么制约<code>快速响应</code>的因素是什么呢？</p>
    <p>我们日常使用App，浏览网页时，有两类场景会制约<code>快速响应</code>：</p>
    <ul>
      <li>
        <p>当遇到大计算量的操作或者设备性能不足使页面掉帧，导致卡顿。</p>
      </li>
      <li>
        <p>发送网络请求后，由于需要等待数据返回才能进一步操作导致不能快速响应。</p>
      </li>
    </ul>
    <p>这两类场景可以概括为：</p>
    <ul>
      <li>
        <p>CPU的瓶颈</p>
      </li>
      <li>
        <p>IO的瓶颈</p>
      </li>
    </ul>
    <p><code>React</code>是如何解决这两个瓶颈的呢？</p>
    <h2 id="cpu的瓶颈"><a href="#cpu的瓶颈" class="header-anchor">#</a> CPU的瓶颈</h2>
    <p>当项目变得庞大、组件数量繁多时，就容易遇到CPU的瓶颈。</p>
    <p>考虑如下Demo，我们向视图中渲染3000个<code>li</code>：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> len <span class="token operator">=</span> <span class="token number">3000</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>ul<span class="token operator">&gt;</span>
      <span class="token punctuation">{</span><span class="token function">Array</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">_<span class="token punctuation">,</span> i</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token operator">&lt;</span>li<span class="token operator">&gt;</span><span class="token punctuation">{</span>i<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> rootEl <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">"#root"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>App<span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> rootEl<span class="token punctuation">)</span><span class="token punctuation">;</span>  
</code></pre>
    </div>
    <p>主流浏览器刷新频率为60Hz，即每（1000ms / 60Hz）16.6ms浏览器刷新一次。</p>
    <p>
      我们知道，JS可以操作DOM，<code>GUI渲染线程</code>与<code>JS线程</code>是互斥的。所以<strong>JS脚本执行</strong>和<strong>浏览器布局、绘制</strong>不能同时执行。
    </p>
    <p>在每16.6ms时间内，需要完成如下工作：</p>
    <div class="language- extra-class">
      <pre class="language-text"><code>JS脚本执行 -----  样式布局 ----- 样式绘制
</code></pre>
    </div>
    <p>当JS执行时间过长，超出了16.6ms，这次刷新就没有时间执行<strong>样式布局</strong>和<strong>样式绘制</strong>了。</p>
    <p>在Demo中，由于组件数量繁多（3000个），JS脚本执行时间过长，页面掉帧，造成卡顿。</p>
    <p>可以从打印的执行堆栈图看到，JS执行时间为73.65ms，远远多于一帧的时间。</p> <img src="https://react.iamkasong.com/img/long-task.png" alt="长任务">
    <p>如何解决这个问题呢？</p>
    <p>答案是：在浏览器每一帧的时间中，预留一些时间给JS线程，<code>React</code>利用这部分时间更新组件（可以看到，在<a
        href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/scheduler/src/forks/SchedulerHostConfig.default.js#L119"
        target="_blank" rel="noopener noreferrer">源码<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
            focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a>中，预留的初始时间是5ms）。</p>
    <p>当预留的时间不够用时，<code>React</code>将线程控制权交还给浏览器使其有时间渲染UI，<code>React</code>则等待下一帧时间到来继续被中断的工作。</p>
    <blockquote>
      <p>这种将长任务分拆到每一帧中，像蚂蚁搬家一样一次执行一小段任务的操作，被称为<code>时间切片</code>（time slice）</p>
    </blockquote>
    <p>接下来我们开启<code>Concurrent Mode</code>（后续章节会讲到，当前你只需了解开启后会启用<code>时间切片</code>）：</p>
    <div class="language-js extra-class">
      <div class="highlight-lines"><br><br>
        <div class="highlighted">&nbsp;</div><br>
      </div>
      <pre class="language-js"><code><span class="token comment">// 通过使用ReactDOM.unstable_createRoot开启Concurrent Mode</span>
<span class="token comment">// ReactDOM.render(&lt;App/&gt;, rootEl);  </span>
ReactDOM<span class="token punctuation">.</span><span class="token function">unstable_createRoot</span><span class="token punctuation">(</span>rootEl<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>App<span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    </div>
    <p>
      此时我们的长任务被拆分到每一帧不同的<code>task</code>中，<code>JS脚本</code>执行时间大体在<code>5ms</code>左右，这样浏览器就有剩余时间执行<strong>样式布局</strong>和<strong>样式绘制</strong>，减少掉帧的可能性。
    </p> <img src="https://react.iamkasong.com/img/time-slice.png" alt="长任务">
    <p>
      所以，解决<code>CPU瓶颈</code>的关键是实现<code>时间切片</code>，而<code>时间切片</code>的关键是：将<strong>同步的更新</strong>变为<strong>可中断的异步更新</strong>。
    </p>
    <details class="custom-block details">
      <summary>同步更新 vs 异步更新 Demo</summary>
      <p>我们有个更新很耗时的大列表，让我们看看<strong>同步更新</strong>和<strong>异步更新</strong>时，输入框的响应速度</p>
      <p><a href="/me.html">关注公众号</a>，后台回复<strong>323</strong>获得在线Demo地址</p>
      <p>可以从Demo看到，当牺牲了列表的更新速度，<code>React</code>大幅提高了输入响应速度，使交互更自然。</p>
    </details>
    <h2 id="io的瓶颈"><a href="#io的瓶颈" class="header-anchor">#</a> IO的瓶颈</h2>
    <p><code>网络延迟</code>是前端开发者无法解决的。如何在<code>网络延迟</code>客观存在的情况下，减少用户对<code>网络延迟</code>的感知？</p>
    <p><code>React</code>给出的答案是<a
        href="https://zh-hans.reactjs.org/docs/concurrent-mode-intro.html#putting-research-into-production"
        target="_blank" rel="noopener noreferrer">将人机交互研究的结果整合到真实的 UI 中<span><svg xmlns="http://www.w3.org/2000/svg"
            aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"
            class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a>。</p>
    <p>这里我们以业界人机交互最顶尖的苹果举例，在IOS系统中：</p>
    <p>点击“设置”面板中的“通用”，进入“通用”界面：</p> <img src="https://react.iamkasong.com/img/legacy-move.gif" alt="同步">
    <p>作为对比，再点击“设置”面板中的“Siri与搜索”，进入“Siri与搜索”界面：</p> <img src="https://react.iamkasong.com/img/concurrent-mov.gif"
      alt="异步">
    <p>你能感受到两者体验上的区别么？</p>
    <p>事实上，点击“通用”后的交互是同步的，直接显示后续界面。而点击“Siri与搜索”后的交互是异步的，需要等待请求返回后再显示后续界面。但从用户感知来看，这两者的区别微乎其微。</p>
    <p>这里的窍门在于：点击“Siri与搜索”后，先在当前页面停留了一小段时间，这一小段时间被用来请求数据。</p>
    <p>当“这一小段时间”足够短时，用户是无感知的。如果请求时间超过一个范围，再显示<code>loading</code>的效果。</p>
    <p>试想如果我们一点击“Siri与搜索”就显示<code>loading</code>效果，即使数据请求时间很短，<code>loading</code>效果一闪而过。用户也是可以感知到的。</p>
    <p>为此，<code>React</code>实现了<a href="https://zh-hans.reactjs.org/docs/concurrent-mode-suspense.html" target="_blank"
        rel="noopener noreferrer">Suspense<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
            focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a>功能及配套的<code>hook</code>——<a
        href="https://zh-hans.reactjs.org/docs/concurrent-mode-reference.html#usedeferredvalue" target="_blank"
        rel="noopener noreferrer">useDeferredValue<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
            focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a>。</p>
    <p>而在源码内部，为了支持这些特性，同样需要将<strong>同步的更新</strong>变为<strong>可中断的异步更新</strong>。</p>
    <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2>
    <p>通过以上内容，我们可以看到，<code>React</code>为了践行“构建<strong>快速响应</strong>的大型 Web 应用程序”理念做出的努力。</p>
    <p>其中的关键是解决CPU的瓶颈与IO的瓶颈。而落实到实现上，则需要将<strong>同步的更新</strong>变为<strong>可中断的异步更新</strong>。</p>
    <h2 id="参考资料"><a href="#参考资料" class="header-anchor">#</a> 参考资料</h2>
    <p><a href="https://www.bilibili.com/video/BV134411c7Sk?from=search&amp;seid=17404881291635824595" target="_blank"
        rel="noopener noreferrer">「英文」尤雨溪论JavaScript框架设计哲学：平衡<span><svg xmlns="http://www.w3.org/2000/svg"
            aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"
            class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a></p>
  </div>
  <div class="theme-default-content content__default">
    <p>在上一节中我们了解了<code>React</code>的理念，简单概括就是<strong>快速响应</strong>。</p>
    <p><code>React</code>从v15升级到v16后重构了整个架构。本节我们聊聊v15，看看他为什么不能满足<strong>快速响应</strong>的理念，以至于被重构。</p>
    <h2 id="react15架构"><a href="#react15架构" class="header-anchor">#</a> React15架构</h2>
    <p>React15架构可以分为两层：</p>
    <ul>
      <li>Reconciler（协调器）—— 负责找出变化的组件</li>
      <li>Renderer（渲染器）—— 负责将变化的组件渲染到页面上</li>
    </ul>
    <h3 id="reconciler-协调器"><a href="#reconciler-协调器" class="header-anchor">#</a> Reconciler（协调器）</h3>
    <p>
      我们知道，在<code>React</code>中可以通过<code>this.setState</code>、<code>this.forceUpdate</code>、<code>ReactDOM.render</code>等API触发更新。
    </p>
    <p>每当有更新发生时，<strong>Reconciler</strong>会做如下工作：</p>
    <ul>
      <li>调用函数组件、或class组件的<code>render</code>方法，将返回的JSX转化为虚拟DOM</li>
      <li>将虚拟DOM和上次更新时的虚拟DOM对比</li>
      <li>通过对比找出本次更新中变化的虚拟DOM</li>
      <li>通知<strong>Renderer</strong>将变化的虚拟DOM渲染到页面上</li>
    </ul>
    <blockquote>
      <p>你可以在<a href="https://zh-hans.reactjs.org/docs/codebase-overview.html#reconcilers" target="_blank"
          rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false"
              x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new
              window)</span></span></a>看到<code>React</code>官方对<strong>Reconciler</strong>的解释</p>
    </blockquote>
    <h3 id="renderer-渲染器"><a href="#renderer-渲染器" class="header-anchor">#</a> Renderer（渲染器）</h3>
    <p>由于<code>React</code>支持跨平台，所以不同平台有不同的<strong>Renderer</strong>。我们前端最熟悉的是负责在浏览器环境渲染的<strong>Renderer</strong> —— <a
        href="https://www.npmjs.com/package/react-dom" target="_blank" rel="noopener noreferrer">ReactDOM<span><svg
            xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px"
            viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a>。</p>
    <p>除此之外，还有：</p>
    <ul>
      <li><a href="https://www.npmjs.com/package/react-native" target="_blank"
          rel="noopener noreferrer">ReactNative<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>渲染器，渲染App原生组件</li>
      <li><a href="https://www.npmjs.com/package/react-test-Renderer" target="_blank"
          rel="noopener noreferrer">ReactTest<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>渲染器，渲染出纯Js对象用于测试</li>
      <li><a href="https://www.npmjs.com/package/react-art" target="_blank" rel="noopener noreferrer">ReactArt<span><svg
              xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px"
              viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>渲染器，渲染到Canvas, SVG 或 VML (IE8)</li>
    </ul>
    <p>在每次更新发生时，<strong>Renderer</strong>接到<strong>Reconciler</strong>通知，将变化的组件渲染在当前宿主环境。</p>
    <blockquote>
      <p>你可以在<a href="https://zh-hans.reactjs.org/docs/codebase-overview.html#renderers" target="_blank"
          rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false"
              x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new
              window)</span></span></a>看到<code>React</code>官方对<strong>Renderer</strong>的解释</p>
    </blockquote>
    <h2 id="react15架构的缺点"><a href="#react15架构的缺点" class="header-anchor">#</a> React15架构的缺点</h2>
    <p>在<strong>Reconciler</strong>中，<code>mount</code>的组件会调用<a
        href="https://github.com/facebook/react/blob/15-stable/src/renderers/dom/shared/ReactDOMComponent.js#L498"
        target="_blank" rel="noopener noreferrer">mountComponent<span><svg xmlns="http://www.w3.org/2000/svg"
            aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"
            class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a>，<code>update</code>的组件会调用<a
        href="https://github.com/facebook/react/blob/15-stable/src/renderers/dom/shared/ReactDOMComponent.js#L877"
        target="_blank" rel="noopener noreferrer">updateComponent<span><svg xmlns="http://www.w3.org/2000/svg"
            aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"
            class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a>。这两个方法都会递归更新子组件。</p>
    <h3 id="递归更新的缺点"><a href="#递归更新的缺点" class="header-anchor">#</a> 递归更新的缺点</h3>
    <p>由于递归执行，所以更新一旦开始，中途就无法中断。当层级很深时，递归更新时间超过了16ms，用户交互就会卡顿。</p>
    <p>在上一节中，我们已经提出了解决办法——用<strong>可中断的异步更新</strong>代替<strong>同步的更新</strong>。那么React15的架构支持异步更新么？让我们看一个例子：</p>
    <details class="custom-block details">
      <summary>乘法小Demo</summary>
      <p><a href="/me.html">关注公众号</a>，后台回复<strong>222</strong>获得在线Demo地址</p>
      <p>初始化时<code>state.count = 1</code>，每次点击按钮<code>state.count++</code></p>
      <p>列表中3个元素的值分别为1，2，3乘以<code>state.count</code>的结果</p>
    </details>
    <p>我用红色标注了更新的步骤。
      <img src="https://react.iamkasong.com/img/v15.png" alt="更新流程">
    </p>
    <p>
      我们可以看到，<strong>Reconciler</strong>和<strong>Renderer</strong>是交替工作的，当第一个<code>li</code>在页面上已经变化后，第二个<code>li</code>再进入<strong>Reconciler</strong>。
    </p>
    <p>由于整个过程都是同步的，所以在用户看来所有DOM是同时更新的。</p>
    <p>接下来，让我们模拟一下，如果中途中断更新会怎么样？</p>
    <div class="custom-block danger">
      <p class="custom-block-title">注意</p>
      <p>以下是我们模拟中断的情况，实际上<code>React15</code>并不会中断进行中的更新</p>
    </div> <img src="https://react.iamkasong.com/img/dist.png" alt="中断更新流程">
    <p>当第一个<code>li</code>完成更新时中断更新，即步骤3完成后中断更新，此时后面的步骤都还未执行。</p>
    <p>用户本来期望<code>123</code>变为<code>246</code>。实际却看见更新不完全的DOM！（即<code>223</code>）</p>
    <p>基于这个原因，<code>React</code>决定重写整个架构。</p>
  </div>
  <div class="theme-default-content content__default">
    <p>上一节我们聊到React15架构不能支撑异步更新以至于需要重构。那么这一节我们来学习重构后的React16是如何支持异步更新的。</p>
    <h2 id="react16架构"><a href="#react16架构" class="header-anchor">#</a> React16架构</h2>
    <p>React16架构可以分为三层：</p>
    <ul>
      <li>Scheduler（调度器）—— 调度任务的优先级，高优任务优先进入<strong>Reconciler</strong></li>
      <li>Reconciler（协调器）—— 负责找出变化的组件</li>
      <li>Renderer（渲染器）—— 负责将变化的组件渲染到页面上</li>
    </ul>
    <p>可以看到，相较于React15，React16中新增了<strong>Scheduler（调度器）</strong>，让我们来了解下他。</p>
    <h3 id="scheduler-调度器"><a href="#scheduler-调度器" class="header-anchor">#</a> Scheduler（调度器）</h3>
    <p>既然我们以浏览器是否有剩余时间作为任务中断的标准，那么我们需要一种机制，当浏览器有剩余时间时通知我们。</p>
    <p>其实部分浏览器已经实现了这个API，这就是<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback"
        target="_blank" rel="noopener noreferrer">requestIdleCallback<span><svg xmlns="http://www.w3.org/2000/svg"
            aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"
            class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a>。但是由于以下因素，<code>React</code>放弃使用：</p>
    <ul>
      <li>浏览器兼容性</li>
      <li>触发频率不稳定，受很多因素影响。比如当我们的浏览器切换tab后，之前tab注册的<code>requestIdleCallback</code>触发的频率会变得很低</li>
    </ul>
    <p>
      基于以上原因，<code>React</code>实现了功能更完备的<code>requestIdleCallback</code>polyfill，这就是<strong>Scheduler</strong>。除了在空闲时触发回调的功能外，<strong>Scheduler</strong>还提供了多种调度优先级供任务设置。
    </p>
    <blockquote>
      <p><a
          href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/scheduler/README.md"
          target="_blank" rel="noopener noreferrer">Scheduler<span><svg xmlns="http://www.w3.org/2000/svg"
              aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"
              class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>是独立于<code>React</code>的库</p>
    </blockquote>
    <h3 id="reconciler-协调器"><a href="#reconciler-协调器" class="header-anchor">#</a> Reconciler（协调器）</h3>
    <p>我们知道，在React15中<strong>Reconciler</strong>是递归处理虚拟DOM的。让我们看看<a
        href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1673"
        target="_blank" rel="noopener noreferrer">React16的Reconciler<span><svg xmlns="http://www.w3.org/2000/svg"
            aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"
            class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a>。</p>
    <p>我们可以看见，更新工作从递归变成了可以中断的循环过程。每次循环都会调用<code>shouldYield</code>判断当前是否有剩余时间。</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token comment">/** @noinline */</span>
<span class="token keyword">function</span> <span class="token function">workLoopConcurrent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Perform work until Scheduler asks us to yield</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>workInProgress <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">shouldYield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    workInProgress <span class="token operator">=</span> <span class="token function">performUnitOfWork</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <p>那么React16是如何解决中断更新时DOM渲染不完全的问题呢？</p>
    <p>
      在React16中，<strong>Reconciler</strong>与<strong>Renderer</strong>不再是交替工作。当<strong>Scheduler</strong>将任务交给<strong>Reconciler</strong>后，<strong>Reconciler</strong>会为变化的虚拟DOM打上代表增/删/更新的标记，类似这样：
    </p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">const</span> Placement <span class="token operator">=</span> <span class="token comment">/*             */</span> <span class="token number">0b0000000000010</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> Update <span class="token operator">=</span> <span class="token comment">/*                */</span> <span class="token number">0b0000000000100</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> PlacementAndUpdate <span class="token operator">=</span> <span class="token comment">/*    */</span> <span class="token number">0b0000000000110</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> Deletion <span class="token operator">=</span> <span class="token comment">/*              */</span> <span class="token number">0b0000000001000</span><span class="token punctuation">;</span>
</code></pre>
    </div>
    <blockquote>
      <p>全部的标记见<a
          href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactSideEffectTags.js"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a></p>
    </blockquote>
    <p>
      整个<strong>Scheduler</strong>与<strong>Reconciler</strong>的工作都在内存中进行。只有当所有组件都完成<strong>Reconciler</strong>的工作，才会统一交给<strong>Renderer</strong>。
    </p>
    <blockquote>
      <p>你可以在<a href="https://zh-hans.reactjs.org/docs/codebase-overview.html#fiber-reconciler" target="_blank"
          rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false"
              x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new
              window)</span></span></a>看到<code>React</code>官方对React16新<strong>Reconciler</strong>的解释</p>
    </blockquote>
    <h3 id="renderer-渲染器"><a href="#renderer-渲染器" class="header-anchor">#</a> Renderer（渲染器）</h3>
    <p><strong>Renderer</strong>根据<strong>Reconciler</strong>为虚拟DOM打的标记，同步执行对应的DOM操作。</p>
    <p>所以，对于我们在上一节使用过的Demo</p>
    <details class="custom-block details">
      <summary>乘法小Demo</summary>
      <p><a href="/me.html">关注公众号</a>，后台回复<strong>222</strong>获得在线Demo地址</p>
      <p><code>state.count = 1</code>，每次点击按钮<code>state.count++</code></p>
      <p>列表中3个元素的值分别为1，2，3乘以<code>state.count</code>的结果</p>
    </details>
    <p>在React16架构中整个更新流程为：</p> <img src="https://react.iamkasong.com/img/process.png" alt="更新流程">
    <p>其中红框中的步骤随时可能由于以下原因被中断：</p>
    <ul>
      <li>有其他更高优任务需要先更新</li>
      <li>当前帧没有剩余时间</li>
    </ul>
    <p>由于红框中的工作都在内存中进行，不会更新页面上的DOM，所以即使反复中断，用户也不会看见更新不完全的DOM（即上一节演示的情况）。</p>
    <blockquote>
      <p>实际上，由于<strong>Scheduler</strong>和<strong>Reconciler</strong>都是平台无关的，所以<code>React</code>为他们单独发了一个包<a
          href="https://www.npmjs.com/package/react-reconciler" target="_blank"
          rel="noopener noreferrer">react-Reconciler<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new
              window)</span></span></a>。你可以用这个包自己实现一个<code>ReactDOM</code>，具体见<strong>参考资料</strong></p>
    </blockquote>
    <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2>
    <p>通过本节我们知道了<code>React16</code>采用新的<code>Reconciler</code>。</p>
    <p><code>Reconciler</code>内部采用了<code>Fiber</code>的架构。</p>
    <p><code>Fiber</code>是什么？他和<code>Reconciler</code>或者说和<code>React</code>之间是什么关系？我们会在接下来三节解答。</p>
    <h2 id="参考资料"><a href="#参考资料" class="header-anchor">#</a> 参考资料</h2>
    <p><a href="https://www.youtube.com/watch?v=CGpMlWVcHok&amp;list=PLPxbbTqCLbGHPxZpw4xj_Wwg8-fdNxJRh&amp;index=7"
        target="_blank" rel="noopener noreferrer">「英文 外网」Building a Custom React Renderer | React前经理Sophie
        Alpert<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px"
            viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a></p>
    <details class="custom-block details">
      <summary>同步/Debounce/Throttle/并发 情况下性能对比Demo</summary>
      <p><a href="/me.html">关注公众号</a>，后台回复<strong>323</strong>获得在线Demo地址</p>
    </details>
  </div>
  <div class="theme-default-content content__default">
    <p>React核心团队成员<a href="https://github.com/sebmarkbage/" target="_blank" rel="noopener noreferrer">Sebastian
        Markbåge<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px"
            viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new
            window)</span></span></a>（<code>React Hooks</code>的发明者）曾说：我们在<code>React</code>中做的就是践行<code>代数效应</code>（Algebraic
      Effects）。</p>
    <p>那么，<code>代数效应</code>是什么呢？他和<code>React</code>有什么关系呢。</p>
    <h2 id="什么是代数效应"><a href="#什么是代数效应" class="header-anchor">#</a> 什么是代数效应</h2>
    <p><code>代数效应</code>是<code>函数式编程</code>中的一个概念，用于将<code>副作用</code>从<code>函数</code>调用中分离。</p>
    <p>接下来我们用<code>虚构的语法</code>来解释。</p>
    <p>假设我们有一个函数<code>getTotalPicNum</code>，传入2个<code>用户名称</code>后，分别查找该用户在平台保存的图片数量，最后将图片数量相加后返回。</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">getTotalPicNum</span><span class="token punctuation">(</span><span class="token parameter">user1<span class="token punctuation">,</span> user2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> picNum1 <span class="token operator">=</span> <span class="token function">getPicNum</span><span class="token punctuation">(</span>user1<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> picNum2 <span class="token operator">=</span> <span class="token function">getPicNum</span><span class="token punctuation">(</span>user2<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> picNum1 <span class="token operator">+</span> picNum2<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <p>在<code>getTotalPicNum</code>中，我们不关注<code>getPicNum</code>的实现，只在乎“获取到两个数字后将他们相加的结果返回”这一过程。</p>
    <p>接下来我们来实现<code>getPicNum</code>。</p>
    <p>"用户在平台保存的图片数量"是保存在服务器中的。所以，为了获取该值，我们需要发起异步请求。</p>
    <p>为了尽量保持<code>getTotalPicNum</code>的调用方式不变，我们首先想到了使用<code>async await</code>：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">getTotalPicNum</span><span class="token punctuation">(</span><span class="token parameter">user1<span class="token punctuation">,</span> user2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> picNum1 <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">getPicNum</span><span class="token punctuation">(</span>user1<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> picNum2 <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">getPicNum</span><span class="token punctuation">(</span>user2<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> picNum1 <span class="token operator">+</span> picNum2<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <p>但是，<code>async await</code>是有<code>传染性</code>的 ——
      当一个函数变为<code>async</code>后，这意味着调用他的函数也需要是<code>async</code>，这破坏了<code>getTotalPicNum</code>的同步特性。</p>
    <p>有没有什么办法能保持<code>getTotalPicNum</code>保持现有调用方式不变的情况下实现异步请求呢？</p>
    <p>没有。不过我们可以<code>虚构</code>一个。</p>
    <p>我们虚构一个类似<code>try...catch</code>的语法 —— <code>try...handle</code>与两个操作符<code>perform</code>、<code>resume</code>。
    </p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">getPicNum</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> picNum <span class="token operator">=</span> perform name<span class="token punctuation">;</span>
  <span class="token keyword">return</span> picNum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">try</span> <span class="token punctuation">{</span>
  <span class="token function">getTotalPicNum</span><span class="token punctuation">(</span><span class="token string">'kaSong'</span><span class="token punctuation">,</span> <span class="token string">'xiaoMing'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token function">handle</span> <span class="token punctuation">(</span><span class="token parameter">who</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>who<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token string">'kaSong'</span><span class="token operator">:</span>
      resume <span class="token keyword">with</span> <span class="token number">230</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token string">'xiaoMing'</span><span class="token operator">:</span>
      resume <span class="token keyword">with</span> <span class="token number">122</span><span class="token punctuation">;</span>
    <span class="token keyword">default</span><span class="token operator">:</span>
      resume <span class="token keyword">with</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <p>当执行到<code>getTotalPicNum</code>内部的<code>getPicNum</code>方法时，会执行<code>perform name</code>。</p>
    <p>
      此时函数调用栈会从<code>getPicNum</code>方法内跳出，被最近一个<code>try...handle</code>捕获。类似<code>throw Error</code>后被最近一个<code>try...catch</code>捕获。
    </p>
    <p>
      类似<code>throw Error</code>后<code>Error</code>会作为<code>catch</code>的参数，<code>perform name</code>后<code>name</code>会作为<code>handle</code>的参数。
    </p>
    <p>
      与<code>try...catch</code>最大的不同在于：当<code>Error</code>被<code>catch</code>捕获后，之前的调用栈就销毁了。而<code>handle</code>执行<code>resume</code>后会回到之前<code>perform</code>的调用栈。
    </p>
    <p>
      对于<code>case 'kaSong'</code>，执行完<code>resume with 230;</code>后调用栈会回到<code>getPicNum</code>，此时<code>picNum === 230</code>
    </p>
    <div class="custom-block warning">
      <p class="custom-block-title">注意</p>
      <p>再次申明，<code>try...handle</code>的语法是虚构的，只是为了演示<code>代数效应</code>的思想。</p>
    </div>
    <p>总结一下：<code>代数效应</code>能够将<code>副作用</code>（例子中为<code>请求图片数量</code>）从函数逻辑中分离，使函数关注点保持纯粹。</p>
    <p>并且，从例子中可以看出，<code>perform resume</code>不需要区分同步异步。</p>
    <h2 id="代数效应在react中的应用"><a href="#代数效应在react中的应用" class="header-anchor">#</a> 代数效应在React中的应用</h2>
    <p>那么<code>代数效应</code>与<code>React</code>有什么关系呢？最明显的例子就是<code>Hooks</code>。</p>
    <p>
      对于类似<code>useState</code>、<code>useReducer</code>、<code>useRef</code>这样的<code>Hook</code>，我们不需要关注<code>FunctionComponent</code>的<code>state</code>在<code>Hook</code>中是如何保存的，<code>React</code>会为我们处理。
    </p>
    <p>我们只需要假设<code>useState</code>返回的是我们想要的<code>state</code>，并编写业务逻辑就行。</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>num<span class="token punctuation">,</span> updateNum<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">updateNum</span><span class="token punctuation">(</span><span class="token parameter">num</span> <span class="token operator">=&gt;</span> num <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>num<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>  
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <p>如果这个例子还不够明显，可以看看官方的<a href="https://codesandbox.io/s/frosty-hermann-bztrp?file=/src/index.js:152-160"
        target="_blank" rel="noopener noreferrer">Suspense Demo<span><svg xmlns="http://www.w3.org/2000/svg"
            aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"
            class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a></p>
    <p>在<code>Demo</code>中<code>ProfileDetails</code>用于展示<code>用户名称</code>。而<code>用户名称</code>是<code>异步请求</code>的。</p>
    <p>但是<code>Demo</code>中完全是<code>同步</code>的写法。</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">ProfileDetails</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> user <span class="token operator">=</span> resource<span class="token punctuation">.</span>user<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span><span class="token punctuation">{</span>user<span class="token punctuation">.</span>name<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <h2 id="代数效应与generator"><a href="#代数效应与generator" class="header-anchor">#</a> 代数效应与Generator</h2>
    <p>
      从<code>React15</code>到<code>React16</code>，协调器（<code>Reconciler</code>）重构的一大目的是：将老的<code>同步更新</code>的架构变为<code>异步可中断更新</code>。
    </p>
    <p><code>异步可中断更新</code>可以理解为：<code>更新</code>在执行过程中可能会被打断（浏览器时间分片用尽或有更高优任务插队），当可以继续执行时恢复之前执行的中间状态。</p>
    <p>这就是<code>代数效应</code>中<code>try...handle</code>的作用。</p>
    <p>其实，浏览器原生就支持类似的实现，这就是<code>Generator</code>。</p>
    <p>但是<code>Generator</code>的一些缺陷使<code>React</code>团队放弃了他：</p>
    <ul>
      <li>
        <p>
          类似<code>async</code>，<code>Generator</code>也是<code>传染性</code>的，使用了<code>Generator</code>则上下文的其他函数也需要作出改变。这样心智负担比较重。
        </p>
      </li>
      <li>
        <p><code>Generator</code>执行的<code>中间状态</code>是上下文关联的。</p>
      </li>
    </ul>
    <p>考虑如下例子：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token parameter"><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token punctuation">,</span> <span class="token constant">C</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token function">doExpensiveWorkA</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">yield</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> y <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token function">doExpensiveWorkB</span><span class="token punctuation">(</span><span class="token constant">B</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">yield</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> z <span class="token operator">=</span> y <span class="token operator">+</span> <span class="token function">doExpensiveWorkC</span><span class="token punctuation">(</span><span class="token constant">C</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> z<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <p>每当浏览器有空闲时间都会依次执行其中一个<code>doExpensiveWork</code>，当时间用尽则会中断，当再次恢复时会从中断位置继续执行。</p>
    <p>只考虑“单一优先级任务的中断与继续”情况下<code>Generator</code>可以很好的实现<code>异步可中断更新</code>。</p>
    <p>
      但是当我们考虑“高优先级任务插队”的情况，如果此时已经完成<code>doExpensiveWorkA</code>与<code>doExpensiveWorkB</code>计算出<code>x</code>与<code>y</code>。
    </p>
    <p>
      此时<code>B</code>组件接收到一个<code>高优更新</code>，由于<code>Generator</code>执行的<code>中间状态</code>是上下文关联的，所以计算<code>y</code>时无法复用之前已经计算出的<code>x</code>，需要重新计算。
    </p>
    <p>如果通过<code>全局变量</code>保存之前执行的<code>中间状态</code>，又会引入新的复杂度。</p>
    <blockquote>
      <p>更详细的解释可以参考<a href="https://github.com/facebook/react/issues/7942#issuecomment-254987818" target="_blank"
          rel="noopener noreferrer">这个issue<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a></p>
    </blockquote>
    <p>基于这些原因，<code>React</code>没有采用<code>Generator</code>实现<code>协调器</code>。</p>
    <h2 id="代数效应与fiber"><a href="#代数效应与fiber" class="header-anchor">#</a> 代数效应与Fiber</h2>
    <p><code>Fiber</code>并不是计算机术语中的新名词，他的中文翻译叫做<code>纤程</code>，与进程（Process）、线程（Thread）、协程（Coroutine）同为程序执行过程。</p>
    <p>在很多文章中将<code>纤程</code>理解为<code>协程</code>的一种实现。在<code>JS</code>中，<code>协程</code>的实现便是<code>Generator</code>。</p>
    <p>所以，我们可以将<code>纤程</code>(Fiber)、<code>协程</code>(Generator)理解为<code>代数效应</code>思想在<code>JS</code>中的体现。</p>
    <p><code>React Fiber</code>可以理解为：</p>
    <p><code>React</code>内部实现的一套状态更新机制。支持任务不同<code>优先级</code>，可中断与恢复，并且恢复后可以复用之前的<code>中间状态</code>。</p>
    <p>其中每个任务更新单元为<code>React Element</code>对应的<code>Fiber节点</code>。</p>
    <p>下一节，我们具体讲解<code>Fiber架构</code>的实现。</p>
  </div>
  <div class="theme-default-content content__default">
    <p>在<a
        href="/preparation/newConstructure.html">新的React架构一节</a>中，我们提到的<strong>虚拟DOM</strong>在<code>React</code>中有个正式的称呼——<code>Fiber</code>。在之后的学习中，我们会逐渐用<code>Fiber</code>来取代<strong>React16虚拟DOM</strong>这一称呼。
    </p>
    <p>接下来让我们了解下<code>Fiber</code>因何而来？他的作用是什么？</p>
    <h2 id="fiber的起源"><a href="#fiber的起源" class="header-anchor">#</a> Fiber的起源</h2>
    <blockquote>
      <p>最早的<code>Fiber</code>官方解释来源于<a href="https://github.com/acdlite/react-fiber-architecture" target="_blank"
          rel="noopener noreferrer">2016年React团队成员Acdlite的一篇介绍<span><svg xmlns="http://www.w3.org/2000/svg"
              aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"
              class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>。</p>
    </blockquote>
    <p>从上一章的学习我们知道：</p>
    <p>在<code>React15</code>及以前，<code>Reconciler</code>采用递归的方式创建虚拟DOM，递归过程是不能中断的。如果组件树的层级很深，递归会占用线程很多时间，造成卡顿。</p>
    <p>
      为了解决这个问题，<code>React16</code>将<strong>递归的无法中断的更新</strong>重构为<strong>异步的可中断更新</strong>，由于曾经用于递归的<strong>虚拟DOM</strong>数据结构已经无法满足需要。于是，全新的<code>Fiber</code>架构应运而生。
    </p>
    <h2 id="fiber的含义"><a href="#fiber的含义" class="header-anchor">#</a> Fiber的含义</h2>
    <p><code>Fiber</code>包含三层含义：</p>
    <ol>
      <li>
        <p>
          作为架构来说，之前<code>React15</code>的<code>Reconciler</code>采用递归的方式执行，数据保存在递归调用栈中，所以被称为<code>stack Reconciler</code>。<code>React16</code>的<code>Reconciler</code>基于<code>Fiber节点</code>实现，被称为<code>Fiber Reconciler</code>。
        </p>
      </li>
      <li>
        <p>作为静态的数据结构来说，每个<code>Fiber节点</code>对应一个<code>React element</code>，保存了该组件的类型（函数组件/类组件/原生组件...）、对应的DOM节点等信息。</p>
      </li>
      <li>
        <p>作为动态的工作单元来说，每个<code>Fiber节点</code>保存了本次更新中该组件改变的状态、要执行的工作（需要被删除/被插入页面中/被更新...）。</p>
      </li>
    </ol>
    <h2 id="fiber的结构"><a href="#fiber的结构" class="header-anchor">#</a> Fiber的结构</h2>
    <p>你可以从这里看到<a
        href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiber.new.js#L117"
        target="_blank" rel="noopener noreferrer">Fiber节点的属性定义<span><svg xmlns="http://www.w3.org/2000/svg"
            aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"
            class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a>。虽然属性很多，但我们可以按三层含义将他们分类来看</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">FiberNode</span><span class="token punctuation">(</span>
  <span class="token parameter">tag<span class="token operator">:</span> WorkTag<span class="token punctuation">,</span>
  pendingProps<span class="token operator">:</span> mixed<span class="token punctuation">,</span>
  key<span class="token operator">:</span> <span class="token keyword">null</span> <span class="token operator">|</span> string<span class="token punctuation">,</span>
  mode<span class="token operator">:</span> TypeOfMode<span class="token punctuation">,</span></span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 作为静态数据结构的属性</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>tag <span class="token operator">=</span> tag<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>elementType <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>stateNode <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

  <span class="token comment">// 用于连接其他Fiber节点形成Fiber树</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>return <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>child <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>sibling <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

  <span class="token keyword">this</span><span class="token punctuation">.</span>ref <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

  <span class="token comment">// 作为动态的工作单元的属性</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>pendingProps <span class="token operator">=</span> pendingProps<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>memoizedProps <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>updateQueue <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>memoizedState <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>dependencies <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

  <span class="token keyword">this</span><span class="token punctuation">.</span>mode <span class="token operator">=</span> mode<span class="token punctuation">;</span>

  <span class="token keyword">this</span><span class="token punctuation">.</span>effectTag <span class="token operator">=</span> NoEffect<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>nextEffect <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

  <span class="token keyword">this</span><span class="token punctuation">.</span>firstEffect <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>lastEffect <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

  <span class="token comment">// 调度优先级相关</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>lanes <span class="token operator">=</span> NoLanes<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>childLanes <span class="token operator">=</span> NoLanes<span class="token punctuation">;</span>

  <span class="token comment">// 指向该fiber在另一次更新时对应的fiber</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>alternate <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <h3 id="作为架构来说"><a href="#作为架构来说" class="header-anchor">#</a> 作为架构来说</h3>
    <p>每个Fiber节点有个对应的<code>React element</code>，多个<code>Fiber节点</code>是如何连接形成树呢？靠如下三个属性：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token comment">// 指向父级Fiber节点</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>return <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token comment">// 指向子Fiber节点</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>child <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token comment">// 指向右边第一个兄弟Fiber节点</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>sibling <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre>
    </div>
    <p>举个例子，如下的组件结构：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      i am
      <span class="token operator">&lt;</span>span<span class="token operator">&gt;</span>KaSong<span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <p>对应的<code>Fiber树</code>结构：
      <img src="https://react.iamkasong.com/img/fiber.png" alt="Fiber架构">
    </p>
    <blockquote>
      <p>
        这里需要提一下，为什么父级指针叫做<code>return</code>而不是<code>parent</code>或者<code>father</code>呢？因为作为一个工作单元，<code>return</code>指节点执行完<code>completeWork</code>（本章后面会介绍）后会返回的下一个节点。子<code>Fiber节点</code>及其兄弟节点完成工作后会返回其父级节点，所以用<code>return</code>指代父级节点。
      </p>
    </blockquote>
    <h3 id="作为静态的数据结构"><a href="#作为静态的数据结构" class="header-anchor">#</a> 作为静态的数据结构</h3>
    <p>作为一种静态的数据结构，保存了组件相关的信息：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token comment">// Fiber对应组件的类型 Function/Class/Host...</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>tag <span class="token operator">=</span> tag<span class="token punctuation">;</span>
<span class="token comment">// key属性</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>
<span class="token comment">// 大部分情况同type，某些情况不同，比如FunctionComponent使用React.memo包裹</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>elementType <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token comment">// 对于 FunctionComponent，指函数本身，对于ClassComponent，指class，对于HostComponent，指DOM节点tagName</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token comment">// Fiber对应的真实DOM节点</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>stateNode <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre>
    </div>
    <h3 id="作为动态的工作单元"><a href="#作为动态的工作单元" class="header-anchor">#</a> 作为动态的工作单元</h3>
    <p>作为动态的工作单元，<code>Fiber</code>中如下参数保存了本次更新相关的信息，我们会在后续的更新流程中使用到具体属性时再详细介绍</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code>
<span class="token comment">// 保存本次更新造成的状态改变相关信息</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>pendingProps <span class="token operator">=</span> pendingProps<span class="token punctuation">;</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>memoizedProps <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>updateQueue <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>memoizedState <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>dependencies <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

<span class="token keyword">this</span><span class="token punctuation">.</span>mode <span class="token operator">=</span> mode<span class="token punctuation">;</span>

<span class="token comment">// 保存本次更新会造成的DOM操作</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>effectTag <span class="token operator">=</span> NoEffect<span class="token punctuation">;</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>nextEffect <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

<span class="token keyword">this</span><span class="token punctuation">.</span>firstEffect <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>lastEffect <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre>
    </div>
    <p>如下两个字段保存调度优先级相关的信息，会在讲解<code>Scheduler</code>时介绍。</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token comment">// 调度优先级相关</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>lanes <span class="token operator">=</span> NoLanes<span class="token punctuation">;</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>childLanes <span class="token operator">=</span> NoLanes<span class="token punctuation">;</span>
</code></pre>
    </div>
    <div class="custom-block warning">
      <p class="custom-block-title">注意</p>
      <p>在2020年5月，调度优先级策略经历了比较大的重构。以<code>expirationTime</code>属性为代表的优先级模型被<code>lane</code>取代。详见<a
          href="https://github.com/facebook/react/pull/18796" target="_blank" rel="noopener noreferrer">这个PR<span><svg
              xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px"
              viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a></p>
      <p>如果你的源码中<code>fiber.expirationTime</code>仍存在，请参照<a href="/preparation/source.html">调试源码</a>章节获取最新代码。</p>
    </div>
    <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2>
    <p>
      本节我们了解了<code>Fiber</code>的起源与架构，其中<code>Fiber节点</code>可以构成<code>Fiber树</code>。那么<code>Fiber树</code>和页面呈现的<code>DOM树</code>有什么关系，<code>React</code>又是如何更新<code>DOM</code>的呢？
    </p>
    <p>我们会在下一节讲解。</p>
    <h2 id="参考资料"><a href="#参考资料" class="header-anchor">#</a> 参考资料</h2>
    <p><a href="https://www.bilibili.com/video/BV1it411p7v6?from=search&amp;seid=3508901752524570226" target="_blank"
        rel="noopener noreferrer">Lin Clark - A Cartoon Intro to Fiber - React Conf 2017<span><svg
            xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px"
            viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a></p>
  </div>
  <div class="theme-default-content content__default">
    <p>通过上一节的学习，我们了解了<code>Fiber</code>是什么，知道<code>Fiber节点</code>可以保存对应的<code>DOM节点</code>。</p>
    <p>相应的，<code>Fiber节点</code>构成的<code>Fiber树</code>就对应<code>DOM树</code>。</p>
    <p>那么如何更新<code>DOM</code>呢？这需要用到被称为“双缓存”的技术。</p>
    <h2 id="什么是-双缓存"><a href="#什么是-双缓存" class="header-anchor">#</a> 什么是“双缓存”</h2>
    <p>当我们用<code>canvas</code>绘制动画，每一帧绘制前都会调用<code>ctx.clearRect</code>清除上一帧的画面。</p>
    <p>如果当前帧画面计算量比较大，导致清除上一帧画面到绘制当前帧画面之间有较长间隙，就会出现白屏。</p>
    <p>为了解决这个问题，我们可以在内存中绘制当前帧动画，绘制完毕后直接用当前帧替换上一帧画面，由于省去了两帧替换间的计算时间，不会出现从白屏到出现画面的闪烁情况。</p>
    <p>这种<strong>在内存中构建并直接替换</strong>的技术叫做<a href="https://baike.baidu.com/item/%E5%8F%8C%E7%BC%93%E5%86%B2"
        target="_blank" rel="noopener noreferrer">双缓存<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
            focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a>。</p>
    <p><code>React</code>使用“双缓存”来完成<code>Fiber树</code>的构建与替换——对应着<code>DOM树</code>的创建与更新。</p>
    <h2 id="双缓存fiber树"><a href="#双缓存fiber树" class="header-anchor">#</a> 双缓存Fiber树</h2>
    <p>
      在<code>React</code>中最多会同时存在两棵<code>Fiber树</code>。当前屏幕上显示内容对应的<code>Fiber树</code>称为<code>current Fiber树</code>，正在内存中构建的<code>Fiber树</code>称为<code>workInProgress Fiber树</code>。
    </p>
    <p>
      <code>current Fiber树</code>中的<code>Fiber节点</code>被称为<code>current fiber</code>，<code>workInProgress Fiber树</code>中的<code>Fiber节点</code>被称为<code>workInProgress fiber</code>，他们通过<code>alternate</code>属性连接。
    </p>
    <div class="language-js extra-class">
      <pre class="language-js"><code>currentFiber<span class="token punctuation">.</span>alternate <span class="token operator">===</span> workInProgressFiber<span class="token punctuation">;</span>
workInProgressFiber<span class="token punctuation">.</span>alternate <span class="token operator">===</span> currentFiber<span class="token punctuation">;</span>
</code></pre>
    </div>
    <p>
      <code>React</code>应用的根节点通过使<code>current</code>指针在不同<code>Fiber树</code>的<code>rootFiber</code>间切换来完成<code>current Fiber</code>树指向的切换。
    </p>
    <p>
      即当<code>workInProgress Fiber树</code>构建完成交给<code>Renderer</code>渲染在页面上后，应用根节点的<code>current</code>指针指向<code>workInProgress Fiber树</code>，此时<code>workInProgress Fiber树</code>就变为<code>current Fiber树</code>。
    </p>
    <p>
      每次状态更新都会产生新的<code>workInProgress Fiber树</code>，通过<code>current</code>与<code>workInProgress</code>的替换，完成<code>DOM</code>更新。
    </p>
    <p>接下来我们以具体例子讲解<code>mount时</code>、<code>update时</code>的构建/替换流程。</p>
    <h2 id="mount时"><a href="#mount时" class="header-anchor">#</a> mount时</h2>
    <p>考虑如下例子：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>num<span class="token punctuation">,</span> add<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>p onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">add</span><span class="token punctuation">(</span>num <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>num<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>

ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>App<span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'root'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    </div>
    <ol>
      <li>
        首次执行<code>ReactDOM.render</code>会创建<code>fiberRootNode</code>（源码中叫<code>fiberRoot</code>）和<code>rootFiber</code>。其中<code>fiberRootNode</code>是整个应用的根节点，<code>rootFiber</code>是<code>&lt;App/&gt;</code>所在组件树的根节点。
      </li>
    </ol>
    <p>
      之所以要区分<code>fiberRootNode</code>与<code>rootFiber</code>，是因为在应用中我们可以多次调用<code>ReactDOM.render</code>渲染不同的组件树，他们会拥有不同的<code>rootFiber</code>。但是整个应用的根节点只有一个，那就是<code>fiberRootNode</code>。
    </p>
    <p><code>fiberRootNode</code>的<code>current</code>会指向当前页面上已渲染内容对应<code>Fiber树</code>，即<code>current Fiber树</code>。
    </p> <img src="https://react.iamkasong.com/img/rootfiber.png" alt="rootFiber">
    <div class="language-js extra-class">
      <pre class="language-js"><code>fiberRootNode<span class="token punctuation">.</span>current <span class="token operator">=</span> rootFiber<span class="token punctuation">;</span>
</code></pre>
    </div>
    <p>
      由于是首屏渲染，页面中还没有挂载任何<code>DOM</code>，所以<code>fiberRootNode.current</code>指向的<code>rootFiber</code>没有任何<code>子Fiber节点</code>（即<code>current Fiber树</code>为空）。
    </p>
    <ol start="2">
      <li>
        接下来进入<code>render阶段</code>，根据组件返回的<code>JSX</code>在内存中依次创建<code>Fiber节点</code>并连接在一起构建<code>Fiber树</code>，被称为<code>workInProgress Fiber树</code>。（下图中右侧为内存中构建的树，左侧为页面显示的树）
      </li>
    </ol>
    <p>
      在构建<code>workInProgress Fiber树</code>时会尝试复用<code>current Fiber树</code>中已有的<code>Fiber节点</code>内的属性，在<code>首屏渲染</code>时只有<code>rootFiber</code>存在对应的<code>current fiber</code>（即<code>rootFiber.alternate</code>）。
    </p> <img src="https://react.iamkasong.com/img/workInProgressFiber.png" alt="workInProgressFiber">
    <ol start="3">
      <li>图中右侧已构建完的<code>workInProgress Fiber树</code>在<code>commit阶段</code>渲染到页面。</li>
    </ol>
    <p>
      此时<code>DOM</code>更新为右侧树对应的样子。<code>fiberRootNode</code>的<code>current</code>指针指向<code>workInProgress Fiber树</code>使其变为<code>current Fiber 树</code>。
    </p> <img src="https://react.iamkasong.com/img/wipTreeFinish.png" alt="workInProgressFiberFinish">
    <h2 id="update时"><a href="#update时" class="header-anchor">#</a> update时</h2>
    <ol>
      <li>接下来我们点击<code>p节点</code>触发状态改变，这会开启一次新的<code>render阶段</code>并构建一棵新的<code>workInProgress Fiber 树</code>。</li>
    </ol> <img src="https://react.iamkasong.com/img/wipTreeUpdate.png" alt="wipTreeUpdate">
    <p>和<code>mount</code>时一样，<code>workInProgress fiber</code>的创建可以复用<code>current Fiber树</code>对应的节点数据。</p>
    <blockquote>
      <p>这个决定是否复用的过程就是Diff算法，后面章节会详细讲解</p>
    </blockquote>
    <ol start="2">
      <li>
        <code>workInProgress Fiber 树</code>在<code>render阶段</code>完成构建后进入<code>commit阶段</code>渲染到页面上。渲染完毕后，<code>workInProgress Fiber 树</code>变为<code>current Fiber 树</code>。
      </li>
    </ol> <img src="https://react.iamkasong.com/img/currentTreeUpdate.png" alt="currentTreeUpdate">
    <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2>
    <p>本文介绍了<code>Fiber树</code>的构建与替换过程，这个过程伴随着<code>DOM</code>的更新。</p>
    <p>那么在构建过程中每个<code>Fiber节点</code>具体是如何创建的呢？我们会在<code>架构篇</code>的<a href="/process/reconciler.html">render阶段</a>讲解。
    </p>
    <h2 id="参考资料"><a href="#参考资料" class="header-anchor">#</a> 参考资料</h2>
    <details class="custom-block details">
      <summary>Fiber树的创建与切换Demo</summary>
      <p>此<code>Demo</code>会在如下时机在控制台打印信息：</p>
      <ul>
        <li>
          <p>构建<code>WorkInProgrss Fiber</code>时</p>
        </li>
        <li>
          <p>在渲染完毕后，<code>workInProgress Fiber 树</code>变为<code>current Fiber 树</code>时</p>
        </li>
      </ul>
      <p><a href="/me.html">关注公众号</a>，后台回复<strong>812</strong>获得在线Demo地址</p>
    </details>
  </div>
  <div class="theme-default-content content__default">
    <p>通过本章的学习，我们了解了<code>React</code>的<code>Scheduler-Reconciler-Renderer</code>架构体系，在结束本章前，我想介绍几个源码内的术语：</p>
    <ul>
      <li><code>Reconciler</code>工作的阶段被称为<code>render</code>阶段。因为在该阶段会调用组件的<code>render</code>方法。</li>
      <li>
        <code>Renderer</code>工作的阶段被称为<code>commit</code>阶段。就像你完成一个需求的编码后执行<code>git commit</code>提交代码。<code>commit</code>阶段会把<code>render</code>阶段提交的信息渲染在页面上。
      </li>
      <li>
        <code>render</code>与<code>commit</code>阶段统称为<code>work</code>，即<code>React</code>在工作中。相对应的，如果任务正在<code>Scheduler</code>内调度，就不属于<code>work</code>。
      </li>
    </ul>
    <p>
      在<code>架构篇</code>我们会分别讲解<code>Reconciler</code>和<code>Renderer</code>的工作流程，所以章节名分别为<code>render阶段</code>和<code>commit阶段</code>。
    </p>
  </div>
  <div class="theme-default-content content__default">
    <p>经过之前的学习，我们已经知道<code>React16</code>的架构分为三层：</p>
    <ul>
      <li>Scheduler（调度器）—— 调度任务的优先级，高优任务优先进入<strong>Reconciler</strong></li>
      <li>Reconciler（协调器）—— 负责找出变化的组件</li>
      <li>Renderer（渲染器）—— 负责将变化的组件渲染到页面上</li>
    </ul>
    <p>那么架构是如何体现在源码的文件结构上呢，让我们一起看看吧。</p>
    <h2 id="顶层目录"><a href="#顶层目录" class="header-anchor">#</a> 顶层目录</h2>
    <p>除去配置文件和隐藏文件夹，根目录的文件夹包括三个：</p>
    <div class="language- extra-class">
      <pre class="language-text"><code>根目录
├── fixtures        # 包含一些给贡献者准备的小型 React 测试项目
├── packages        # 包含元数据（比如 package.json）和 React 仓库中所有 package 的源码（子目录 src）
├── scripts         # 各种工具链的脚本，比如git、jest、eslint等
</code></pre>
    </div>
    <p>这里我们关注<strong>packages</strong>目录</p>
    <h2 id="packages目录"><a href="#packages目录" class="header-anchor">#</a> packages目录</h2>
    <p>目录下的文件夹非常多，我们来看下：</p>
    <h3 id="react文件夹"><a href="#react文件夹" class="header-anchor">#</a> <a
        href="https://github.com/facebook/react/tree/master/packages/react" target="_blank"
        rel="noopener noreferrer">react<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
            focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a>文件夹</h3>
    <p>React的核心，包含所有全局 React API，如：</p>
    <ul>
      <li>React.createElement</li>
      <li>React.Component</li>
      <li>React.Children</li>
    </ul>
    <p>这些 API 是全平台通用的，它不包含<code>ReactDOM</code>、<code>ReactNative</code>等平台特定的代码。在 NPM 上作为<a
        href="https://www.npmjs.com/package/react" target="_blank" rel="noopener noreferrer">单独的一个包<span><svg
            xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px"
            viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a>发布。</p>
    <h3 id="scheduler文件夹"><a href="#scheduler文件夹" class="header-anchor">#</a> <a
        href="https://github.com/facebook/react/tree/master/packages/scheduler" target="_blank"
        rel="noopener noreferrer">scheduler<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
            focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a>文件夹</h3>
    <p>Scheduler（调度器）的实现。</p>
    <h3 id="shared文件夹"><a href="#shared文件夹" class="header-anchor">#</a> <a
        href="https://github.com/facebook/react/tree/master/packages/shared" target="_blank"
        rel="noopener noreferrer">shared<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
            focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a>文件夹</h3>
    <p>源码中其他模块公用的<strong>方法</strong>和<strong>全局变量</strong>，比如在<a
        href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/shared/ReactSymbols.js"
        target="_blank" rel="noopener noreferrer">shared/ReactSymbols.js<span><svg xmlns="http://www.w3.org/2000/svg"
            aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"
            class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a>中保存<code>React</code>不同组件类型的定义。</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token comment">// ...</span>
<span class="token keyword">export</span> <span class="token keyword">let</span> <span class="token constant">REACT_ELEMENT_TYPE</span> <span class="token operator">=</span> <span class="token number">0xeac7</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">let</span> <span class="token constant">REACT_PORTAL_TYPE</span> <span class="token operator">=</span> <span class="token number">0xeaca</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">let</span> <span class="token constant">REACT_FRAGMENT_TYPE</span> <span class="token operator">=</span> <span class="token number">0xeacb</span><span class="token punctuation">;</span>
<span class="token comment">// ...</span>
</code></pre>
    </div>
    <h3 id="renderer相关的文件夹"><a href="#renderer相关的文件夹" class="header-anchor">#</a> Renderer相关的文件夹</h3>
    <p>如下几个文件夹为对应的<strong>Renderer</strong></p>
    <div class="language- extra-class">
      <pre class="language-text"><code>- react-art
- react-dom                 # 注意这同时是DOM和SSR（服务端渲染）的入口
- react-native-renderer
- react-noop-renderer       # 用于debug fiber（后面会介绍fiber）
- react-test-renderer
</code></pre>
    </div>
    <h3 id="试验性包的文件夹"><a href="#试验性包的文件夹" class="header-anchor">#</a> 试验性包的文件夹</h3>
    <p><code>React</code>将自己流程中的一部分抽离出来，形成可以独立使用的包，由于他们是试验性质的，所以不被建议在生产环境使用。包括如下文件夹：</p>
    <div class="language- extra-class">
      <pre class="language-text"><code>- react-server        # 创建自定义SSR流
- react-client        # 创建自定义的流
- react-fetch         # 用于数据请求
- react-interactions  # 用于测试交互相关的内部特性，比如React的事件模型
- react-reconciler    # Reconciler的实现，你可以用他构建自己的Renderer
</code></pre>
    </div>
    <h3 id="辅助包的文件夹"><a href="#辅助包的文件夹" class="header-anchor">#</a> 辅助包的文件夹</h3>
    <p><code>React</code>将一些辅助功能形成单独的包。包括如下文件夹：</p>
    <div class="language- extra-class">
      <pre class="language-text"><code>- react-is       # 用于测试组件是否是某类型
- react-client   # 创建自定义的流
- react-fetch    # 用于数据请求
- react-refresh  # “热重载”的React官方实现
</code></pre>
    </div>
    <h3 id="react-reconciler文件夹"><a href="#react-reconciler文件夹" class="header-anchor">#</a> <a
        href="https://github.com/facebook/react/tree/master/packages/react-reconciler" target="_blank"
        rel="noopener noreferrer">react-reconciler<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
            focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a>文件夹</h3>
    <p>我们需要重点关注<strong>react-reconciler</strong>，在接下来源码学习中 80%的代码量都来自这个包。</p>
    <p>虽然他是一个实验性的包，内部的很多功能在正式版本中还未开放。但是他一边对接<strong>Scheduler</strong>，一边对接不同平台的<strong>Renderer</strong>，构成了整个 React16
      的架构体系。</p>
  </div>
  <div class="theme-default-content content__default">
    <p>了解了源码的文件目录，这一节我们看看如何调试源码。</p>
    <p>
      即使版本号相同（当前最新版为<code>17.0.0 RC</code>），但是<code>facebook/react</code>项目<code>master</code>分支的代码和我们使用<code>create-react-app</code>创建的项目<code>node_modules</code>下的<code>react</code>项目代码还是有些区别。
    </p>
    <p>因为<code>React</code>的新代码都是直接提交到<code>master</code>分支，而<code>create-react-app</code>内的<code>react</code>使用的是稳定版的包。
    </p>
    <p>为了始终使用最新版<code>React</code>教学，我们调试源码遵循以下步骤：</p>
    <ol>
      <li>从<code>facebook/react</code>项目<code>master</code>分支拉取最新源码</li>
      <li>基于最新源码构建<code>react</code>、<code>scheduler</code>、<code>react-dom</code>三个包</li>
      <li>通过<code>create-react-app</code>创建测试项目，并使用步骤2创建的包作为项目依赖的包</li>
    </ol>
    <h2 id="拉取源码"><a href="#拉取源码" class="header-anchor">#</a> 拉取源码</h2>
    <p>拉取<code>facebook/react</code>代码</p>
    <div class="language-sh extra-class">
      <pre class="language-sh"><code><span class="token comment"># 拉取代码</span>
<span class="token function">git</span> clone https://github.com/facebook/react.git

<span class="token comment"># 如果拉取速度很慢，可以考虑如下2个方案：</span>

<span class="token comment"># 1. 使用cnpm代理</span>
<span class="token function">git</span> clone https://github.com.cnpmjs.org/facebook/react

<span class="token comment"># 2. 使用码云的镜像（一天会与react同步一次）</span>
<span class="token function">git</span> clone https://gitee.com/mirrors/react.git

</code></pre>
    </div>
    <p>安装依赖</p>
    <div class="language-sh extra-class">
      <pre class="language-sh"><code><span class="token comment"># 切入到react源码所在文件夹</span>
<span class="token builtin class-name">cd</span> react

<span class="token comment"># 安装依赖</span>
<span class="token function">yarn</span>
</code></pre>
    </div>
    <p>打包<code>react</code>、<code>scheduler</code>、<code>react-dom</code>三个包为dev环境可以使用的<code>cjs</code>包。</p>
    <blockquote>
      <p>我们的步骤只包含具体做法，对每一步更详细的介绍可以参考<code>React</code>文档<a
          href="https://zh-hans.reactjs.org/docs/how-to-contribute.html#development-workflow" target="_blank"
          rel="noopener noreferrer">源码贡献章节<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a></p>
    </blockquote>
    <div class="language-sh extra-class">
      <pre class="language-sh"><code>
<span class="token comment"># 执行打包命令</span>
<span class="token function">yarn</span> build react/index,react/jsx,react-dom/index,scheduler --type<span class="token operator">=</span>NODE


</code></pre>
    </div>
    <details class="custom-block details">
      <summary>网络不好的同学看这里</summary>
      <p>如果网络不好，执行<code>yarn</code>命令无法完成依赖安装，或者执行<code>yarn build</code>无法完成打包，可以使用我打好的包。</p>
      <p>版本为<code>17.0.0-alpha.0</code></p>
      <p><a href="https://gitee.com/kasong/react" target="_blank" rel="noopener noreferrer">地址<span><svg
              xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px"
              viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a></p>
    </details>
    <p>
      现在源码目录<code>build/node_modules</code>下会生成最新代码的包。我们为<code>react</code>、<code>react-dom</code>创建<code>yarn link</code>。
    </p>
    <blockquote>
      <p>通过<code>yarn link</code>可以改变项目中依赖包的目录指向</p>
    </blockquote>
    <div class="language-sh extra-class">
      <pre class="language-sh"><code><span class="token builtin class-name">cd</span> build/node_modules/react
<span class="token comment"># 申明react指向</span>
<span class="token function">yarn</span> <span class="token function">link</span>
<span class="token builtin class-name">cd</span> build/node_modules/react-dom
<span class="token comment"># 申明react-dom指向</span>
<span class="token function">yarn</span> <span class="token function">link</span>
</code></pre>
    </div>
    <h2 id="创建项目"><a href="#创建项目" class="header-anchor">#</a> 创建项目</h2>
    <p>接下来我们通过<code>create-react-app</code>在其他地方创建新项目。这里我们随意起名，比如“a-react-demo”。</p>
    <div class="language-sh extra-class">
      <pre class="language-sh"><code>npx create-react-app a-react-demo
</code></pre>
    </div>
    <p>在新项目中，将<code>react</code>与<code>react-dom</code>2个包指向<code>facebook/react</code>下我们刚才生成的包。</p>
    <div class="language-sh extra-class">
      <pre class="language-sh"><code><span class="token comment"># 将项目内的react react-dom指向之前申明的包</span>
<span class="token function">yarn</span> <span class="token function">link</span> react react-dom
</code></pre>
    </div>
    <p>现在试试在<code>react/build/node_modules/react-dom/cjs/react-dom.development.js</code>中随意打印些东西。</p>
    <p>在<code>a-react-demo</code>项目下执行<code>yarn start</code>。现在浏览器控制台已经可以打印出我们输入的东西了。</p>
    <p>通过以上方法，我们的运行时代码就和<code>React</code>最新代码一致了。</p>
  </div>
  <div class="theme-default-content content__default">
    <p><code>JSX</code>作为描述组件内容的数据结构，为JS赋予了更多视觉表现力。在<code>React</code>中我们大量使用他。在深入源码之前，有些疑问我们需要先解决：</p>
    <ul>
      <li><code>JSX</code>和<code>Fiber节点</code>是同一个东西么？</li>
      <li><code>React Component</code>、<code>React Element</code>是同一个东西么，他们和<code>JSX</code>有什么关系？</li>
    </ul>
    <p>带着这些疑问，让我们开始这一节的学习。</p>
    <h2 id="jsx简介"><a href="#jsx简介" class="header-anchor">#</a> JSX简介</h2>
    <p>相信作为<code>React</code>的使用者，你已经接触过<code>JSX</code>。如果你还不了解他，可以看下<a
        href="https://react.docschina.org/docs/introducing-jsx.html" target="_blank"
        rel="noopener noreferrer">官网对其的描述<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
            focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a>。</p>
    <p><code>JSX</code>在编译时会被<code>Babel</code>编译为<code>React.createElement</code>方法。</p>
    <details class="custom-block details">
      <summary>JSX编译</summary>
      <p><a href="/me.html">关注公众号</a>，后台回复<strong>712</strong>获得在线Demo地址</p>
    </details>
    <p>这也是为什么在每个使用<code>JSX</code>的JS文件中，你必须显式的声明</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>
</code></pre>
    </div>
    <p>否则在运行时该模块内就会报<code>未定义变量 React</code>的错误。</p>
    <div class="custom-block warning">
      <p class="custom-block-title">注意</p>
      <p>在React17中，已经不需要显式导入React了。详见<a
          href="https://zh-hans.reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html" target="_blank"
          rel="noopener noreferrer">介绍全新的 JSX 转换<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a></p>
    </div>
    <p><code>JSX</code>并不是只能被编译为<code>React.createElement</code>方法，你可以通过<a
        href="https://babeljs.io/docs/en/babel-plugin-transform-react-jsx" target="_blank"
        rel="noopener noreferrer">@babel/plugin-transform-react-jsx<span><svg xmlns="http://www.w3.org/2000/svg"
            aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"
            class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new
            window)</span></span></a>插件显式告诉<code>Babel</code>编译时需要将<code>JSX</code>编译为什么函数的调用（默认为<code>React.createElement</code>）。
    </p>
    <p>比如在<a href="https://github.com/preactjs/preact" target="_blank" rel="noopener noreferrer">preact<span><svg
            xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px"
            viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new
            window)</span></span></a>这个类<code>React</code>库中，<code>JSX</code>会被编译为一个名为<code>h</code>的函数调用。</p>
    <div class="language-jsx extra-class">
      <pre class="language-jsx"><code><span class="token comment">// 编译前</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">KaSong</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
<span class="token comment">// 编译后</span>
<span class="token function">h</span><span class="token punctuation">(</span><span class="token string">"p"</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">"KaSong"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    </div>
    <h2 id="react-createelement"><a href="#react-createelement" class="header-anchor">#</a> <a
        href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react/src/ReactElement.js#L348"
        target="_blank" rel="noopener noreferrer">React.createElement<span><svg xmlns="http://www.w3.org/2000/svg"
            aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"
            class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a></h2>
    <p>既然<code>JSX</code>会被编译为<code>React.createElement</code>，让我们看看他做了什么：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">createElement</span><span class="token punctuation">(</span><span class="token parameter">type<span class="token punctuation">,</span> config<span class="token punctuation">,</span> children</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> propName<span class="token punctuation">;</span>

  <span class="token keyword">const</span> props <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token keyword">let</span> key <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> ref <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> self <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> source <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>config <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 将 config 处理后赋值给 props</span>
    <span class="token comment">// ...省略</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">const</span> childrenLength <span class="token operator">=</span> arguments<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token comment">// 处理 children，会被赋值给props.children</span>
  <span class="token comment">// ...省略</span>

  <span class="token comment">// 处理 defaultProps</span>
  <span class="token comment">// ...省略</span>

  <span class="token keyword">return</span> <span class="token function">ReactElement</span><span class="token punctuation">(</span>
    type<span class="token punctuation">,</span>
    key<span class="token punctuation">,</span>
    ref<span class="token punctuation">,</span>
    self<span class="token punctuation">,</span>
    source<span class="token punctuation">,</span>
    ReactCurrentOwner<span class="token punctuation">.</span>current<span class="token punctuation">,</span>
    props<span class="token punctuation">,</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> <span class="token function-variable function">ReactElement</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">type<span class="token punctuation">,</span> key<span class="token punctuation">,</span> ref<span class="token punctuation">,</span> self<span class="token punctuation">,</span> source<span class="token punctuation">,</span> owner<span class="token punctuation">,</span> props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> element <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token comment">// 标记这是个 React Element</span>
    $$<span class="token keyword">typeof</span><span class="token operator">:</span> <span class="token constant">REACT_ELEMENT_TYPE</span><span class="token punctuation">,</span>

    type<span class="token operator">:</span> type<span class="token punctuation">,</span>
    key<span class="token operator">:</span> key<span class="token punctuation">,</span>
    ref<span class="token operator">:</span> ref<span class="token punctuation">,</span>
    props<span class="token operator">:</span> props<span class="token punctuation">,</span>
    _owner<span class="token operator">:</span> owner<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> element<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
    </div>
    <p>
      我们可以看到，<code>React.createElement</code>最终会调用<code>ReactElement</code>方法返回一个包含组件数据的对象，该对象有个参数<code>$$typeof: REACT_ELEMENT_TYPE</code>标记了该对象是个<code>React Element</code>。
    </p>
    <p>所以调用<code>React.createElement</code>返回的对象就是<code>React Element</code>么？</p>
    <p><code>React</code>提供了验证合法<code>React Element</code>的全局API <a
        href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react/src/ReactElement.js#L547"
        target="_blank" rel="noopener noreferrer">React.isValidElement<span><svg xmlns="http://www.w3.org/2000/svg"
            aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"
            class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a>，我们看下他的实现：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">isValidElement</span><span class="token punctuation">(</span><span class="token parameter">object</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token keyword">typeof</span> object <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">&amp;&amp;</span>
    object <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span>
    object<span class="token punctuation">.</span>$$<span class="token keyword">typeof</span> <span class="token operator">===</span> <span class="token constant">REACT_ELEMENT_TYPE</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <p>
      可以看到，<code>$$typeof === REACT_ELEMENT_TYPE</code>的非<code>null</code>对象就是一个合法的<code>React Element</code>。换言之，在<code>React</code>中，所有<code>JSX</code>在运行时的返回结果（即<code>React.createElement()</code>的返回值）都是<code>React Element</code>。
    </p>
    <p>那么<code>JSX</code>和<code>React Component</code>的关系呢?</p>
    <h2 id="react-component"><a href="#react-component" class="header-anchor">#</a> React Component</h2>
    <p>在<code>React</code>中，我们常使用<code>ClassComponent</code>与<code>FunctionComponent</code>构建组件。</p>
    <div class="language-jsx extra-class">
      <pre class="language-jsx"><code><span class="token keyword">class</span> <span class="token class-name">AppClass</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">KaSong</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'这是ClassComponent：'</span><span class="token punctuation">,</span> AppClass<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'这是Element：'</span><span class="token punctuation">,</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">AppClass</span></span><span class="token punctuation">/&gt;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token keyword">function</span> <span class="token function">AppFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">KaSong</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'这是FunctionComponent：'</span><span class="token punctuation">,</span> AppFunc<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'这是Element：'</span><span class="token punctuation">,</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">AppFunc</span></span><span class="token punctuation">/&gt;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    </div>
    <details class="custom-block details">
      <summary>React Component 分类 Demo</summary>
      <p><a href="/me.html">关注公众号</a>，后台回复<strong>901</strong>获得在线Demo地址</p>
    </details>
    <p>
      我们可以从Demo控制台打印的对象看出，<code>ClassComponent</code>对应的<code>Element</code>的<code>type</code>字段为<code>AppClass</code>自身。
    </p>
    <p><code>FunctionComponent</code>对应的<code>Element</code>的<code>type</code>字段为<code>AppFunc</code>自身，如下所示：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token punctuation">{</span>
  $$<span class="token keyword">typeof</span><span class="token operator">:</span> <span class="token function">Symbol</span><span class="token punctuation">(</span>react<span class="token punctuation">.</span>element<span class="token punctuation">)</span><span class="token punctuation">,</span>
  key<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  props<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  ref<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  type<span class="token operator">:</span> ƒ <span class="token function">AppFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  _owner<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  _store<span class="token operator">:</span> <span class="token punctuation">{</span>validated<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  _self<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  _source<span class="token operator">:</span> <span class="token keyword">null</span> 
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <p>值得注意的一点，由于</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code>AppClass <span class="token keyword">instanceof</span> <span class="token class-name">Function</span> <span class="token operator">===</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
AppFunc <span class="token keyword">instanceof</span> <span class="token class-name">Function</span> <span class="token operator">===</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
</code></pre>
    </div>
    <p>
      所以无法通过引用类型区分<code>ClassComponent</code>和<code>FunctionComponent</code>。<code>React</code>通过<code>ClassComponent</code>实例原型上的<code>isReactComponent</code>变量判断是否是<code>ClassComponent</code>。
    </p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token class-name">ClassComponent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>isReactComponent <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
    </div>
    <h2 id="jsx与fiber节点"><a href="#jsx与fiber节点" class="header-anchor">#</a> JSX与Fiber节点</h2>
    <p>
      从上面的内容我们可以发现，<code>JSX</code>是一种描述当前组件内容的数据结构，他不包含组件<strong>schedule</strong>、<strong>reconcile</strong>、<strong>render</strong>所需的相关信息。
    </p>
    <p>比如如下信息就不包括在<code>JSX</code>中：</p>
    <ul>
      <li>组件在更新中的<code>优先级</code></li>
      <li>组件的<code>state</code></li>
      <li>组件被打上的用于<strong>Renderer</strong>的<code>标记</code></li>
    </ul>
    <p>这些内容都包含在<code>Fiber节点</code>中。</p>
    <p>所以，在组件<code>mount</code>时，<code>Reconciler</code>根据<code>JSX</code>描述的组件内容生成组件对应的<code>Fiber节点</code>。</p>
    <p>
      在<code>update</code>时，<code>Reconciler</code>将<code>JSX</code>与<code>Fiber节点</code>保存的数据对比，生成组件对应的<code>Fiber节点</code>，并根据对比结果为<code>Fiber节点</code>打上<code>标记</code>。
    </p>
    <h2 id="参考资料"><a href="#参考资料" class="header-anchor">#</a> 参考资料</h2>
    <ul>
      <li>
        <p><a href="https://mp.weixin.qq.com/s/ICjOlJL-fUGRb2S_xqBT7Q" target="_blank"
            rel="noopener noreferrer">如何干掉��乎的全部DIV --
            通过这篇文章在运行时修改<code>React.createElement</code>达到消除页面所有<code>div</code>元素的效果<span><svg
                xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px"
                viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
                <path fill="currentColor"
                  d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
                </path>
                <polygon fill="currentColor"
                  points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
                </polygon>
              </svg> <span class="sr-only">(opens new window)</span></span></a></p>
      </li>
      <li>
        <p><a href="https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html" target="_blank"
            rel="noopener noreferrer">React官网Blog，关于React Component, Element, Instance, Reconciliation的简介<span><svg
                xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px"
                viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
                <path fill="currentColor"
                  d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
                </path>
                <polygon fill="currentColor"
                  points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
                </polygon>
              </svg> <span class="sr-only">(opens new window)</span></span></a></p>
      </li>
    </ul>
  </div>
  <div class="theme-default-content content__default">
    <p>本章我们会讲解<code>Fiber节点</code>是如何被创建并构建<code>Fiber树</code>的。</p>
    <p>
      <code>render阶段</code>开始于<code>performSyncWorkOnRoot</code>或<code>performConcurrentWorkOnRoot</code>方法的调用。这取决于本次更新是同步更新还是异步更新。
    </p>
    <p>我们现在还不需要学习这两个方法，只需要知道在这两个方法中会调用如下两个方法：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token comment">// performSyncWorkOnRoot会调用该方法</span>
<span class="token keyword">function</span> <span class="token function">workLoopSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>workInProgress <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">performUnitOfWork</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// performConcurrentWorkOnRoot会调用该方法</span>
<span class="token keyword">function</span> <span class="token function">workLoopConcurrent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>workInProgress <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">shouldYield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">performUnitOfWork</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <p>可以看到，他们唯一的区别是是否调用<code>shouldYield</code>。如果当前浏览器帧没有剩余时间，<code>shouldYield</code>会中止循环，直到浏览器有空闲时间后再继续遍历。</p>
    <p><code>workInProgress</code>代表当前已创建的<code>workInProgress fiber</code>。</p>
    <p>
      <code>performUnitOfWork</code>方法会创建下一个<code>Fiber节点</code>并赋值给<code>workInProgress</code>，并将<code>workInProgress</code>与已创建的<code>Fiber节点</code>连接起来构成<code>Fiber树</code>。
    </p>
    <blockquote>
      <p>你可以从<a
          href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1599"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>看到<code>workLoopConcurrent</code>的源码</p>
    </blockquote>
    <p>
      我们知道<code>Fiber Reconciler</code>是从<code>Stack Reconciler</code>重构而来，通过遍历的方式实现可中断的递归，所以<code>performUnitOfWork</code>的工作可以分为两部分：“递”和“归”。
    </p>
    <h2 id="递-阶段"><a href="#递-阶段" class="header-anchor">#</a> “递”阶段</h2>
    <p>首先从<code>rootFiber</code>开始向下深度优先遍历。为遍历到的每个<code>Fiber节点</code>调用<a
        href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L3058"
        target="_blank" rel="noopener noreferrer">beginWork方法<span><svg xmlns="http://www.w3.org/2000/svg"
            aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"
            class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a>。</p>
    <p>该方法会根据传入的<code>Fiber节点</code>创建<code>子Fiber节点</code>，并将这两个<code>Fiber节点</code>连接起来。</p>
    <p>当遍历到叶子节点（即没有子组件的组件）时就会进入“归”阶段。</p>
    <h2 id="归-阶段"><a href="#归-阶段" class="header-anchor">#</a> “归”阶段</h2>
    <p>在“归”阶段会调用<a
        href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCompleteWork.new.js#L652"
        target="_blank" rel="noopener noreferrer">completeWork<span><svg xmlns="http://www.w3.org/2000/svg"
            aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"
            class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a>处理<code>Fiber节点</code>。</p>
    <p>
      当某个<code>Fiber节点</code>执行完<code>completeWork</code>，如果其存在<code>兄弟Fiber节点</code>（即<code>fiber.sibling !== null</code>），会进入其<code>兄弟Fiber</code>的“递”阶段。
    </p>
    <p>如果不存在<code>兄弟Fiber</code>，会进入<code>父级Fiber</code>的“归”阶段。</p>
    <p>“递”和“归”阶段会交错执行直到“归”到<code>rootFiber</code>。至此，<code>render阶段</code>的工作就结束了。</p>
    <h2 id="例子"><a href="#例子" class="header-anchor">#</a> 例子</h2>
    <p>以上一节的例子举例：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      i am
      <span class="token operator">&lt;</span>span<span class="token operator">&gt;</span>KaSong<span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>

ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>App <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"root"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    </div>
    <p>对应的<code>Fiber树</code>结构：
      <img src="https://react.iamkasong.com/img/fiber.png" alt="Fiber架构">
    </p>
    <p><code>render阶段</code>会依次执行：</p>
    <div class="language-sh extra-class">
      <pre class="language-sh"><code><span class="token number">1</span>. rootFiber beginWork
<span class="token number">2</span>. App Fiber beginWork
<span class="token number">3</span>. div Fiber beginWork
<span class="token number">4</span>. <span class="token string">"i am"</span> Fiber beginWork
<span class="token number">5</span>. <span class="token string">"i am"</span> Fiber completeWork
<span class="token number">6</span>. span Fiber beginWork
<span class="token number">7</span>. span Fiber completeWork
<span class="token number">8</span>. div Fiber completeWork
<span class="token number">9</span>. App Fiber completeWork
<span class="token number">10</span>. rootFiber completeWork
</code></pre>
    </div>
    <div class="custom-block warning">
      <p class="custom-block-title">注意</p>
      <p>之所以没有 “KaSong” Fiber 的
        beginWork/completeWork，是因为作为一种性能优化手段，针对只有单一文本子节点的<code>Fiber</code>，<code>React</code>会特殊处理。</p>
    </div>
    <details class="custom-block details">
      <summary>自己试一试 Demo</summary>
      <p>我在<code>beginWork</code>和<code>completeWork</code>调用时打印<code>fiber.tag</code>和<code>fiber.type</code>。</p>
      <p>你可以从<a
          href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactWorkTags.js"
          target="_blank" rel="noopener noreferrer">ReactWorkTags.js<span><svg xmlns="http://www.w3.org/2000/svg"
              aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"
              class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new
              window)</span></span></a>看到<code>Fiber节点</code>的所有<code>tag</code>定义。</p>
      <p>相信多调试几次，你一定能明白方法的调用顺序</p>
      <p><a href="/me.html">关注公众号</a>，后台回复<strong>904</strong>获得在线Demo地址</p>
    </details>
    <details class="custom-block details">
      <summary>performUnitOfWork 的递归版本</summary>
      <p>如果将<code>performUnitOfWork</code>转化为递归版本，大体代码如下：</p>
      <div class="language-js extra-class">
        <pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">performUnitOfWork</span><span class="token punctuation">(</span><span class="token parameter">fiber</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 执行beginWork</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>fiber<span class="token punctuation">.</span>child<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">performUnitOfWork</span><span class="token punctuation">(</span>fiber<span class="token punctuation">.</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 执行completeWork</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>fiber<span class="token punctuation">.</span>sibling<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">performUnitOfWork</span><span class="token punctuation">(</span>fiber<span class="token punctuation">.</span>sibling<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
      </div>
    </details>
    <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2>
    <p>本节我们介绍了<code>render阶段</code>会调用的方法。在接下来两节中，我们会讲解<code>beginWork</code>和<code>completeWork</code>做的具体工作。</p>
    <h2 id="参考资料"><a href="#参考资料" class="header-anchor">#</a> 参考资料</h2>
    <p><a
        href="https://indepth.dev/the-how-and-why-on-reacts-usage-of-linked-list-in-fiber-to-walk-the-components-tree/"
        target="_blank" rel="noopener noreferrer">The how and why on React’s usage of linked list in Fiber to walk the
        component’s tree<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px"
            y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a></p>
    <p><a href="https://indepth.dev/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react/"
        target="_blank" rel="noopener noreferrer">Inside Fiber: in-depth overview of the new reconciliation algorithm in
        React<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px"
            viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a></p>
  </div>
  <div class="theme-default-content content__default">
    <p>
      上一节我们了解到<code>render阶段</code>的工作可以分为“递”阶段和“归”阶段。其中“递”阶段会执行<code>beginWork</code>，“归”阶段会执行<code>completeWork</code>。这一节我们看看“递”阶段的<code>beginWork</code>方法究竟做了什么。
    </p>
    <h2 id="方法概览"><a href="#方法概览" class="header-anchor">#</a> 方法概览</h2>
    <p>可以从<a
        href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L3075"
        target="_blank" rel="noopener noreferrer">源码这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
            focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a>看到<code>beginWork</code>的定义。整个方法大概有500行代码。
    </p>
    <p>从上一节我们已经知道，<code>beginWork</code>的工作是传入<code>当前Fiber节点</code>，创建<code>子Fiber节点</code>，我们从传参来看看具体是如何做的。</p>
    <h3 id="从传参看方法执行"><a href="#从传参看方法执行" class="header-anchor">#</a> 从传参看方法执行</h3>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">beginWork</span><span class="token punctuation">(</span>
  <span class="token parameter">current<span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  workInProgress<span class="token operator">:</span> Fiber<span class="token punctuation">,</span>
  renderLanes<span class="token operator">:</span> Lanes<span class="token punctuation">,</span></span>
<span class="token punctuation">)</span><span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...省略函数体</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <p>其中传参：</p>
    <ul>
      <li>current：当前组件对应的<code>Fiber节点</code>在上一次更新时的<code>Fiber节点</code>，即<code>workInProgress.alternate</code></li>
      <li>workInProgress：当前组件对应的<code>Fiber节点</code></li>
      <li>renderLanes：优先级相关，在讲解<code>Scheduler</code>时再讲解</li>
    </ul>
    <p>从<a href="/process/doubleBuffer.html">双缓存机制一节</a>我们知道，除<a
        href="/process/doubleBuffer.html#mount时"><code>rootFiber</code></a>以外，
      组件<code>mount</code>时，由于是首次渲染，是不存在当前组件对应的<code>Fiber节点</code>在上一次更新时的<code>Fiber节点</code>，即<code>mount</code>时<code>current === null</code>。
    </p>
    <p>组件<code>update</code>时，由于之前已经<code>mount</code>过，所以<code>current !== null</code>。</p>
    <p>所以我们可以通过<code>current === null ?</code>来区分组件是处于<code>mount</code>还是<code>update</code>。</p>
    <p>基于此原因，<code>beginWork</code>的工作可以分为两部分：</p>
    <ul>
      <li>
        <p>
          <code>update</code>时：如果<code>current</code>存在，在满足一定条件时可以复用<code>current</code>节点，这样就能克隆<code>current.child</code>作为<code>workInProgress.child</code>，而不需要新建<code>workInProgress.child</code>。
        </p>
      </li>
      <li>
        <p>
          <code>mount</code>时：除<code>fiberRootNode</code>以外，<code>current === null</code>。会根据<code>fiber.tag</code>不同，创建不同类型的<code>子Fiber节点</code>
        </p>
      </li>
    </ul>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">beginWork</span><span class="token punctuation">(</span>
  <span class="token parameter">current<span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  workInProgress<span class="token operator">:</span> Fiber<span class="token punctuation">,</span>
  renderLanes<span class="token operator">:</span> Lanes</span>
<span class="token punctuation">)</span><span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token punctuation">{</span>

  <span class="token comment">// update时：如果current存在可能存在优化路径，可以复用current（即上一次更新的Fiber节点）</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...省略</span>

    <span class="token comment">// 复用current</span>
    <span class="token keyword">return</span> <span class="token function">bailoutOnAlreadyFinishedWork</span><span class="token punctuation">(</span>
      current<span class="token punctuation">,</span>
      workInProgress<span class="token punctuation">,</span>
      renderLanes<span class="token punctuation">,</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    didReceiveUpdate <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// mount时：根据tag不同，创建不同的子Fiber节点</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>workInProgress<span class="token punctuation">.</span>tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> IndeterminateComponent<span class="token operator">:</span> 
      <span class="token comment">// ...省略</span>
    <span class="token keyword">case</span> LazyComponent<span class="token operator">:</span> 
      <span class="token comment">// ...省略</span>
    <span class="token keyword">case</span> FunctionComponent<span class="token operator">:</span> 
      <span class="token comment">// ...省略</span>
    <span class="token keyword">case</span> ClassComponent<span class="token operator">:</span> 
      <span class="token comment">// ...省略</span>
    <span class="token keyword">case</span> HostRoot<span class="token operator">:</span>
      <span class="token comment">// ...省略</span>
    <span class="token keyword">case</span> HostComponent<span class="token operator">:</span>
      <span class="token comment">// ...省略</span>
    <span class="token keyword">case</span> HostText<span class="token operator">:</span>
      <span class="token comment">// ...省略</span>
    <span class="token comment">// ...省略其他类型</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <h2 id="update时"><a href="#update时" class="header-anchor">#</a> update时</h2>
    <p>我们可以看到，满足如下情况时<code>didReceiveUpdate === false</code>（即可以直接复用前一次更新的<code>子Fiber</code>，不需要新建<code>子Fiber</code>）
    </p>
    <ol>
      <li>
        <code>oldProps === newProps &amp;&amp; workInProgress.type === current.type</code>，即<code>props</code>与<code>fiber.type</code>不变
      </li>
      <li>
        <code>!includesSomeLane(renderLanes, updateLanes)</code>，即当前<code>Fiber节点</code>优先级不够，会在讲解<code>Scheduler</code>时介绍
      </li>
    </ol>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> oldProps <span class="token operator">=</span> current<span class="token punctuation">.</span>memoizedProps<span class="token punctuation">;</span>
    <span class="token keyword">const</span> newProps <span class="token operator">=</span> workInProgress<span class="token punctuation">.</span>pendingProps<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>
      oldProps <span class="token operator">!==</span> newProps <span class="token operator">||</span>
      <span class="token function">hasLegacyContextChanged</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span>
      <span class="token punctuation">(</span>__DEV__ <span class="token operator">?</span> workInProgress<span class="token punctuation">.</span>type <span class="token operator">!==</span> current<span class="token punctuation">.</span>type <span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span> <span class="token punctuation">{</span>
      didReceiveUpdate <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">includesSomeLane</span><span class="token punctuation">(</span>renderLanes<span class="token punctuation">,</span> updateLanes<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      didReceiveUpdate <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
      <span class="token keyword">switch</span> <span class="token punctuation">(</span>workInProgress<span class="token punctuation">.</span>tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 省略处理</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span> <span class="token function">bailoutOnAlreadyFinishedWork</span><span class="token punctuation">(</span>
        current<span class="token punctuation">,</span>
        workInProgress<span class="token punctuation">,</span>
        renderLanes<span class="token punctuation">,</span>
      <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      didReceiveUpdate <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    didReceiveUpdate <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre>
    </div>
    <h2 id="mount时"><a href="#mount时" class="header-anchor">#</a> mount时</h2>
    <p>当不满足优化路径时，我们就进入第二部分，新建<code>子Fiber</code>。</p>
    <p>我们可以看到，根据<code>fiber.tag</code>不同，进入不同类型<code>Fiber</code>的创建逻辑。</p>
    <blockquote>
      <p>可以从<a
          href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactWorkTags.js"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>看到<code>tag</code>对应的组件类型</p>
    </blockquote>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token comment">// mount时：根据tag不同，创建不同的Fiber节点</span>
<span class="token keyword">switch</span> <span class="token punctuation">(</span>workInProgress<span class="token punctuation">.</span>tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">case</span> IndeterminateComponent<span class="token operator">:</span> 
    <span class="token comment">// ...省略</span>
  <span class="token keyword">case</span> LazyComponent<span class="token operator">:</span> 
    <span class="token comment">// ...省略</span>
  <span class="token keyword">case</span> FunctionComponent<span class="token operator">:</span> 
    <span class="token comment">// ...省略</span>
  <span class="token keyword">case</span> ClassComponent<span class="token operator">:</span> 
    <span class="token comment">// ...省略</span>
  <span class="token keyword">case</span> HostRoot<span class="token operator">:</span>
    <span class="token comment">// ...省略</span>
  <span class="token keyword">case</span> HostComponent<span class="token operator">:</span>
    <span class="token comment">// ...省略</span>
  <span class="token keyword">case</span> HostText<span class="token operator">:</span>
    <span class="token comment">// ...省略</span>
  <span class="token comment">// ...省略其他类型</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <p>对于我们常见的组件类型，如（<code>FunctionComponent</code>/<code>ClassComponent</code>/<code>HostComponent</code>），最终会进入<a
        href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L233"
        target="_blank" rel="noopener noreferrer">reconcileChildren<span><svg xmlns="http://www.w3.org/2000/svg"
            aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"
            class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a>方法。</p>
    <h2 id="reconcilechildren"><a href="#reconcilechildren" class="header-anchor">#</a> reconcileChildren</h2>
    <p>从该函数名就能看出这是<code>Reconciler</code>模块的核心部分。那么他究竟做了什么呢？</p>
    <ul>
      <li>
        <p>对于<code>mount</code>的组件，他会创建新的<code>子Fiber节点</code></p>
      </li>
      <li>
        <p>
          对于<code>update</code>的组件，他会将当前组件与该组件在上次更新时对应的<code>Fiber节点</code>比较（也就是俗称的<code>Diff</code>算法），将比较的结果生成新<code>Fiber节点</code>
        </p>
      </li>
    </ul>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">reconcileChildren</span><span class="token punctuation">(</span>
  <span class="token parameter">current<span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  workInProgress<span class="token operator">:</span> Fiber<span class="token punctuation">,</span>
  nextChildren<span class="token operator">:</span> any<span class="token punctuation">,</span>
  renderLanes<span class="token operator">:</span> Lanes</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 对于mount的组件</span>
    workInProgress<span class="token punctuation">.</span>child <span class="token operator">=</span> <span class="token function">mountChildFibers</span><span class="token punctuation">(</span>
      workInProgress<span class="token punctuation">,</span>
      <span class="token keyword">null</span><span class="token punctuation">,</span>
      nextChildren<span class="token punctuation">,</span>
      renderLanes<span class="token punctuation">,</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 对于update的组件</span>
    workInProgress<span class="token punctuation">.</span>child <span class="token operator">=</span> <span class="token function">reconcileChildFibers</span><span class="token punctuation">(</span>
      workInProgress<span class="token punctuation">,</span>
      current<span class="token punctuation">.</span>child<span class="token punctuation">,</span>
      nextChildren<span class="token punctuation">,</span>
      renderLanes<span class="token punctuation">,</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <p>从代码可以看出，和<code>beginWork</code>一样，他也是通过<code>current === null ?</code>区分<code>mount</code>与<code>update</code>。
    </p>
    <p>不论走哪个逻辑，最终他会生成新的子<code>Fiber节点</code>并赋值给<code>workInProgress.child</code>，作为本次<code>beginWork</code><a
        href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L1158"
        target="_blank" rel="noopener noreferrer">返回值<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
            focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new
            window)</span></span></a>，并作为下次<code>performUnitOfWork</code>执行时<code>workInProgress</code>的<a
        href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1702"
        target="_blank" rel="noopener noreferrer">传参<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
            focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a>。</p>
    <div class="custom-block warning">
      <p class="custom-block-title">注意</p>
      <p>
        值得一提的是，<code>mountChildFibers</code>与<code>reconcileChildFibers</code>这两个方法的逻辑基本一致。唯一的区别是：<code>reconcileChildFibers</code>会为生成的<code>Fiber节点</code>带上<code>effectTag</code>属性，而<code>mountChildFibers</code>不会。
      </p>
    </div>
    <h2 id="effecttag"><a href="#effecttag" class="header-anchor">#</a> effectTag</h2>
    <p>
      我们知道，<code>render阶段</code>的工作是在内存中进行，当工作结束后会通知<code>Renderer</code>需要执行的<code>DOM</code>操作。要执行<code>DOM</code>操作的具体类型就保存在<code>fiber.effectTag</code>中。
    </p>
    <blockquote>
      <p>你可以从<a
          href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactSideEffectTags.js"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new
              window)</span></span></a>看到<code>effectTag</code>对应的<code>DOM</code>操作</p>
    </blockquote>
    <p>比如：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token comment">// DOM需要插入到页面中</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> Placement <span class="token operator">=</span> <span class="token comment">/*                */</span> <span class="token number">0b00000000000010</span><span class="token punctuation">;</span>
<span class="token comment">// DOM需要更新</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> Update <span class="token operator">=</span> <span class="token comment">/*                   */</span> <span class="token number">0b00000000000100</span><span class="token punctuation">;</span>
<span class="token comment">// DOM需要插入到页面中并更新</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> PlacementAndUpdate <span class="token operator">=</span> <span class="token comment">/*       */</span> <span class="token number">0b00000000000110</span><span class="token punctuation">;</span>
<span class="token comment">// DOM需要删除</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> Deletion <span class="token operator">=</span> <span class="token comment">/*                 */</span> <span class="token number">0b00000000001000</span><span class="token punctuation">;</span>
</code></pre>
    </div>
    <blockquote>
      <p>通过二进制表示<code>effectTag</code>，可以方便的使用位操作为<code>fiber.effectTag</code>赋值多个<code>effect</code>。</p>
    </blockquote>
    <p>那么，如果要通知<code>Renderer</code>将<code>Fiber节点</code>对应的<code>DOM节点</code>插入页面中，需要满足两个条件：</p>
    <ol>
      <li>
        <p><code>fiber.stateNode</code>存在，即<code>Fiber节点</code>中保存了对应的<code>DOM节点</code></p>
      </li>
      <li>
        <p><code>(fiber.effectTag &amp; Placement) !== 0</code>，即<code>Fiber节点</code>存在<code>Placement effectTag</code>
        </p>
      </li>
    </ol>
    <p>
      我们知道，<code>mount</code>时，<code>fiber.stateNode === null</code>，且在<code>reconcileChildren</code>中调用的<code>mountChildFibers</code>不会为<code>Fiber节点</code>赋值<code>effectTag</code>。那么首屏渲染如何完成呢？
    </p>
    <p>针对第一个问题，<code>fiber.stateNode</code>会在<code>completeWork</code>中创建，我们会在下一节介绍。</p>
    <p>
      第二个问题的答案十分巧妙：假设<code>mountChildFibers</code>也会赋值<code>effectTag</code>，那么可以预见<code>mount</code>时整棵<code>Fiber树</code>所有节点都会有<code>Placement effectTag</code>。那么<code>commit阶段</code>在执行<code>DOM</code>操作时每个节点都会执行一次插入操作，这样大量的<code>DOM</code>操作是极低效的。
    </p>
    <p>
      为了解决这个问题，在<code>mount</code>时只有<code>rootFiber</code>会赋值<code>Placement effectTag</code>，在<code>commit阶段</code>只会执行一次插入操作。
    </p>
    <details class="custom-block details">
      <summary>根Fiber节点 Demo</summary>
      <p>
        借用上一节的Demo，第一个进入<code>beginWork</code>方法的<code>Fiber节点</code>就是<code>rootFiber</code>，他的<code>alternate</code>指向<code>current rootFiber</code>（即他存在<code>current</code>）。
      </p>
      <blockquote>
        <p>为什么<code>rootFiber</code>节点存在<code>current</code>（即<code>rootFiber.alternate</code>），我们在<a
            href="/process/doubleBuffer.html">双缓存机制一节mount时的第二步</a>已经讲过</p>
      </blockquote>
      <p>
        由于存在<code>current</code>，<code>rootFiber</code>在<code>reconcileChildren</code>时会走<code>reconcileChildFibers</code>逻辑。
      </p>
      <p>而之后通过<code>beginWork</code>创建的<code>Fiber节点</code>是不存在<code>current</code>的（即
        <code>fiber.alternate === null</code>），会走<code>mountChildFibers</code>逻辑</p>
      <p><a href="/me.html">关注公众号</a>，后台回复<strong>531</strong>获得在线Demo地址</p>
    </details>
    <h2 id="参考资料"><a href="#参考资料" class="header-anchor">#</a> 参考资料</h2>
    <p><code>beginWork</code>流程图</p> <img src="https://react.iamkasong.com/img/beginWork.png" alt="beginWork流程图">
  </div>
  <div class="theme-default-content content__default">
    <p>在<a
        href="/process/reconciler">流程概览一节</a>我们了解组件在<code>render阶段</code>会经历<code>beginWork</code>与<code>completeWork</code>。
    </p>
    <p>上一节我们讲解了组件执行<code>beginWork</code>后会创建<code>子Fiber节点</code>，节点上可能存在<code>effectTag</code>。</p>
    <p>这一节让我们看看<code>completeWork</code>会做什么工作。</p>
    <p>你可以从<a
        href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberCompleteWork.new.js#L673"
        target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
            focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a>看到<code>completeWork</code>方法定义。</p>
    <h2 id="流程概览"><a href="#流程概览" class="header-anchor">#</a> 流程概览</h2>
    <p>类似<code>beginWork</code>，<code>completeWork</code>也是针对不同<code>fiber.tag</code>调用不同的处理逻辑。</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">completeWork</span><span class="token punctuation">(</span>
  <span class="token parameter">current<span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  workInProgress<span class="token operator">:</span> Fiber<span class="token punctuation">,</span>
  renderLanes<span class="token operator">:</span> Lanes<span class="token punctuation">,</span></span>
<span class="token punctuation">)</span><span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> newProps <span class="token operator">=</span> workInProgress<span class="token punctuation">.</span>pendingProps<span class="token punctuation">;</span>

  <span class="token keyword">switch</span> <span class="token punctuation">(</span>workInProgress<span class="token punctuation">.</span>tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> IndeterminateComponent<span class="token operator">:</span>
    <span class="token keyword">case</span> LazyComponent<span class="token operator">:</span>
    <span class="token keyword">case</span> SimpleMemoComponent<span class="token operator">:</span>
    <span class="token keyword">case</span> FunctionComponent<span class="token operator">:</span>
    <span class="token keyword">case</span> ForwardRef<span class="token operator">:</span>
    <span class="token keyword">case</span> Fragment<span class="token operator">:</span>
    <span class="token keyword">case</span> Mode<span class="token operator">:</span>
    <span class="token keyword">case</span> Profiler<span class="token operator">:</span>
    <span class="token keyword">case</span> ContextConsumer<span class="token operator">:</span>
    <span class="token keyword">case</span> MemoComponent<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> ClassComponent<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token comment">// ...省略</span>
      <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">case</span> HostRoot<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token comment">// ...省略</span>
      <span class="token function">updateHostContainer</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">case</span> HostComponent<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token comment">// ...省略</span>
      <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token comment">// ...省略</span>
</code></pre>
    </div>
    <p>
      我们重点关注页面渲染所必须的<code>HostComponent</code>（即原生<code>DOM组件</code>对应的<code>Fiber节点</code>），其他类型<code>Fiber</code>的处理留在具体功能实现时讲解。
    </p>
    <h2 id="处理hostcomponent"><a href="#处理hostcomponent" class="header-anchor">#</a> 处理HostComponent</h2>
    <p>和<code>beginWork</code>一样，我们根据<code>current === null ?</code>判断是<code>mount</code>还是<code>update</code>。</p>
    <p>
      同时针对<code>HostComponent</code>，判断<code>update</code>时我们还需要考虑<code>workInProgress.stateNode != null ?</code>（即该<code>Fiber节点</code>是否存在对应的<code>DOM节点</code>）
    </p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">case</span> HostComponent<span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token function">popHostContext</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> rootContainerInstance <span class="token operator">=</span> <span class="token function">getRootHostContainer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> type <span class="token operator">=</span> workInProgress<span class="token punctuation">.</span>type<span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> workInProgress<span class="token punctuation">.</span>stateNode <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// update的情况</span>
    <span class="token comment">// ...省略</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// mount的情况</span>
    <span class="token comment">// ...省略</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <h2 id="update时"><a href="#update时" class="header-anchor">#</a> update时</h2>
    <p>
      当<code>update</code>时，<code>Fiber节点</code>已经存在对应<code>DOM节点</code>，所以不需要生成<code>DOM节点</code>。需要做的主要是处理<code>props</code>，比如：
    </p>
    <ul>
      <li><code>onClick</code>、<code>onChange</code>等回调函数的注册</li>
      <li>处理<code>style prop</code></li>
      <li>处理<code>DANGEROUSLY_SET_INNER_HTML prop</code></li>
      <li>处理<code>children prop</code></li>
    </ul>
    <p>我们去掉一些当前不需要关注的功能（比如<code>ref</code>）。可以看到最主要的逻辑是调用<code>updateHostComponent</code>方法。</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> workInProgress<span class="token punctuation">.</span>stateNode <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// update的情况</span>
  <span class="token function">updateHostComponent</span><span class="token punctuation">(</span>
    current<span class="token punctuation">,</span>
    workInProgress<span class="token punctuation">,</span>
    type<span class="token punctuation">,</span>
    newProps<span class="token punctuation">,</span>
    rootContainerInstance<span class="token punctuation">,</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <p>你可以从<a
        href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberCompleteWork.new.js#L225"
        target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
            focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a>看到<code>updateHostComponent</code>方法定义。</p>
    <p>
      在<code>updateHostComponent</code>内部，被处理完的<code>props</code>会被赋值给<code>workInProgress.updateQueue</code>，并最终会在<code>commit阶段</code>被渲染在页面上。
    </p>
    <div class="language-ts extra-class">
      <pre class="language-ts"><code>workInProgress<span class="token punctuation">.</span>updateQueue <span class="token operator">=</span> <span class="token punctuation">(</span>updatePayload<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    </div>
    <p>其中<code>updatePayload</code>为数组形式，他的偶数索引的值为变化的<code>prop key</code>，奇数索引的值为变化的<code>prop value</code>。</p>
    <blockquote>
      <p>具体渲染过程见<a href="/renderer/mutation.html#hostcomponent-mutation">mutation阶段一节</a></p>
    </blockquote>
    <details class="custom-block details">
      <summary>updatePayload属性 Demo</summary>
      <p><code>updateHostComponent</code>方法内打印了<code>Fiber节点</code>对应的<code>type</code>与<code>updatePayload</code>。</p>
      <p>你可以直观的感受<code>updatePayload</code>的数据结构</p>
      <p><a href="/me.html">关注公众号</a>，后台回复<strong>431</strong>获得在线Demo地址</p>
    </details>
    <h2 id="mount时"><a href="#mount时" class="header-anchor">#</a> mount时</h2>
    <p>同样，我们省略了不相关的逻辑。可以看到，<code>mount</code>时的主要逻辑包括三个：</p>
    <ul>
      <li>为<code>Fiber节点</code>生成对应的<code>DOM节点</code></li>
      <li>将子孙<code>DOM节点</code>插入刚生成的<code>DOM节点</code>中</li>
      <li>与<code>update</code>逻辑中的<code>updateHostComponent</code>类似的处理<code>props</code>的过程</li>
    </ul>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token comment">// mount的情况</span>

<span class="token comment">// ...省略服务端渲染相关逻辑</span>

<span class="token keyword">const</span> currentHostContext <span class="token operator">=</span> <span class="token function">getHostContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 为fiber创建对应DOM节点</span>
<span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token function">createInstance</span><span class="token punctuation">(</span>
    type<span class="token punctuation">,</span>
    newProps<span class="token punctuation">,</span>
    rootContainerInstance<span class="token punctuation">,</span>
    currentHostContext<span class="token punctuation">,</span>
    workInProgress<span class="token punctuation">,</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 将子孙DOM节点插入刚生成的DOM节点中</span>
<span class="token function">appendAllChildren</span><span class="token punctuation">(</span>instance<span class="token punctuation">,</span> workInProgress<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// DOM节点赋值给fiber.stateNode</span>
workInProgress<span class="token punctuation">.</span>stateNode <span class="token operator">=</span> instance<span class="token punctuation">;</span>

<span class="token comment">// 与update逻辑中的updateHostComponent类似的处理props的过程</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>
  <span class="token function">finalizeInitialChildren</span><span class="token punctuation">(</span>
    instance<span class="token punctuation">,</span>
    type<span class="token punctuation">,</span>
    newProps<span class="token punctuation">,</span>
    rootContainerInstance<span class="token punctuation">,</span>
    currentHostContext<span class="token punctuation">,</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">markUpdate</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <p>还记得<a
        href="/process/beginWork.html#effecttag">上一节</a>我们讲到：<code>mount</code>时只会在<code>rootFiber</code>存在<code>Placement effectTag</code>。那么<code>commit阶段</code>是如何通过一次插入<code>DOM</code>操作（对应一个<code>Placement effectTag</code>）将整棵<code>DOM树</code>插入页面的呢？
    </p>
    <p>原因就在于<code>completeWork</code>中的<code>appendAllChildren</code>方法。</p>
    <p>
      由于<code>completeWork</code>属于“归”阶段调用的函数，每次调用<code>appendAllChildren</code>时都会将已生成的子孙<code>DOM节点</code>插入当前生成的<code>DOM节点</code>下。那么当“归”到<code>rootFiber</code>时，我们已经有一个构建好的离屏<code>DOM树</code>。
    </p>
    <h2 id="effectlist"><a href="#effectlist" class="header-anchor">#</a> effectList</h2>
    <p>至此<code>render阶段</code>的绝大部分工作就完成了。</p>
    <p>
      还有一个问题：作为<code>DOM</code>操作的依据，<code>commit阶段</code>需要找到所有有<code>effectTag</code>的<code>Fiber节点</code>并依次执行<code>effectTag</code>对应操作。难道需要在<code>commit阶段</code>再遍历一次<code>Fiber树</code>寻找<code>effectTag !== null</code>的<code>Fiber节点</code>么？
    </p>
    <p>这显然是很低效的。</p>
    <p>
      为了解决这个问题，在<code>completeWork</code>的上层函数<code>completeUnitOfWork</code>中，每个执行完<code>completeWork</code>且存在<code>effectTag</code>的<code>Fiber节点</code>会被保存在一条被称为<code>effectList</code>的单向链表中。
    </p>
    <p>
      <code>effectList</code>中第一个<code>Fiber节点</code>保存在<code>fiber.firstEffect</code>，最后一个元素保存在<code>fiber.lastEffect</code>。
    </p>
    <p>
      类似<code>appendAllChildren</code>，在“归”阶段，所有有<code>effectTag</code>的<code>Fiber节点</code>都会被追加在<code>effectList</code>中，最终形成一条以<code>rootFiber.firstEffect</code>为起点的单向链表。
    </p>
    <div class="language-js extra-class">
      <pre class="language-js"><code>                       nextEffect         nextEffect
rootFiber<span class="token punctuation">.</span>firstEffect <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">&gt;</span> fiber <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">&gt;</span> fiber
</code></pre>
    </div>
    <p>这样，在<code>commit阶段</code>只需要遍历<code>effectList</code>就能执行所有<code>effect</code>了。</p>
    <p>你可以在<a
        href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1744"
        target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
            focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a>看到这段代码逻辑。</p>
    <p>借用<code>React</code>团队成员<strong>Dan
        Abramov</strong>的话：<code>effectList</code>相较于<code>Fiber树</code>，就像圣诞树上挂的那一串彩灯。</p>
    <h2 id="流程结尾"><a href="#流程结尾" class="header-anchor">#</a> 流程结尾</h2>
    <p>
      至此，<code>render阶段</code>全部工作完成。在<code>performSyncWorkOnRoot</code>函数中<code>fiberRootNode</code>被传递给<code>commitRoot</code>方法，开启<code>commit阶段</code>工作流程。
    </p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token function">commitRoot</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    </div>
    <p>代码见<a
        href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1107"
        target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
            focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a>。</p>
    <h2 id="参考资料"><a href="#参考资料" class="header-anchor">#</a> 参考资料</h2>
    <p><code>completeWork</code>流程图</p> <img src="https://react.iamkasong.com/img/completeWork.png"
      alt="completeWork流程图">
  </div>
  <div class="theme-default-content content__default">
    <p>上一章<a
        href="/process/completeWork.html#流程结尾">最后一节</a>我们介绍了，<code>commitRoot</code>方法是<code>commit阶段</code>工作的起点。<code>fiberRootNode</code>会作为传参。
    </p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token function">commitRoot</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    </div>
    <p>
      在<code>rootFiber.firstEffect</code>上保存了一条需要执行<code>副作用</code>的<code>Fiber节点</code>的单向链表<code>effectList</code>，这些<code>Fiber节点</code>的<code>updateQueue</code>中保存了变化的<code>props</code>。
    </p>
    <p>这些<code>副作用</code>对应的<code>DOM操作</code>在<code>commit</code>阶段执行。</p>
    <p>
      除此之外，一些生命周期钩子（比如<code>componentDidXXX</code>）、<code>hook</code>（比如<code>useEffect</code>）需要在<code>commit</code>阶段执行。
    </p>
    <p><code>commit</code>阶段的主要工作（即<code>Renderer</code>的工作流程）分为三部分：</p>
    <ul>
      <li>
        <p>before mutation阶段（执行<code>DOM</code>操作前）</p>
      </li>
      <li>
        <p>mutation阶段（执行<code>DOM</code>操作）</p>
      </li>
      <li>
        <p>layout阶段（执行<code>DOM</code>操作后）</p>
      </li>
    </ul>
    <p>你可以从<a
        href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L2001"
        target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
            focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a>看到<code>commit</code>阶段的完整代码</p>
    <p>
      在<code>before mutation阶段</code>之前和<code>layout阶段</code>之后还有一些额外工作，涉及到比如<code>useEffect</code>的触发、<code>优先级相关</code>的重置、<code>ref</code>的绑定/解绑。
    </p>
    <p>这些对我们当前属于超纲内容，为了内容完整性，在这节简单介绍。</p>
    <h2 id="before-mutation之前"><a href="#before-mutation之前" class="header-anchor">#</a> before mutation之前</h2>
    <p><code>commitRootImpl</code>方法中直到第一句<code>if (firstEffect !== null)</code>之前属于<code>before mutation</code>之前。</p>
    <p>我们大体看下他做的工作，现在你还不需要理解他们：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">do</span> <span class="token punctuation">{</span>
    <span class="token comment">// 触发useEffect回调与其他同步任务。由于这些任务可能触发新的渲染，所以这里要一直遍历执行直到没有任务</span>
    <span class="token function">flushPassiveEffects</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>rootWithPendingPassiveEffects <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// root指 fiberRootNode</span>
  <span class="token comment">// root.finishedWork指当前应用的rootFiber</span>
  <span class="token keyword">const</span> finishedWork <span class="token operator">=</span> root<span class="token punctuation">.</span>finishedWork<span class="token punctuation">;</span>

  <span class="token comment">// 凡是变量名带lane的都是优先级相关</span>
  <span class="token keyword">const</span> lanes <span class="token operator">=</span> root<span class="token punctuation">.</span>finishedLanes<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>finishedWork <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  root<span class="token punctuation">.</span>finishedWork <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  root<span class="token punctuation">.</span>finishedLanes <span class="token operator">=</span> NoLanes<span class="token punctuation">;</span>

  <span class="token comment">// 重置Scheduler绑定的回调函数</span>
  root<span class="token punctuation">.</span>callbackNode <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  root<span class="token punctuation">.</span>callbackId <span class="token operator">=</span> NoLanes<span class="token punctuation">;</span>

  <span class="token keyword">let</span> remainingLanes <span class="token operator">=</span> <span class="token function">mergeLanes</span><span class="token punctuation">(</span>finishedWork<span class="token punctuation">.</span>lanes<span class="token punctuation">,</span> finishedWork<span class="token punctuation">.</span>childLanes<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 重置优先级相关变量</span>
  <span class="token function">markRootFinished</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> remainingLanes<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 清除已完成的discrete updates，例如：用户鼠标点击触发的更新。</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>rootsWithPendingDiscreteUpdates <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>
      <span class="token operator">!</span><span class="token function">hasDiscreteLanes</span><span class="token punctuation">(</span>remainingLanes<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
      rootsWithPendingDiscreteUpdates<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span>
    <span class="token punctuation">)</span> <span class="token punctuation">{</span>
      rootsWithPendingDiscreteUpdates<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 重置全局变量</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">===</span> workInProgressRoot<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    workInProgressRoot <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    workInProgress <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    workInProgressRootRenderLanes <span class="token operator">=</span> NoLanes<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 将effectList赋值给firstEffect</span>
  <span class="token comment">// 由于每个fiber的effectList只包含他的子孙节点</span>
  <span class="token comment">// 所以根节点如果有effectTag则不会被包含进来</span>
  <span class="token comment">// 所以这里将有effectTag的根节点插入到effectList尾部</span>
  <span class="token comment">// 这样才能保证有effect的fiber都在effectList中</span>
  <span class="token keyword">let</span> firstEffect<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>finishedWork<span class="token punctuation">.</span>effectTag <span class="token operator">&gt;</span> PerformedWork<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>finishedWork<span class="token punctuation">.</span>lastEffect <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      finishedWork<span class="token punctuation">.</span>lastEffect<span class="token punctuation">.</span>nextEffect <span class="token operator">=</span> finishedWork<span class="token punctuation">;</span>
      firstEffect <span class="token operator">=</span> finishedWork<span class="token punctuation">.</span>firstEffect<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      firstEffect <span class="token operator">=</span> finishedWork<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 根节点没有effectTag</span>
    firstEffect <span class="token operator">=</span> finishedWork<span class="token punctuation">.</span>firstEffect<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre>
    </div>
    <p>可以看到，<code>before mutation</code>之前主要做一些变量赋值，状态重置的工作。</p>
    <p>这一长串代码我们只需要关注最后赋值的<code>firstEffect</code>，在<code>commit</code>的三个子阶段都会用到他。</p>
    <h2 id="layout之后"><a href="#layout之后" class="header-anchor">#</a> layout之后</h2>
    <p>接下来让我们简单看下<code>layout</code>阶段执行完后的代码，现在你还不需要理解他们：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">const</span> rootDidHavePassiveEffects <span class="token operator">=</span> rootDoesHavePassiveEffects<span class="token punctuation">;</span>

<span class="token comment">// useEffect相关</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>rootDoesHavePassiveEffects<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  rootDoesHavePassiveEffects <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  rootWithPendingPassiveEffects <span class="token operator">=</span> root<span class="token punctuation">;</span>
  pendingPassiveEffectsLanes <span class="token operator">=</span> lanes<span class="token punctuation">;</span>
  pendingPassiveEffectsRenderPriority <span class="token operator">=</span> renderPriorityLevel<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">// 性能优化相关</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>remainingLanes <span class="token operator">!==</span> NoLanes<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>enableSchedulerTracing<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token comment">// 性能优化相关</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>enableSchedulerTracing<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>rootDidHavePassiveEffects<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// ...检测无限循环的同步任务</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>remainingLanes <span class="token operator">===</span> SyncLane<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span> 

<span class="token comment">// 在离开commitRoot函数前调用，触发一次新的调度，确保任何附加的任务被调度</span>
<span class="token function">ensureRootIsScheduled</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// ...处理未捕获错误及老版本遗留的边界问题</span>


<span class="token comment">// 执行同步任务，这样同步任务不需要等到下次事件循环再执行</span>
<span class="token comment">// 比如在 componentDidMount 中执行 setState 创建的更新会在这里被同步执行</span>
<span class="token comment">// 或useLayoutEffect</span>
<span class="token function">flushSyncCallbackQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre>
    </div>
    <blockquote>
      <p>你可以在<a
          href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L2195"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>看到这段代码</p>
    </blockquote>
    <p>主要包括三点内容：</p>
    <ol>
      <li><code>useEffect</code>相关的处理。</li>
    </ol>
    <p>我们会在讲解<code>layout阶段</code>时讲解。</p>
    <ol start="2">
      <li>性能追踪相关。</li>
    </ol>
    <p>源码里有很多和<code>interaction</code>相关的变量。他们都和追踪<code>React</code>渲染时间、性能相关，在<a
        href="https://zh-hans.reactjs.org/docs/profiler.html" target="_blank" rel="noopener noreferrer">Profiler
        API<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px"
            viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a>和<a
        href="https://github.com/facebook/react-devtools/pull/1069" target="_blank"
        rel="noopener noreferrer">DevTools<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
            focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a>中使用。</p>
    <blockquote>
      <p>你可以在这里看到<a href="https://gist.github.com/bvaughn/8de925562903afd2e7a12554adcdda16#overview" target="_blank"
          rel="noopener noreferrer">interaction的定义<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a></p>
    </blockquote>
    <ol start="3">
      <li>在<code>commit</code>阶段会触发一些生命周期钩子（如
        <code>componentDidXXX</code>）和<code>hook</code>（如<code>useLayoutEffect</code>、<code>useEffect</code>）。</li>
    </ol>
    <p>在这些回调方法中可能触发新的更新，新的更新会开启新的<code>render-commit</code>流程。考虑如下Demo：</p>
    <details class="custom-block details">
      <summary>useLayoutEffect Demo</summary>
      <p>在该Demo中我们点击页面中的数字，状态会先变为0，再在<code>useLayoutEffect</code>回调中变为随机数。但在页面上数字不会变为0，而是直接变为新的随机数。</p>
      <p>
        这是因为<code>useLayoutEffect</code>会在<code>layout阶段</code>同步执行回调。回调中我们触发了状态更新<code>setCount(randomNum)</code>，这会重新调度一个同步任务。
      </p>
      <p>该任务会在在如上<code>commitRoot</code>倒数第二行代码处被同步执行。</p>
      <div class="language-js extra-class">
        <pre class="language-js"><code><span class="token function">flushSyncCallbackQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
      </div>
      <p>所以我们看不到页面中元素先变为0。</p>
      <p>如果换成<code>useEffect</code>多点击几次就能看到区别。</p>
      <p><a href="/me.html">关注公众号</a>，后台回复<strong>908</strong>获得在线Demo地址</p>
    </details>
  </div>
  <div class="theme-default-content content__default">
    <p>在本节正式开始前，让我们复习下这一章到目前为止所学的。</p>
    <p><code>Renderer</code>工作的阶段被称为<code>commit</code>阶段。<code>commit</code>阶段可以分为三个子阶段：</p>
    <ul>
      <li>
        <p>before mutation阶段（执行<code>DOM</code>操作前）</p>
      </li>
      <li>
        <p>mutation阶段（执行<code>DOM</code>操作）</p>
      </li>
      <li>
        <p>layout阶段（执行<code>DOM</code>操作后）</p>
      </li>
    </ul>
    <p>本节我们看看<code>before mutation阶段</code>（执行<code>DOM</code>操作前）都做了什么。</p>
    <h2 id="概览"><a href="#概览" class="header-anchor">#</a> 概览</h2>
    <p>
      <code>before mutation阶段</code>的代码很短，整个过程就是遍历<code>effectList</code>并调用<code>commitBeforeMutationEffects</code>函数处理。
    </p>
    <blockquote>
      <p>这部分<a
          href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L2104-L2127"
          target="_blank" rel="noopener noreferrer">源码在这里<span><svg xmlns="http://www.w3.org/2000/svg"
              aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"
              class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>。为了增加可读性，示例代码中删除了不相关的逻辑</p>
    </blockquote>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token comment">// 保存之前的优先级，以同步优先级执行，执行完毕后恢复之前优先级</span>
<span class="token keyword">const</span> previousLanePriority <span class="token operator">=</span> <span class="token function">getCurrentUpdateLanePriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setCurrentUpdateLanePriority</span><span class="token punctuation">(</span>SyncLanePriority<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 将当前上下文标记为CommitContext，作为commit阶段的标志</span>
<span class="token keyword">const</span> prevExecutionContext <span class="token operator">=</span> executionContext<span class="token punctuation">;</span>
executionContext <span class="token operator">|=</span> CommitContext<span class="token punctuation">;</span>

<span class="token comment">// 处理focus状态</span>
focusedInstanceHandle <span class="token operator">=</span> <span class="token function">prepareForCommit</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>containerInfo<span class="token punctuation">)</span><span class="token punctuation">;</span>
shouldFireAfterActiveInstanceBlur <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

<span class="token comment">// beforeMutation阶段的主函数</span>
<span class="token function">commitBeforeMutationEffects</span><span class="token punctuation">(</span>finishedWork<span class="token punctuation">)</span><span class="token punctuation">;</span>

focusedInstanceHandle <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre>
    </div>
    <p>我们重点关注<code>beforeMutation</code>阶段的主函数<code>commitBeforeMutationEffects</code>做了什么。</p>
    <h2 id="commitbeforemutationeffects"><a href="#commitbeforemutationeffects" class="header-anchor">#</a>
      commitBeforeMutationEffects</h2>
    <p>大体代码逻辑：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">commitBeforeMutationEffects</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>nextEffect <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> current <span class="token operator">=</span> nextEffect<span class="token punctuation">.</span>alternate<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>shouldFireAfterActiveInstanceBlur <span class="token operator">&amp;&amp;</span> focusedInstanceHandle <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// ...focus blur相关</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">const</span> effectTag <span class="token operator">=</span> nextEffect<span class="token punctuation">.</span>effectTag<span class="token punctuation">;</span>

    <span class="token comment">// 调用getSnapshotBeforeUpdate</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>effectTag <span class="token operator">&amp;</span> Snapshot<span class="token punctuation">)</span> <span class="token operator">!==</span> NoEffect<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">commitBeforeMutationEffectOnFiber</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> nextEffect<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 调度useEffect</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>effectTag <span class="token operator">&amp;</span> Passive<span class="token punctuation">)</span> <span class="token operator">!==</span> NoEffect<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>rootDoesHavePassiveEffects<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        rootDoesHavePassiveEffects <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token function">scheduleCallback</span><span class="token punctuation">(</span>NormalSchedulerPriority<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
          <span class="token function">flushPassiveEffects</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    nextEffect <span class="token operator">=</span> nextEffect<span class="token punctuation">.</span>nextEffect<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <p>整体可以分为三部分：</p>
    <ol>
      <li>
        <p>处理<code>DOM节点</code>渲染/删除后的 <code>autoFocus</code>、<code>blur</code> 逻辑。</p>
      </li>
      <li>
        <p>调用<code>getSnapshotBeforeUpdate</code>生命周期钩子。</p>
      </li>
      <li>
        <p>调度<code>useEffect</code>。</p>
      </li>
    </ol>
    <p>我们讲解下2、3两点。</p>
    <h2 id="调用getsnapshotbeforeupdate"><a href="#调用getsnapshotbeforeupdate" class="header-anchor">#</a>
      调用getSnapshotBeforeUpdate</h2>
    <p><code>commitBeforeMutationEffectOnFiber</code>是<code>commitBeforeMutationLifeCycles</code>的别名。</p>
    <p>在该方法内会调用<code>getSnapshotBeforeUpdate</code>。</p>
    <blockquote>
      <p>你可以在<a
          href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberCommitWork.old.js#L222"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>看到这段逻辑</p>
    </blockquote>
    <p>从<code>React</code>v16开始，<code>componentWillXXX</code>钩子前增加了<code>UNSAFE_</code>前缀。</p>
    <p>
      究其原因，是因为<code>Stack Reconciler</code>重构为<code>Fiber Reconciler</code>后，<code>render阶段</code>的任务可能中断/重新开始，对应的组件在<code>render阶段</code>的生命周期钩子（即<code>componentWillXXX</code>）可能触发多次。
    </p>
    <p>这种行为和<code>React</code>v15不一致，所以标记为<code>UNSAFE_</code>。</p>
    <blockquote>
      <p>更详细的解释参照<a href="https://juejin.im/post/6847902224287285255#comment" target="_blank"
          rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false"
              x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a></p>
    </blockquote>
    <p>为此，<code>React</code>提供了替代的生命周期钩子<code>getSnapshotBeforeUpdate</code>。</p>
    <p>
      我们可以看见，<code>getSnapshotBeforeUpdate</code>是在<code>commit阶段</code>内的<code>before mutation阶段</code>调用的，由于<code>commit阶段</code>是同步的，所以不会遇到多次调用的问题。
    </p>
    <h2 id="调度useeffect"><a href="#调度useeffect" class="header-anchor">#</a> 调度<code>useEffect</code></h2>
    <p>在这几行代码内，<code>scheduleCallback</code>方法由<code>Scheduler</code>模块提供，用于以某个优先级异步调度一个回调函数。</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token comment">// 调度useEffect</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>effectTag <span class="token operator">&amp;</span> Passive<span class="token punctuation">)</span> <span class="token operator">!==</span> NoEffect<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>rootDoesHavePassiveEffects<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    rootDoesHavePassiveEffects <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token function">scheduleCallback</span><span class="token punctuation">(</span>NormalSchedulerPriority<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token comment">// 触发useEffect</span>
      <span class="token function">flushPassiveEffects</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <p>在此处，被异步调度的回调函数就是触发<code>useEffect</code>的方法<code>flushPassiveEffects</code>。</p>
    <p>我们接下来讨论<code>useEffect</code>如何被异步调度，以及为什么要异步（而不是同步）调度。</p>
    <h3 id="如何异步调度"><a href="#如何异步调度" class="header-anchor">#</a> 如何异步调度</h3>
    <p>在<code>flushPassiveEffects</code>方法内部会从全局变量<code>rootWithPendingPassiveEffects</code>获取<code>effectList</code>。
    </p>
    <p>关于<code>flushPassiveEffects</code>的具体讲解参照<a href="/hooks/useeffect.html">useEffect与useLayoutEffect一节</a></p>
    <p>在<a
        href="/process/completeWork.html#effectlist">completeWork一节</a>我们讲到，<code>effectList</code>中保存了需要执行副作用的<code>Fiber节点</code>。其中副作用包括
    </p>
    <ul>
      <li>插入<code>DOM节点</code>（Placement）</li>
      <li>更新<code>DOM节点</code>（Update）</li>
      <li>删除<code>DOM节点</code>（Deletion）</li>
    </ul>
    <p>
      除此外，当一个<code>FunctionComponent</code>含有<code>useEffect</code>或<code>useLayoutEffect</code>，他对应的<code>Fiber节点</code>也会被赋值<code>effectTag</code>。
    </p>
    <blockquote>
      <p>你可以从<a
          href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactHookEffectTags.js"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new
              window)</span></span></a>看到<code>hook</code>相关的<code>effectTag</code></p>
    </blockquote>
    <p>
      在<code>flushPassiveEffects</code>方法内部会遍历<code>rootWithPendingPassiveEffects</code>（即<code>effectList</code>）执行<code>effect</code>回调函数。
    </p>
    <p>如果在此时直接执行，<code>rootWithPendingPassiveEffects === null</code>。</p>
    <p>那么<code>rootWithPendingPassiveEffects</code>会在何时赋值呢？</p>
    <p>
      在上一节<code>layout之后</code>的代码片段中会根据<code>rootDoesHavePassiveEffects === true?</code>决定是否赋值<code>rootWithPendingPassiveEffects</code>。
    </p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">const</span> rootDidHavePassiveEffects <span class="token operator">=</span> rootDoesHavePassiveEffects<span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>rootDoesHavePassiveEffects<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  rootDoesHavePassiveEffects <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  rootWithPendingPassiveEffects <span class="token operator">=</span> root<span class="token punctuation">;</span>
  pendingPassiveEffectsLanes <span class="token operator">=</span> lanes<span class="token punctuation">;</span>
  pendingPassiveEffectsRenderPriority <span class="token operator">=</span> renderPriorityLevel<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <p>所以整个<code>useEffect</code>异步调用分为三步：</p>
    <ol>
      <li><code>before mutation阶段</code>在<code>scheduleCallback</code>中调度<code>flushPassiveEffects</code></li>
      <li><code>layout阶段</code>之后将<code>effectList</code>赋值给<code>rootWithPendingPassiveEffects</code></li>
      <li>
        <code>scheduleCallback</code>触发<code>flushPassiveEffects</code>，<code>flushPassiveEffects</code>内部遍历<code>rootWithPendingPassiveEffects</code>
      </li>
    </ol>
    <h3 id="为什么需要异步调用"><a href="#为什么需要异步调用" class="header-anchor">#</a> 为什么需要异步调用</h3>
    <p>摘录自<code>React</code>文档<a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#timing-of-effects"
        target="_blank" rel="noopener noreferrer">effect 的执行时机<span><svg xmlns="http://www.w3.org/2000/svg"
            aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"
            class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a>：</p>
    <blockquote>
      <p>与 componentDidMount、componentDidUpdate 不同的是，在浏览器完成布局与绘制之后，传给 useEffect
        的函数会延迟调用。这使得它适用于许多常见的副作用场景，比如设置订阅和事件处理等情况，因此不应在函数中执行阻塞浏览器更新屏幕的操作。</p>
    </blockquote>
    <p>可见，<code>useEffect</code>异步执行的原因主要是防止同步执行时阻塞浏览器渲染。</p>
    <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2>
    <p>经过本节学习，我们知道了在<code>before mutation阶段</code>，会遍历<code>effectList</code>，依次执行：</p>
    <ol>
      <li>
        <p>处理<code>DOM节点</code>渲染/删除后的 <code>autoFocus</code>、<code>blur</code>逻辑</p>
      </li>
      <li>
        <p>调用<code>getSnapshotBeforeUpdate</code>生命周期钩子</p>
      </li>
      <li>
        <p>调度<code>useEffect</code></p>
      </li>
    </ol>
  </div>
  <div class="theme-default-content content__default">
    <p>终于到了执行<code>DOM</code>操作的<code>mutation阶段</code>。</p>
    <h2 id="概览"><a href="#概览" class="header-anchor">#</a> 概览</h2>
    <p>
      类似<code>before mutation阶段</code>，<code>mutation阶段</code>也是遍历<code>effectList</code>，执行函数。这里执行的是<code>commitMutationEffects</code>。
    </p>
    <div class="language-js extra-class">
      <pre class="language-js"><code>nextEffect <span class="token operator">=</span> firstEffect<span class="token punctuation">;</span>
<span class="token keyword">do</span> <span class="token punctuation">{</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
      <span class="token function">commitMutationEffects</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> renderPriorityLevel<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">invariant</span><span class="token punctuation">(</span>nextEffect <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">'Should be working on an effect.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">captureCommitPhaseError</span><span class="token punctuation">(</span>nextEffect<span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span>
      nextEffect <span class="token operator">=</span> nextEffect<span class="token punctuation">.</span>nextEffect<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>nextEffect <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    </div>
    <h2 id="commitmutationeffects"><a href="#commitmutationeffects" class="header-anchor">#</a> commitMutationEffects
    </h2>
    <p>代码如下：</p>
    <blockquote>
      <p>你可以在<a
          href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.old.js#L2091"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>看到<code>commitMutationEffects</code>源码</p>
    </blockquote>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">commitMutationEffects</span><span class="token punctuation">(</span><span class="token parameter">root<span class="token operator">:</span> FiberRoot<span class="token punctuation">,</span> renderPriorityLevel</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 遍历effectList</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>nextEffect <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">const</span> effectTag <span class="token operator">=</span> nextEffect<span class="token punctuation">.</span>effectTag<span class="token punctuation">;</span>

    <span class="token comment">// 根据 ContentReset effectTag重置文字节点</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>effectTag <span class="token operator">&amp;</span> ContentReset<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">commitResetTextContent</span><span class="token punctuation">(</span>nextEffect<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 更新ref</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>effectTag <span class="token operator">&amp;</span> Ref<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> current <span class="token operator">=</span> nextEffect<span class="token punctuation">.</span>alternate<span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">commitDetachRef</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 根据 effectTag 分别处理</span>
    <span class="token keyword">const</span> primaryEffectTag <span class="token operator">=</span>
      effectTag <span class="token operator">&amp;</span> <span class="token punctuation">(</span>Placement <span class="token operator">|</span> Update <span class="token operator">|</span> Deletion <span class="token operator">|</span> Hydrating<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>primaryEffectTag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 插入DOM</span>
      <span class="token keyword">case</span> Placement<span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token function">commitPlacement</span><span class="token punctuation">(</span>nextEffect<span class="token punctuation">)</span><span class="token punctuation">;</span>
        nextEffect<span class="token punctuation">.</span>effectTag <span class="token operator">&amp;=</span> <span class="token operator">~</span>Placement<span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 插入DOM 并 更新DOM</span>
      <span class="token keyword">case</span> PlacementAndUpdate<span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token comment">// 插入</span>
        <span class="token function">commitPlacement</span><span class="token punctuation">(</span>nextEffect<span class="token punctuation">)</span><span class="token punctuation">;</span>

        nextEffect<span class="token punctuation">.</span>effectTag <span class="token operator">&amp;=</span> <span class="token operator">~</span>Placement<span class="token punctuation">;</span>

        <span class="token comment">// 更新</span>
        <span class="token keyword">const</span> current <span class="token operator">=</span> nextEffect<span class="token punctuation">.</span>alternate<span class="token punctuation">;</span>
        <span class="token function">commitWork</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> nextEffect<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// SSR</span>
      <span class="token keyword">case</span> Hydrating<span class="token operator">:</span> <span class="token punctuation">{</span>
        nextEffect<span class="token punctuation">.</span>effectTag <span class="token operator">&amp;=</span> <span class="token operator">~</span>Hydrating<span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// SSR</span>
      <span class="token keyword">case</span> HydratingAndUpdate<span class="token operator">:</span> <span class="token punctuation">{</span>
        nextEffect<span class="token punctuation">.</span>effectTag <span class="token operator">&amp;=</span> <span class="token operator">~</span>Hydrating<span class="token punctuation">;</span>

        <span class="token keyword">const</span> current <span class="token operator">=</span> nextEffect<span class="token punctuation">.</span>alternate<span class="token punctuation">;</span>
        <span class="token function">commitWork</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> nextEffect<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 更新DOM</span>
      <span class="token keyword">case</span> Update<span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> current <span class="token operator">=</span> nextEffect<span class="token punctuation">.</span>alternate<span class="token punctuation">;</span>
        <span class="token function">commitWork</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> nextEffect<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 删除DOM</span>
      <span class="token keyword">case</span> Deletion<span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token function">commitDeletion</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> nextEffect<span class="token punctuation">,</span> renderPriorityLevel<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    nextEffect <span class="token operator">=</span> nextEffect<span class="token punctuation">.</span>nextEffect<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <p><code>commitMutationEffects</code>会遍历<code>effectList</code>，对每个<code>Fiber节点</code>执行如下三个操作：</p>
    <ol>
      <li>根据<code>ContentReset effectTag</code>重置文字节点</li>
      <li>更新<code>ref</code></li>
      <li>根据<code>effectTag</code>分别处理，其中<code>effectTag</code>包括(<code>Placement</code> | <code>Update</code> |
        <code>Deletion</code> | <code>Hydrating</code>)</li>
    </ol>
    <p>我们关注步骤三中的<code>Placement</code> | <code>Update</code> |
      <code>Deletion</code>。<code>Hydrating</code>作为服务端渲染相关，我们先不关注。</p>
    <h2 id="placement-effect"><a href="#placement-effect" class="header-anchor">#</a> Placement effect</h2>
    <p>当<code>Fiber节点</code>含有<code>Placement effectTag</code>，意味着该<code>Fiber节点</code>对应的<code>DOM节点</code>需要插入到页面中。
    </p>
    <p>调用的方法为<code>commitPlacement</code>。</p>
    <blockquote>
      <p>你可以在<a
          href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCommitWork.new.js#L1156"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>看到<code>commitPlacement</code>源码</p>
    </blockquote>
    <p>该方法所做的工作分为三步：</p>
    <ol>
      <li>获取父级<code>DOM节点</code>。其中<code>finishedWork</code>为传入的<code>Fiber节点</code>。</li>
    </ol>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">const</span> parentFiber <span class="token operator">=</span> <span class="token function">getHostParentFiber</span><span class="token punctuation">(</span>finishedWork<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 父级DOM节点</span>
<span class="token keyword">const</span> parentStateNode <span class="token operator">=</span> parentFiber<span class="token punctuation">.</span>stateNode<span class="token punctuation">;</span>
</code></pre>
    </div>
    <ol start="2">
      <li>获取<code>Fiber节点</code>的<code>DOM</code>兄弟节点</li>
    </ol>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">const</span> before <span class="token operator">=</span> <span class="token function">getHostSibling</span><span class="token punctuation">(</span>finishedWork<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    </div>
    <ol start="3">
      <li>
        根据<code>DOM</code>兄弟节点是否存在决定调用<code>parentNode.insertBefore</code>或<code>parentNode.appendChild</code>执行<code>DOM</code>插入操作。
      </li>
    </ol>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token comment">// parentStateNode是否是rootFiber</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>isContainer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">insertOrAppendPlacementNodeIntoContainer</span><span class="token punctuation">(</span>finishedWork<span class="token punctuation">,</span> before<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token function">insertOrAppendPlacementNode</span><span class="token punctuation">(</span>finishedWork<span class="token punctuation">,</span> before<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <p>
      值得注意的是，<code>getHostSibling</code>（获取兄弟<code>DOM节点</code>）的执行很耗时，当在同一个父<code>Fiber节点</code>下依次执行多个插入操作，<code>getHostSibling</code>算法的复杂度为指数级。
    </p>
    <p>
      这是由于<code>Fiber节点</code>不只包括<code>HostComponent</code>，所以<code>Fiber树</code>和渲染的<code>DOM树</code>节点并不是一一对应的。要从<code>Fiber节点</code>找到<code>DOM节点</code>很可能跨层级遍历。
    </p>
    <p>考虑如下例子：</p>
    <div class="language-jsx extra-class">
      <pre class="language-jsx"><code>
<span class="token keyword">function</span> <span class="token function">Item</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">;
}

function App() </span><span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Item</span></span><span class="token punctuation">/&gt;</span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token plain-text">

ReactDOM.render(</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">App</span></span><span class="token punctuation">/&gt;</span></span><span class="token plain-text">, document.getElementById('root'));
</span></code></pre>
    </div>
    <p>对应的<code>Fiber树</code>和<code>DOM树</code>结构为：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token comment">// Fiber树</span>
          child      child      child       child
rootFiber <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">&gt;</span> App <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">&gt;</span> div <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">&gt;</span> Item <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">&gt;</span> li

<span class="token comment">// DOM树</span>
#root <span class="token operator">--</span><span class="token operator">-</span><span class="token operator">&gt;</span> div <span class="token operator">--</span><span class="token operator">-</span><span class="token operator">&gt;</span> li
</code></pre>
    </div>
    <p>当在<code>div</code>的子节点<code>Item</code>前插入一个新节点<code>p</code>，即<code>App</code>变为：</p>
    <div class="language-jsx extra-class">
      <pre class="language-jsx"><code><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Item</span></span><span class="token punctuation">/&gt;</span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <p>对应的<code>Fiber树</code>和<code>DOM树</code>结构为：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token comment">// Fiber树</span>
          child      child      child
rootFiber <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">&gt;</span> App <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">&gt;</span> div <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">&gt;</span> p 
                                       <span class="token operator">|</span> sibling       child
                                       <span class="token operator">|</span> <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">&gt;</span> Item <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">&gt;</span> li 
<span class="token comment">// DOM树</span>
#root <span class="token operator">--</span><span class="token operator">-</span><span class="token operator">&gt;</span> div <span class="token operator">--</span><span class="token operator">-</span><span class="token operator">&gt;</span> p
             <span class="token operator">|</span>
               <span class="token operator">--</span><span class="token operator">-</span><span class="token operator">&gt;</span> li
</code></pre>
    </div>
    <p>此时<code>DOM节点</code> <code>p</code>的兄弟节点为<code>li</code>，而<code>Fiber节点</code>
      <code>p</code>对应的兄弟<code>DOM节点</code>为：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code>fiberP<span class="token punctuation">.</span>sibling<span class="token punctuation">.</span>child
</code></pre>
    </div>
    <p>即<code>fiber p</code>的<code>兄弟fiber</code> <code>Item</code>的<code>子fiber</code> <code>li</code></p>
    <h2 id="update-effect"><a href="#update-effect" class="header-anchor">#</a> Update effect</h2>
    <p>
      当<code>Fiber节点</code>含有<code>Update effectTag</code>，意味着该<code>Fiber节点</code>需要更新。调用的方法为<code>commitWork</code>，他会根据<code>Fiber.tag</code>分别处理。
    </p>
    <blockquote>
      <p>你可以在<a
          href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCommitWork.new.js#L1441"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>看到<code>commitWork</code>源码</p>
    </blockquote>
    <p>这里我们主要关注<code>FunctionComponent</code>和<code>HostComponent</code>。</p>
    <h3 id="functioncomponent-mutation"><a href="#functioncomponent-mutation" class="header-anchor">#</a>
      FunctionComponent mutation</h3>
    <p>
      当<code>fiber.tag</code>为<code>FunctionComponent</code>，会调用<code>commitHookEffectListUnmount</code>。该方法会遍历<code>effectList</code>，执行所有<code>useLayoutEffect hook</code>的销毁函数。
    </p>
    <blockquote>
      <p>你可以在<a
          href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCommitWork.new.js#L314"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new
              window)</span></span></a>看到<code>commitHookEffectListUnmount</code>源码</p>
    </blockquote>
    <p>所谓“销毁函数”，见如下例子：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token function">useLayoutEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...一些副作用逻辑</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...这就是销毁函数</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre>
    </div>
    <p>
      你不需要很了解<code>useLayoutEffect</code>，我们会在下一节详细介绍。你只需要知道在<code>mutation阶段</code>会执行<code>useLayoutEffect</code>的销毁函数。
    </p>
    <h3 id="hostcomponent-mutation"><a href="#hostcomponent-mutation" class="header-anchor">#</a> HostComponent mutation
    </h3>
    <p>当<code>fiber.tag</code>为<code>HostComponent</code>，会调用<code>commitUpdate</code>。</p>
    <blockquote>
      <p>你可以在<a
          href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-dom/src/client/ReactDOMHostConfig.js#L423"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>看到<code>commitUpdate</code>源码</p>
    </blockquote>
    <p>最终会在<a
        href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-dom/src/client/ReactDOMComponent.js#L378"
        target="_blank" rel="noopener noreferrer"><code>updateDOMProperties</code><span><svg
            xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px"
            viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a>中将<a
        href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCompleteWork.new.js#L229"
        target="_blank" rel="noopener noreferrer"><code>render阶段 completeWork</code><span><svg
            xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px"
            viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new
            window)</span></span></a>中为<code>Fiber节点</code>赋值的<code>updateQueue</code>对应的内容渲染在页面上。</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> updatePayload<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> propKey <span class="token operator">=</span> updatePayload<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> propValue <span class="token operator">=</span> updatePayload<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

  <span class="token comment">// 处理 style</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>propKey <span class="token operator">===</span> <span class="token constant">STYLE</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setValueForStyles</span><span class="token punctuation">(</span>domElement<span class="token punctuation">,</span> propValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 处理 DANGEROUSLY_SET_INNER_HTML</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>propKey <span class="token operator">===</span> <span class="token constant">DANGEROUSLY_SET_INNER_HTML</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setInnerHTML</span><span class="token punctuation">(</span>domElement<span class="token punctuation">,</span> propValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 处理 children</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>propKey <span class="token operator">===</span> <span class="token constant">CHILDREN</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTextContent</span><span class="token punctuation">(</span>domElement<span class="token punctuation">,</span> propValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token comment">// 处理剩余 props</span>
    <span class="token function">setValueForProperty</span><span class="token punctuation">(</span>domElement<span class="token punctuation">,</span> propKey<span class="token punctuation">,</span> propValue<span class="token punctuation">,</span> isCustomComponentTag<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <h2 id="deletion-effect"><a href="#deletion-effect" class="header-anchor">#</a> Deletion effect</h2>
    <p>
      当<code>Fiber节点</code>含有<code>Deletion effectTag</code>，意味着该<code>Fiber节点</code>对应的<code>DOM节点</code>需要从页面中删除。调用的方法为<code>commitDeletion</code>。
    </p>
    <blockquote>
      <p>你可以在<a
          href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCommitWork.new.js#L1421"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>看到<code>commitDeletion</code>源码</p>
    </blockquote>
    <p>该方法会执行如下操作：</p>
    <ol>
      <li>递归调用<code>Fiber节点</code>及其子孙<code>Fiber节点</code>中<code>fiber.tag</code>为<code>ClassComponent</code>的<a
          href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCommitWork.new.js#L920"
          target="_blank" rel="noopener noreferrer"><code>componentWillUnmount</code><span><svg
              xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px"
              viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new
              window)</span></span></a>生命周期钩子，从页面移除<code>Fiber节点</code>对应<code>DOM节点</code></li>
      <li>解绑<code>ref</code></li>
      <li>调度<code>useEffect</code>的销毁函数</li>
    </ol>
    <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2>
    <p>
      从这节我们学到，<code>mutation阶段</code>会遍历<code>effectList</code>，依次执行<code>commitMutationEffects</code>。该方法的主要工作为“根据<code>effectTag</code>调用不同的处理函数处理<code>Fiber</code>。
    </p>
  </div>
  <div class="theme-default-content content__default">
    <p>该阶段之所以称为<code>layout</code>，因为该阶段的代码都是在<code>DOM</code>渲染完成（<code>mutation阶段</code>完成）后执行的。</p>
    <p>该阶段触发的生命周期钩子和<code>hook</code>可以直接访问到已经改变后的<code>DOM</code>，即该阶段是可以参与<code>DOM layout</code>的阶段。</p>
    <h2 id="概览"><a href="#概览" class="header-anchor">#</a> 概览</h2>
    <p>与前两个阶段类似，<code>layout阶段</code>也是遍历<code>effectList</code>，执行函数。</p>
    <p>具体执行的函数是<code>commitLayoutEffects</code>。</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code>root<span class="token punctuation">.</span>current <span class="token operator">=</span> finishedWork<span class="token punctuation">;</span>

nextEffect <span class="token operator">=</span> firstEffect<span class="token punctuation">;</span>
<span class="token keyword">do</span> <span class="token punctuation">{</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token function">commitLayoutEffects</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> lanes<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">invariant</span><span class="token punctuation">(</span>nextEffect <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">"Should be working on an effect."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">captureCommitPhaseError</span><span class="token punctuation">(</span>nextEffect<span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span>
    nextEffect <span class="token operator">=</span> nextEffect<span class="token punctuation">.</span>nextEffect<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>nextEffect <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

nextEffect <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre>
    </div>
    <h2 id="commitlayouteffects"><a href="#commitlayouteffects" class="header-anchor">#</a> commitLayoutEffects</h2>
    <p>代码如下：</p>
    <blockquote>
      <p>你可以在<a
          href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L2302"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>看到<code>commitLayoutEffects</code>源码</p>
    </blockquote>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">commitLayoutEffects</span><span class="token punctuation">(</span><span class="token parameter">root<span class="token operator">:</span> FiberRoot<span class="token punctuation">,</span> committedLanes<span class="token operator">:</span> Lanes</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>nextEffect <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> effectTag <span class="token operator">=</span> nextEffect<span class="token punctuation">.</span>effectTag<span class="token punctuation">;</span>

    <span class="token comment">// 调用生命周期钩子和hook</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>effectTag <span class="token operator">&amp;</span> <span class="token punctuation">(</span>Update <span class="token operator">|</span> Callback<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> current <span class="token operator">=</span> nextEffect<span class="token punctuation">.</span>alternate<span class="token punctuation">;</span>
      <span class="token function">commitLayoutEffectOnFiber</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> current<span class="token punctuation">,</span> nextEffect<span class="token punctuation">,</span> committedLanes<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 赋值ref</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>effectTag <span class="token operator">&amp;</span> Ref<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">commitAttachRef</span><span class="token punctuation">(</span>nextEffect<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    nextEffect <span class="token operator">=</span> nextEffect<span class="token punctuation">.</span>nextEffect<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <p><code>commitLayoutEffects</code>一共做了两件事：</p>
    <ol>
      <li>
        <p>commitLayoutEffectOnFiber（调用<code>生命周期钩子</code>和<code>hook</code>相关操作）</p>
      </li>
      <li>
        <p>commitAttachRef（赋值 ref）</p>
      </li>
    </ol>
    <h2 id="commitlayouteffectonfiber"><a href="#commitlayouteffectonfiber" class="header-anchor">#</a>
      commitLayoutEffectOnFiber</h2>
    <p><code>commitLayoutEffectOnFiber</code>方法会根据<code>fiber.tag</code>对不同类型的节点分别处理。</p>
    <blockquote>
      <p>你可以在<a
          href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCommitWork.new.js#L459"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new
              window)</span></span></a>看到<code>commitLayoutEffectOnFiber</code>源码（<code>commitLayoutEffectOnFiber</code>为别名，方法原名为<code>commitLifeCycles</code>）
      </p>
    </blockquote>
    <ul>
      <li>
        对于<code>ClassComponent</code>，他会通过<code>current === null?</code>区分是<code>mount</code>还是<code>update</code>，调用<a
          href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCommitWork.new.js#L538"
          target="_blank" rel="noopener noreferrer"><code>componentDidMount</code><span><svg
              xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px"
              viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>或<a
          href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCommitWork.new.js#L592"
          target="_blank" rel="noopener noreferrer"><code>componentDidUpdate</code><span><svg
              xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px"
              viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>。</li>
    </ul>
    <p>触发<code>状态更新</code>的<code>this.setState</code>如果赋值了第二个参数<code>回调函数</code>，也会在此时调用。</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> xxx<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"i am update~"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    </div>
    <ul>
      <li>
        对于<code>FunctionComponent</code>及相关类型，他会调用<code>useLayoutEffect hook</code>的<code>回调函数</code>，调度<code>useEffect</code>的<code>销毁</code>与<code>回调</code>函数
      </li>
    </ul>
    <blockquote>
      <p>
        <code>相关类型</code>指特殊处理后的<code>FunctionComponent</code>，比如<code>ForwardRef</code>、<code>React.memo</code>包裹的<code>FunctionComponent</code>
      </p>
    </blockquote>
    <div class="language-js extra-class">
      <pre class="language-js"><code>  <span class="token keyword">switch</span> <span class="token punctuation">(</span>finishedWork<span class="token punctuation">.</span>tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 以下都是FunctionComponent及相关类型</span>
    <span class="token keyword">case</span> FunctionComponent<span class="token operator">:</span>
    <span class="token keyword">case</span> ForwardRef<span class="token operator">:</span>
    <span class="token keyword">case</span> SimpleMemoComponent<span class="token operator">:</span>
    <span class="token keyword">case</span> Block<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token comment">// 执行useLayoutEffect的回调函数</span>
      <span class="token function">commitHookEffectListMount</span><span class="token punctuation">(</span>HookLayout <span class="token operator">|</span> HookHasEffect<span class="token punctuation">,</span> finishedWork<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 调度useEffect的销毁函数与回调函数</span>
      <span class="token function">schedulePassiveEffects</span><span class="token punctuation">(</span>finishedWork<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre>
    </div>
    <blockquote>
      <p>你可以从<a
          href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberCommitWork.old.js#L465-L491"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>看到这段代码</p>
    </blockquote>
    <p>在上一节介绍<a href="/renderer/mutation.html#update-effect">Update
        effect</a>时介绍过，<code>mutation阶段</code>会执行<code>useLayoutEffect hook</code>的<code>销毁函数</code>。</p>
    <p>结合这里我们可以发现，<code>useLayoutEffect hook</code>从上一次更新的<code>销毁函数</code>调用到本次更新的<code>回调函数</code>调用是同步执行的。</p>
    <p>而<code>useEffect</code>则需要先调度，在<code>Layout阶段</code>完成后再异步执行。</p>
    <p>这就是<code>useLayoutEffect</code>与<code>useEffect</code>的区别。</p>
    <ul>
      <li>对于<code>HostRoot</code>，即<code>rootFiber</code>，如果赋值了第三个参数<code>回调函数</code>，也会在此时调用。</li>
    </ul>
    <div class="language-js extra-class">
      <pre class="language-js"><code>ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>App <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">"#root"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"i am mount~"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    </div>
    <h2 id="commitattachref"><a href="#commitattachref" class="header-anchor">#</a> commitAttachRef</h2>
    <p><code>commitLayoutEffects</code>会做的第二件事是<code>commitAttachRef</code>。</p>
    <blockquote>
      <p>你可以在<a
          href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCommitWork.new.js#L823"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>看到<code>commitAttachRef</code>源码</p>
    </blockquote>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">commitAttachRef</span><span class="token punctuation">(</span><span class="token parameter">finishedWork<span class="token operator">:</span> Fiber</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> ref <span class="token operator">=</span> finishedWork<span class="token punctuation">.</span>ref<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>ref <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> instance <span class="token operator">=</span> finishedWork<span class="token punctuation">.</span>stateNode<span class="token punctuation">;</span>

    <span class="token comment">// 获取DOM实例</span>
    <span class="token keyword">let</span> instanceToUse<span class="token punctuation">;</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>finishedWork<span class="token punctuation">.</span>tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">case</span> HostComponent<span class="token operator">:</span>
        instanceToUse <span class="token operator">=</span> <span class="token function">getPublicInstance</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token keyword">default</span><span class="token operator">:</span>
        instanceToUse <span class="token operator">=</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> ref <span class="token operator">===</span> <span class="token string">"function"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 如果ref是函数形式，调用回调函数</span>
      <span class="token function">ref</span><span class="token punctuation">(</span>instanceToUse<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 如果ref是ref实例形式，赋值ref.current</span>
      ref<span class="token punctuation">.</span>current <span class="token operator">=</span> instanceToUse<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <p>代码逻辑很简单：获取<code>DOM</code>实例，更新<code>ref</code>。</p>
    <h2 id="current-fiber树切换"><a href="#current-fiber树切换" class="header-anchor">#</a> current Fiber树切换</h2>
    <p>至此，整个<code>layout阶段</code>就结束了。</p>
    <p>在结束本节的学习前，我们关注下这行代码：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code>root<span class="token punctuation">.</span>current <span class="token operator">=</span> finishedWork<span class="token punctuation">;</span>
</code></pre>
    </div>
    <blockquote>
      <p>你可以在<a
          href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L2022"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>看到这行代码</p>
    </blockquote>
    <p>在<a
        href="/process/doubleBuffer.html#什么是-双缓存">双缓存机制一节</a>我们介绍过，<code>workInProgress Fiber树</code>在<code>commit阶段</code>完成渲染后会变为<code>current Fiber树</code>。这行代码的作用就是切换<code>fiberRootNode</code>指向的<code>current Fiber树</code>。
    </p>
    <p>那么这行代码为什么在这里呢？（在<code>mutation阶段</code>结束后，<code>layout阶段</code>开始前。）</p>
    <p>
      我们知道<code>componentWillUnmount</code>会在<code>mutation阶段</code>执行。此时<code>current Fiber树</code>还指向前一次更新的<code>Fiber树</code>，在生命周期钩子内获取的<code>DOM</code>还是更新前的。
    </p>
    <p>
      <code>componentDidMount</code>和<code>componentDidUpdate</code>会在<code>layout阶段</code>执行。此时<code>current Fiber树</code>已经指向更新后的<code>Fiber树</code>，在生命周期钩子内获取的<code>DOM</code>就是更新后的。
    </p>
    <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2>
    <p>
      从这节我们学到，<code>layout阶段</code>会遍历<code>effectList</code>，依次执行<code>commitLayoutEffects</code>。该方法的主要工作为“根据<code>effectTag</code>调用不同的处理函数处理<code>Fiber</code>并更新<code>ref</code>。
    </p>
  </div>
  <div class="theme-default-content content__default">
    <div class="custom-block warning">
      <p class="custom-block-title">本章为选读章节</p>
      <p>是否学习该章对后续章节的学习没有影响。</p>
    </div>
    <p>在<a href="/process/beginWork.html#reconcilechildren">beginWork一节</a>我们提到</p>
    <blockquote>
      <p>对于<code>update</code>的组件，他会将当前组件与该组件在上次更新时对应的Fiber节点比较（也就是俗称的Diff算法），将比较的结果生成新Fiber节点。</p>
    </blockquote>
    <p>这一章我们讲解<code>Diff算法</code>的实现。</p>
    <blockquote>
      <p>你可以从<a href="https://zh-hans.reactjs.org/docs/reconciliation.html#the-diffing-algorithm" target="_blank"
          rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false"
              x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>看到<code>Diff算法</code>的介绍。</p>
    </blockquote>
    <div class="custom-block warning">
      <p class="custom-block-title">为了防止概念混淆，这里再强调下</p>
      <p>一个<code>DOM节点</code>在某一时刻最多会有4个节点和他相关。</p>
      <ol>
        <li>
          <p>
            <code>current Fiber</code>。如果该<code>DOM节点</code>已在页面中，<code>current Fiber</code>代表该<code>DOM节点</code>对应的<code>Fiber节点</code>。
          </p>
        </li>
        <li>
          <p>
            <code>workInProgress Fiber</code>。如果该<code>DOM节点</code>将在本次更新中渲染到页面中，<code>workInProgress Fiber</code>代表该<code>DOM节点</code>对应的<code>Fiber节点</code>。
          </p>
        </li>
        <li>
          <p><code>DOM节点</code>本身。</p>
        </li>
        <li>
          <p>
            <code>JSX对象</code>。即<code>ClassComponent</code>的<code>render</code>方法的返回结果，或<code>FunctionComponent</code>的调用结果。<code>JSX对象</code>中包含描述<code>DOM节点</code>的信息。
          </p>
        </li>
      </ol>
      <p><code>Diff算法</code>的本质是对比1和4，生成2。</p>
    </div>
    <h2 id="diff的瓶颈以及react如何应对"><a href="#diff的瓶颈以及react如何应对" class="header-anchor">#</a> Diff的瓶颈以及React如何应对</h2>
    <p>由于<code>Diff</code>操作本身也会带来性能损耗，React文档中提到，即使在最前沿的算法中，将前后两棵树完全比对的算法的复杂程度为 O(n 3 )，其中<code>n</code>是树中元素的数量。</p>
    <p>如果在<code>React</code>中使用了该算法，那么展示1000个元素所需要执行的计算量将在十亿的量级范围。这个开销实在是太过高昂。</p>
    <p>为了降低算法复杂度，<code>React</code>的<code>diff</code>会预设三个限制：</p>
    <ol>
      <li>
        <p>只对同级元素进行<code>Diff</code>。如果一个<code>DOM节点</code>在前后两次更新中跨越了层级，那么<code>React</code>不会尝试复用他。</p>
      </li>
      <li>
        <p>
          两个不同类型的元素会产生出不同的树。如果元素由<code>div</code>变为<code>p</code>，React会销毁<code>div</code>及其子孙节点，并新建<code>p</code>及其子孙节点。
        </p>
      </li>
      <li>
        <p>开发者可以通过 <code>key prop</code>来暗示哪些子元素在不同的渲染下能保持稳定。考虑如下例子：</p>
      </li>
    </ol>
    <div class="language-jsx extra-class">
      <pre class="language-jsx"><code><span class="token comment">// 更新前</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ka<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">ka</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>song<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">song</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>

<span class="token comment">// 更新后</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>song<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">song</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ka<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">ka</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>

</code></pre>
    </div>
    <p>
      如果没有<code>key</code>，<code>React</code>会认为<code>div</code>的第一个子节点由<code>p</code>变为<code>h3</code>，第二个子节点由<code>h3</code>变为<code>p</code>。这符合限制2的设定，会销毁并新建。
    </p>
    <p>
      但是当我们用<code>key</code>指明了节点前后对应关系后，<code>React</code>知道<code>key === "ka"</code>的<code>p</code>在更新后还存在，所以<code>DOM节点</code>可以复用，只是需要交换下顺序。
    </p>
    <p>这就是<code>React</code>为了应对算法性能瓶颈做出的三条限制。</p>
    <h2 id="diff是如何实现的"><a href="#diff是如何实现的" class="header-anchor">#</a> Diff是如何实现的</h2>
    <p>
      我们从<code>Diff</code>的入口函数<code>reconcileChildFibers</code>出发，该函数会根据<code>newChild</code>（即<code>JSX对象</code>）类型调用不同的处理函数。
    </p>
    <blockquote>
      <p>你可以从<a
          href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactChildFiber.new.js#L1280"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>看到<code>reconcileChildFibers</code>的源码。</p>
    </blockquote>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token comment">// 根据newChild类型选择不同diff函数处理</span>
<span class="token keyword">function</span> <span class="token function">reconcileChildFibers</span><span class="token punctuation">(</span>
  <span class="token parameter">returnFiber<span class="token operator">:</span> Fiber<span class="token punctuation">,</span>
  currentFirstChild<span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  newChild<span class="token operator">:</span> any<span class="token punctuation">,</span></span>
<span class="token punctuation">)</span><span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token punctuation">{</span>

  <span class="token keyword">const</span> isObject <span class="token operator">=</span> <span class="token keyword">typeof</span> newChild <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">&amp;&amp;</span> newChild <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>isObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// object类型，可能是 REACT_ELEMENT_TYPE 或 REACT_PORTAL_TYPE</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>newChild<span class="token punctuation">.</span>$$<span class="token keyword">typeof</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">case</span> <span class="token constant">REACT_ELEMENT_TYPE</span><span class="token operator">:</span>
        <span class="token comment">// 调用 reconcileSingleElement 处理</span>
      <span class="token comment">// // ...省略其他case</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> newChild <span class="token operator">===</span> <span class="token string">'string'</span> <span class="token operator">||</span> <span class="token keyword">typeof</span> newChild <span class="token operator">===</span> <span class="token string">'number'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 调用 reconcileSingleTextNode 处理</span>
    <span class="token comment">// ...省略</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isArray</span><span class="token punctuation">(</span>newChild<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 调用 reconcileChildrenArray 处理</span>
    <span class="token comment">// ...省略</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 一些其他情况调用处理函数</span>
  <span class="token comment">// ...省略</span>

  <span class="token comment">// 以上都没有命中，删除节点</span>
  <span class="token keyword">return</span> <span class="token function">deleteRemainingChildren</span><span class="token punctuation">(</span>returnFiber<span class="token punctuation">,</span> currentFirstChild<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <p>我们可以从同级的节点数量将Diff分为两类：</p>
    <ol>
      <li>
        <p>当<code>newChild</code>类型为<code>object</code>、<code>number</code>、<code>string</code>，代表同级只有一个节点</p>
      </li>
      <li>
        <p>当<code>newChild</code>类型为<code>Array</code>，同级有多个节点</p>
      </li>
    </ol>
    <p>在接下来两节我们会分别讨论这两类节点的<code>Diff</code>。</p>
  </div>
  <div class="theme-default-content content__default">
    <p>对于单个节点，我们以类型<code>object</code>为例，会进入<code>reconcileSingleElement</code></p>
    <blockquote>
      <p>你可以从<a
          href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactChildFiber.new.js#L1141"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>看到<code>reconcileSingleElement</code>源码</p>
    </blockquote>
    <div class="language-javascript extra-class">
      <pre class="language-javascript"><code>  <span class="token keyword">const</span> isObject <span class="token operator">=</span> <span class="token keyword">typeof</span> newChild <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">&amp;&amp;</span> newChild <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>isObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 对象类型，可能是 REACT_ELEMENT_TYPE 或 REACT_PORTAL_TYPE</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>newChild<span class="token punctuation">.</span>$$<span class="token keyword">typeof</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">case</span> <span class="token constant">REACT_ELEMENT_TYPE</span><span class="token operator">:</span>
        <span class="token comment">// 调用 reconcileSingleElement 处理</span>
      <span class="token comment">// ...其他case</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre>
    </div>
    <p>这个函数会做如下事情：</p> <img src="https://react.iamkasong.com/img/diff.png" alt="diff">
    <p>让我们看看第二步<strong>判断DOM节点是否可以复用</strong>是如何实现的。</p>
    <div class="language-javascript extra-class">
      <pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">reconcileSingleElement</span><span class="token punctuation">(</span>
  <span class="token parameter">returnFiber<span class="token operator">:</span> Fiber<span class="token punctuation">,</span>
  currentFirstChild<span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  element<span class="token operator">:</span> ReactElement</span>
<span class="token punctuation">)</span><span class="token operator">:</span> Fiber <span class="token punctuation">{</span>
  <span class="token keyword">const</span> key <span class="token operator">=</span> element<span class="token punctuation">.</span>key<span class="token punctuation">;</span>
  <span class="token keyword">let</span> child <span class="token operator">=</span> currentFirstChild<span class="token punctuation">;</span>
  
  <span class="token comment">// 首先判断是否存在对应DOM节点</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>child <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 上一次更新存在DOM节点，接下来判断是否可复用</span>

    <span class="token comment">// 首先比较key是否相同</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>child<span class="token punctuation">.</span>key <span class="token operator">===</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>

      <span class="token comment">// key相同，接下来比较type是否相同</span>

      <span class="token keyword">switch</span> <span class="token punctuation">(</span>child<span class="token punctuation">.</span>tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// ...省略case</span>
        
        <span class="token keyword">default</span><span class="token operator">:</span> <span class="token punctuation">{</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>child<span class="token punctuation">.</span>elementType <span class="token operator">===</span> element<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// type相同则表示可以复用</span>
            <span class="token comment">// 返回复用的fiber</span>
            <span class="token keyword">return</span> existing<span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
          
          <span class="token comment">// type不同则跳出switch</span>
          <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 代码执行到这里代表：key相同但是type不同</span>
      <span class="token comment">// 将该fiber及其兄弟fiber标记为删除</span>
      <span class="token function">deleteRemainingChildren</span><span class="token punctuation">(</span>returnFiber<span class="token punctuation">,</span> child<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// key不同，将该fiber标记为删除</span>
      <span class="token function">deleteChild</span><span class="token punctuation">(</span>returnFiber<span class="token punctuation">,</span> child<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    child <span class="token operator">=</span> child<span class="token punctuation">.</span>sibling<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 创建新Fiber，并返回 ...省略</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <p>还记得我们刚才提到的，React预设的限制么，</p>
    <p>
      从代码可以看出，React通过先判断<code>key</code>是否相同，如果<code>key</code>相同则判断<code>type</code>是否相同，只有都相同时一个<code>DOM节点</code>才能复用。
    </p>
    <p>这里有个细节需要关注下：</p>
    <ul>
      <li>
        <p>
          当<code>child !== null</code>且<code>key相同</code>且<code>type不同</code>时执行<code>deleteRemainingChildren</code>将<code>child</code>及其兄弟<code>fiber</code>都标记删除。
        </p>
      </li>
      <li>
        <p>当<code>child !== null</code>且<code>key不同</code>时仅将<code>child</code>标记删除。</p>
      </li>
    </ul>
    <p>考虑如下例子：</p>
    <p>当前页面有3个<code>li</code>，我们要全部删除，再插入一个<code>p</code>。</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token comment">// 当前页面显示的</span>
ul <span class="token operator">&gt;</span> li <span class="token operator">*</span> <span class="token number">3</span>

<span class="token comment">// 这次需要更新的</span>
ul <span class="token operator">&gt;</span> p
</code></pre>
    </div>
    <p>由于本次更新时只有一个<code>p</code>，属于单一节点的<code>Diff</code>，会走上面介绍的代码逻辑。</p>
    <p>
      在<code>reconcileSingleElement</code>中遍历之前的3个<code>fiber</code>（对应的<code>DOM</code>为3个<code>li</code>），寻找本次更新的<code>p</code>是否可以复用之前的3个<code>fiber</code>中某个的<code>DOM</code>。
    </p>
    <p>
      当<code>key相同</code>且<code>type不同</code>时，代表我们已经找到本次更新的<code>p</code>对应的上次的<code>fiber</code>，但是<code>p</code>与<code>li</code>
      <code>type</code>不同，不能复用。既然唯一的可能性已经不能复用，则剩下的<code>fiber</code>都没有机会了，所以都需要标记删除。</p>
    <p>
      当<code>key不同</code>时只代表遍历到的该<code>fiber</code>不能被<code>p</code>复用，后面还有兄弟<code>fiber</code>还没有遍历到。所以仅仅标记该<code>fiber</code>删除。
    </p>
    <h2 id="练习题"><a href="#练习题" class="header-anchor">#</a> 练习题</h2>
    <p>让我们来做几道习题巩固下吧：</p>
    <p>请判断如下<code>JSX对象</code>对应的<code>DOM</code>元素是否可以复用：</p>
    <div class="language-jsx extra-class">
      <pre class="language-jsx"><code><span class="token comment">// 习题1 更新前</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">ka song</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token comment">// 更新后</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">ka song</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>

<span class="token comment">// 习题2 更新前</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>xxx<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">ka song</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token comment">// 更新后</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ooo<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">ka song</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>

<span class="token comment">// 习题3 更新前</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>xxx<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">ka song</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token comment">// 更新后</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ooo<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">ka song</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>

<span class="token comment">// 习题4 更新前</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>xxx<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">ka song</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token comment">// 更新后</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>xxx<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">xiao bei</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>

</code></pre>
    </div>
    <p>。</p>
    <p>。</p>
    <p>。</p>
    <p>。</p>
    <p>公布答案：</p>
    <p>习题1: 未设置<code>key prop</code>默认
      <code>key = null;</code>，所以更新前后key相同，都为<code>null</code>，但是更新前<code>type</code>为<code>div</code>，更新后为<code>p</code>，<code>type</code>改变则不能复用。
    </p>
    <p>习题2: 更新前后<code>key</code>改变，不需要再判断<code>type</code>，不能复用。</p>
    <p>习题3: 更新前后<code>key</code>改变，不需要再判断<code>type</code>，不能复用。</p>
    <p>习题4: 更新前后<code>key</code>与<code>type</code>都未改变，可以复用。<code>children</code>变化，<code>DOM</code>的子元素需要更新。</p>
    <p>你是不是都答对了呢。</p>
  </div>
  <div class="theme-default-content content__default">
    <p>上一节我们介绍了单一节点的<code>Diff</code>，现在考虑我们有一个<code>FunctionComponent</code>：</p>
    <div class="language-jsx extra-class">
      <pre class="language-jsx"><code><span class="token keyword">function</span> <span class="token function">List</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">0</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">1</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">2</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>3<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">3</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <p>他的返回值<code>JSX对象</code>的<code>children</code>属性不是单一节点，而是包含四个对象的数组</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token punctuation">{</span>
  $$<span class="token keyword">typeof</span><span class="token operator">:</span> <span class="token function">Symbol</span><span class="token punctuation">(</span>react<span class="token punctuation">.</span>element<span class="token punctuation">)</span><span class="token punctuation">,</span>
  key<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  props<span class="token operator">:</span> <span class="token punctuation">{</span>
    children<span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">{</span>$$<span class="token keyword">typeof</span><span class="token operator">:</span> <span class="token function">Symbol</span><span class="token punctuation">(</span>react<span class="token punctuation">.</span>element<span class="token punctuation">)</span><span class="token punctuation">,</span> type<span class="token operator">:</span> <span class="token string">"li"</span><span class="token punctuation">,</span> key<span class="token operator">:</span> <span class="token string">"0"</span><span class="token punctuation">,</span> ref<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span> props<span class="token operator">:</span> <span class="token punctuation">{</span>…<span class="token punctuation">}</span><span class="token punctuation">,</span> …<span class="token punctuation">}</span>
      <span class="token punctuation">{</span>$$<span class="token keyword">typeof</span><span class="token operator">:</span> <span class="token function">Symbol</span><span class="token punctuation">(</span>react<span class="token punctuation">.</span>element<span class="token punctuation">)</span><span class="token punctuation">,</span> type<span class="token operator">:</span> <span class="token string">"li"</span><span class="token punctuation">,</span> key<span class="token operator">:</span> <span class="token string">"1"</span><span class="token punctuation">,</span> ref<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span> props<span class="token operator">:</span> <span class="token punctuation">{</span>…<span class="token punctuation">}</span><span class="token punctuation">,</span> …<span class="token punctuation">}</span>
      <span class="token punctuation">{</span>$$<span class="token keyword">typeof</span><span class="token operator">:</span> <span class="token function">Symbol</span><span class="token punctuation">(</span>react<span class="token punctuation">.</span>element<span class="token punctuation">)</span><span class="token punctuation">,</span> type<span class="token operator">:</span> <span class="token string">"li"</span><span class="token punctuation">,</span> key<span class="token operator">:</span> <span class="token string">"2"</span><span class="token punctuation">,</span> ref<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span> props<span class="token operator">:</span> <span class="token punctuation">{</span>…<span class="token punctuation">}</span><span class="token punctuation">,</span> …<span class="token punctuation">}</span>
      <span class="token punctuation">{</span>$$<span class="token keyword">typeof</span><span class="token operator">:</span> <span class="token function">Symbol</span><span class="token punctuation">(</span>react<span class="token punctuation">.</span>element<span class="token punctuation">)</span><span class="token punctuation">,</span> type<span class="token operator">:</span> <span class="token string">"li"</span><span class="token punctuation">,</span> key<span class="token operator">:</span> <span class="token string">"3"</span><span class="token punctuation">,</span> ref<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span> props<span class="token operator">:</span> <span class="token punctuation">{</span>…<span class="token punctuation">}</span><span class="token punctuation">,</span> …<span class="token punctuation">}</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  ref<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  type<span class="token operator">:</span> <span class="token string">"ul"</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <p>
      这种情况下，<code>reconcileChildFibers</code>的<code>newChild</code>参数类型为<code>Array</code>，在<code>reconcileChildFibers</code>函数内部对应如下情况：
    </p>
    <blockquote>
      <p>你可以在<a
          href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactChildFiber.new.js#L1352"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>看到这段源码逻辑</p>
    </blockquote>
    <div class="language-js extra-class">
      <pre class="language-js"><code>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isArray</span><span class="token punctuation">(</span>newChild<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 调用 reconcileChildrenArray 处理</span>
    <span class="token comment">// ...省略</span>
  <span class="token punctuation">}</span>
</code></pre>
    </div>
    <p>这一节我们来看看，如何处理同级多个节点的<code>Diff</code>。</p>
    <h2 id="概览"><a href="#概览" class="header-anchor">#</a> 概览</h2>
    <p>首先归纳下我们需要处理的情况：</p>
    <p>我们以<strong>之前</strong>代表更新前的<code>JSX对象</code>，<strong>之后</strong>代表更新后的<code>JSX对象</code></p>
    <h3 id="情况1-节点更新"><a href="#情况1-节点更新" class="header-anchor">#</a> 情况1：节点更新</h3>
    <div class="language-jsx extra-class">
      <pre class="language-jsx"><code><span class="token comment">// 之前</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>before<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">0</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">1</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">

// 之后 情况1 —— 节点属性变化
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>after<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">0</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">1</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">

// 之后 情况2 —— 节点类型更新
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">0</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">1</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
</span></code></pre>
    </div>
    <h3 id="情况2-节点新增或减少"><a href="#情况2-节点新增或减少" class="header-anchor">#</a> 情况2：节点新增或减少</h3>
    <div class="language-jsx extra-class">
      <pre class="language-jsx"><code><span class="token comment">// 之前</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">0</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">1</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">

// 之后 情况1 —— 新增节点
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">0</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">1</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">2</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">

// 之后 情况2 —— 删除节点
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">1</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
</span></code></pre>
    </div>
    <h3 id="情况3-节点位置变化"><a href="#情况3-节点位置变化" class="header-anchor">#</a> 情况3：节点位置变化</h3>
    <div class="language-jsx extra-class">
      <pre class="language-jsx"><code><span class="token comment">// 之前</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">0</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">1</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">

// 之后
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">1</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">0</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
</span></code></pre>
    </div>
    <p>同级多个节点的<code>Diff</code>，一定属于以上三种情况中的一种或多种。</p>
    <h2 id="diff的思路"><a href="#diff的思路" class="header-anchor">#</a> Diff的思路</h2>
    <p>该如何设计算法呢？如果让我设计一个<code>Diff算法</code>，我首先想到的方案是：</p>
    <ol>
      <li>判断当前节点的更新属于哪种情况</li>
      <li>如果是<code>新增</code>，执行新增逻辑</li>
      <li>如果是<code>删除</code>，执行删除逻辑</li>
      <li>如果是<code>更新</code>，执行更新逻辑</li>
    </ol>
    <p>按这个方案，其实有个隐含的前提——<strong>不同操作的优先级是相同的</strong></p>
    <p>
      但是<code>React团队</code>发现，在日常开发中，相较于<code>新增</code>和<code>删除</code>，<code>更新</code>组件发生的频率更高。所以<code>Diff</code>会优先判断当前节点是否属于<code>更新</code>。
    </p>
    <div class="custom-block warning">
      <p class="custom-block-title">注意</p>
      <p>在我们做数组相关的算法题时，经常使用<strong>双指针</strong>从数组头和尾同时遍历以提高效率，但是这里却不行。</p>
      <p>虽然本次更新的<code>JSX对象</code>
        <code>newChildren</code>为数组形式，但是和<code>newChildren</code>中每个组件进行比较的是<code>current fiber</code>，同级的<code>Fiber节点</code>是由<code>sibling</code>指针链接形成的单链表，即不支持双指针遍历。
      </p>
      <p>即 <code>newChildren[0]</code>与<code>fiber</code>比较，<code>newChildren[1]</code>与<code>fiber.sibling</code>比较。
      </p>
      <p>所以无法使用<strong>双指针</strong>优化。</p>
    </div>
    <p>基于以上原因，<code>Diff算法</code>的整体逻辑会经历两轮遍历：</p>
    <p>第一轮遍历：处理<code>更新</code>的节点。</p>
    <p>第二轮遍历：处理剩下的不属于<code>更新</code>的节点。</p>
    <h2 id="第一轮遍历"><a href="#第一轮遍历" class="header-anchor">#</a> 第一轮遍历</h2>
    <p>第一轮遍历步骤如下：</p>
    <ol>
      <li>
        <p>
          <code>let i = 0</code>，遍历<code>newChildren</code>，将<code>newChildren[i]</code>与<code>oldFiber</code>比较，判断<code>DOM节点</code>是否可复用。
        </p>
      </li>
      <li>
        <p>如果可复用，<code>i++</code>，继续比较<code>newChildren[i]</code>与<code>oldFiber.sibling</code>，可以复用则继续遍历。</p>
      </li>
      <li>
        <p>如果不可复用，分两种情况：</p>
      </li>
    </ol>
    <ul>
      <li>
        <p><code>key</code>不同导致不可复用，立即跳出整个遍历，<strong>第一轮遍历结束。</strong></p>
      </li>
      <li>
        <p><code>key</code>相同<code>type</code>不同导致不可复用，会将<code>oldFiber</code>标记为<code>DELETION</code>，并继续遍历</p>
      </li>
    </ul>
    <ol start="4">
      <li>
        如果<code>newChildren</code>遍历完（即<code>i === newChildren.length - 1</code>）或者<code>oldFiber</code>遍历完（即<code>oldFiber.sibling === null</code>），跳出遍历，<strong>第一轮遍历结束。</strong>
      </li>
    </ol>
    <blockquote>
      <p>你可以从<a
          href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactChildFiber.new.js#L818"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>看到这轮遍历的源码</p>
    </blockquote>
    <p>当遍历结束后，会有两种结果：</p>
    <h3 id="步骤3跳出的遍历"><a href="#步骤3跳出的遍历" class="header-anchor">#</a> 步骤3跳出的遍历</h3>
    <p>此时<code>newChildren</code>没有遍历完，<code>oldFiber</code>也没有遍历完。</p>
    <p>举个例子，考虑如下代码：</p>
    <div class="language-jsx extra-class">
      <pre class="language-jsx"><code><span class="token comment">// 之前</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">0</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">1</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">2</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
            
<span class="token comment">// 之后</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">0</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">1</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">2</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
</code></pre>
    </div>
    <p>第一个节点可复用，遍历到<code>key === 2</code>的节点发现<code>key</code>改变，不可复用，跳出遍历，等待第二轮遍历处理。</p>
    <p>
      此时<code>oldFiber</code>剩下<code>key === 1</code>、<code>key === 2</code>未遍历，<code>newChildren</code>剩下<code>key === 2</code>、<code>key === 1</code>未遍历。
    </p>
    <h3 id="步骤4跳出的遍历"><a href="#步骤4跳出的遍历" class="header-anchor">#</a> 步骤4跳出的遍历</h3>
    <p>可能<code>newChildren</code>遍历完，或<code>oldFiber</code>遍历完，或他们同时遍历完。</p>
    <p>举个例子，考虑如下代码：</p>
    <div class="language-jsx extra-class">
      <pre class="language-jsx"><code><span class="token comment">// 之前</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>a<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">0</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>b<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">1</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
            
<span class="token comment">// 之后 情况1 —— newChildren与oldFiber都遍历完</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>aa<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">0</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bb<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">1</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
            
<span class="token comment">// 之后 情况2 —— newChildren没遍历完，oldFiber遍历完</span>
<span class="token comment">// newChildren剩下 key==="2" 未遍历</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>aa<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">0</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bb<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">1</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>cc<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">2</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
            
<span class="token comment">// 之后 情况3 —— newChildren遍历完，oldFiber没遍历完</span>
<span class="token comment">// oldFiber剩下 key==="1" 未遍历</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>aa<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">0</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
</code></pre>
    </div>
    <p>带着第一轮遍历的结果，我们开始第二轮遍历。</p>
    <h2 id="第二轮遍历"><a href="#第二轮遍历" class="header-anchor">#</a> 第二轮遍历</h2>
    <p>对于第一轮遍历的结果，我们分别讨论：</p>
    <h3 id="newchildren与oldfiber同时遍历完"><a href="#newchildren与oldfiber同时遍历完" class="header-anchor">#</a>
      <code>newChildren</code>与<code>oldFiber</code>同时遍历完</h3>
    <p>那就是最理想的情况：只需在第一轮遍历进行组件<a
        href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactChildFiber.new.js#L825"
        target="_blank" rel="noopener noreferrer"><code>更新</code><span><svg xmlns="http://www.w3.org/2000/svg"
            aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"
            class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a>。此时<code>Diff</code>结束。</p>
    <h3 id="newchildren没遍历完-oldfiber遍历完"><a href="#newchildren没遍历完-oldfiber遍历完" class="header-anchor">#</a>
      <code>newChildren</code>没遍历完，<code>oldFiber</code>遍历完</h3>
    <p>
      已有的<code>DOM节点</code>都复用了，这时还有新加入的节点，意味着本次更新有新节点插入，我们只需要遍历剩下的<code>newChildren</code>为生成的<code>workInProgress fiber</code>依次标记<code>Placement</code>。
    </p>
    <blockquote>
      <p>你可以在<a
          href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactChildFiber.new.js#L869"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>看到这段源码逻辑</p>
    </blockquote>
    <h3 id="newchildren遍历完-oldfiber没遍历完"><a href="#newchildren遍历完-oldfiber没遍历完" class="header-anchor">#</a>
      <code>newChildren</code>遍历完，<code>oldFiber</code>没遍历完</h3>
    <p>意味着本次更新比之前的节点数量少，有节点被删除了。所以需要遍历剩下的<code>oldFiber</code>，依次标记<code>Deletion</code>。</p>
    <blockquote>
      <p>你可以在<a
          href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactChildFiber.new.js#L863"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>看到这段源码逻辑</p>
    </blockquote>
    <h3 id="newchildren与oldfiber都没遍历完"><a href="#newchildren与oldfiber都没遍历完" class="header-anchor">#</a>
      <code>newChildren</code>与<code>oldFiber</code>都没遍历完</h3>
    <p>这意味着有节点在这次更新中改变了位置。</p>
    <p>这是<code>Diff算法</code>最精髓也是最难懂的部分。我们接下来会重点讲解。</p>
    <blockquote>
      <p>你可以在<a
          href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactChildFiber.new.js#L893"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>看到这段源码逻辑</p>
    </blockquote>
    <h2 id="处理移动的节点"><a href="#处理移动的节点" class="header-anchor">#</a> 处理移动的节点</h2>
    <p>由于有节点改变了位置，所以不能再用位置索引<code>i</code>对比前后的节点，那么如何才能将同一个节点在两次更新中对应上呢？</p>
    <p>我们需要使用<code>key</code>。</p>
    <p>
      为了快速的找到<code>key</code>对应的<code>oldFiber</code>，我们将所有还未处理的<code>oldFiber</code>存入以<code>key</code>为key，<code>oldFiber</code>为value的<code>Map</code>中。
    </p>
    <div class="language-javascript extra-class">
      <pre class="language-javascript"><code><span class="token keyword">const</span> existingChildren <span class="token operator">=</span> <span class="token function">mapRemainingChildren</span><span class="token punctuation">(</span>returnFiber<span class="token punctuation">,</span> oldFiber<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    </div>
    <blockquote>
      <p>你可以在<a
          href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactChildFiber.new.js#L890"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>看到这段源码逻辑</p>
    </blockquote>
    <p>
      接下来遍历剩余的<code>newChildren</code>，通过<code>newChildren[i].key</code>就能在<code>existingChildren</code>中找到<code>key</code>相同的<code>oldFiber</code>。
    </p>
    <h2 id="标记节点是否移动"><a href="#标记节点是否移动" class="header-anchor">#</a> 标记节点是否移动</h2>
    <p>既然我们的目标是寻找移动的节点，那么我们需要明确：节点是否移动是以什么为参照物？</p>
    <p>我们的参照物是：最后一个可复用的节点在<code>oldFiber</code>中的位置索引（用变量<code>lastPlacedIndex</code>表示）。</p>
    <p>
      由于本次更新中节点是按<code>newChildren</code>的顺序排列。在遍历<code>newChildren</code>过程中，每个<code>遍历到的可复用节点</code>一定是当前遍历到的<code>所有可复用节点</code>中<strong>最靠右的那个</strong>，即一定在<code>lastPlacedIndex</code>对应的<code>可复用的节点</code>在本次更新中位置的后面。
    </p>
    <p>
      那么我们只需要比较<code>遍历到的可复用节点</code>在上次更新时是否也在<code>lastPlacedIndex</code>对应的<code>oldFiber</code>后面，就能知道两次更新中这两个节点的相对位置改变没有。
    </p>
    <p>
      我们用变量<code>oldIndex</code>表示<code>遍历到的可复用节点</code>在<code>oldFiber</code>中的位置索引。如果<code>oldIndex &lt; lastPlacedIndex</code>，代表本次更新该节点需要向右移动。
    </p>
    <p>
      <code>lastPlacedIndex</code>初始为<code>0</code>，每遍历一个可复用的节点，如果<code>oldIndex &gt;= lastPlacedIndex</code>，则<code>lastPlacedIndex = oldIndex</code>。
    </p>
    <p>单纯文字表达比较晦涩，这里我们提供两个Demo，你可以对照着理解。</p>
    <h2 id="demo1"><a href="#demo1" class="header-anchor">#</a> Demo1</h2>
    <p>在Demo中我们简化下书写，每个字母代表一个节点，字母的值代表节点的<code>key</code></p>
    <div class="language-jsx extra-class">
      <pre class="language-jsx"><code>
<span class="token comment">// 之前</span>
abcd

<span class="token comment">// 之后</span>
acdb

<span class="token operator">===</span>第一轮遍历开始<span class="token operator">===</span>
a（之后）vs a（之前）  
key不变，可复用
此时 a 对应的oldFiber（之前的a）在之前的数组（abcd）中索引为<span class="token number">0</span>
所以 lastPlacedIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

继续第一轮遍历<span class="token operator">...</span>

c（之后）vs b（之前）  
key改变，不能复用，跳出第一轮遍历
此时 lastPlacedIndex <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token operator">===</span>第一轮遍历结束<span class="token operator">===</span>

<span class="token operator">===</span>第二轮遍历开始<span class="token operator">===</span>
newChildren <span class="token operator">===</span> cdb，没用完，不需要执行删除旧节点
oldFiber <span class="token operator">===</span> bcd，没用完，不需要执行插入新节点

将剩余oldFiber（bcd）保存为map

<span class="token comment">// 当前oldFiber：bcd</span>
<span class="token comment">// 当前newChildren：cdb</span>

继续遍历剩余newChildren

key <span class="token operator">===</span> c 在 oldFiber中存在
<span class="token keyword">const</span> oldIndex <span class="token operator">=</span> c（之前）<span class="token punctuation">.</span>index<span class="token punctuation">;</span>
此时 oldIndex <span class="token operator">===</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">// 之前节点为 abcd，所以c.index === 2</span>
比较 oldIndex 与 lastPlacedIndex<span class="token punctuation">;</span>

如果 oldIndex <span class="token operator">&gt;=</span> lastPlacedIndex 代表该可复用节点不需要移动
并将 lastPlacedIndex <span class="token operator">=</span> oldIndex<span class="token punctuation">;</span>
如果 oldIndex <span class="token operator">&lt;</span> lastplacedIndex 该可复用节点之前插入的位置索引小于这次更新需要插入的位置索引，代表该节点需要向右移动

在例子中，oldIndex <span class="token number">2</span> <span class="token operator">&gt;</span> lastPlacedIndex <span class="token number">0</span>，
则 lastPlacedIndex <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
c节点位置不变

继续遍历剩余newChildren

<span class="token comment">// 当前oldFiber：bd</span>
<span class="token comment">// 当前newChildren：db</span>

key <span class="token operator">===</span> d 在 oldFiber中存在
<span class="token keyword">const</span> oldIndex <span class="token operator">=</span> d（之前）<span class="token punctuation">.</span>index<span class="token punctuation">;</span>
oldIndex <span class="token number">3</span> <span class="token operator">&gt;</span> lastPlacedIndex <span class="token number">2</span> <span class="token comment">// 之前节点为 abcd，所以d.index === 3</span>
则 lastPlacedIndex <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
d节点位置不变

继续遍历剩余newChildren

<span class="token comment">// 当前oldFiber：b</span>
<span class="token comment">// 当前newChildren：b</span>

key <span class="token operator">===</span> b 在 oldFiber中存在
<span class="token keyword">const</span> oldIndex <span class="token operator">=</span> b（之前）<span class="token punctuation">.</span>index<span class="token punctuation">;</span>
oldIndex <span class="token number">1</span> <span class="token operator">&lt;</span> lastPlacedIndex <span class="token number">3</span> <span class="token comment">// 之前节点为 abcd，所以b.index === 1</span>
则 b节点需要向右移动
<span class="token operator">===</span>第二轮遍历结束<span class="token operator">===</span>

最终acd <span class="token number">3</span>个节点都没有移动，b节点被标记为移动

</code></pre>
    </div>
    <h2 id="demo2"><a href="#demo2" class="header-anchor">#</a> Demo2</h2>
    <div class="language-jsx extra-class">
      <pre class="language-jsx"><code><span class="token comment">// 之前</span>
abcd

<span class="token comment">// 之后</span>
dabc

<span class="token operator">===</span>第一轮遍历开始<span class="token operator">===</span>
d（之后）vs a（之前）  
key改变，不能复用，跳出遍历
<span class="token operator">===</span>第一轮遍历结束<span class="token operator">===</span>

<span class="token operator">===</span>第二轮遍历开始<span class="token operator">===</span>
newChildren <span class="token operator">===</span> dabc，没用完，不需要执行删除旧节点
oldFiber <span class="token operator">===</span> abcd，没用完，不需要执行插入新节点

将剩余oldFiber（abcd）保存为map

继续遍历剩余newChildren

<span class="token comment">// 当前oldFiber：abcd</span>
<span class="token comment">// 当前newChildren dabc</span>

key <span class="token operator">===</span> d 在 oldFiber中存在
<span class="token keyword">const</span> oldIndex <span class="token operator">=</span> d（之前）<span class="token punctuation">.</span>index<span class="token punctuation">;</span>
此时 oldIndex <span class="token operator">===</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">// 之前节点为 abcd，所以d.index === 3</span>
比较 oldIndex 与 lastPlacedIndex<span class="token punctuation">;</span>
oldIndex <span class="token number">3</span> <span class="token operator">&gt;</span> lastPlacedIndex <span class="token number">0</span>
则 lastPlacedIndex <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
d节点位置不变

继续遍历剩余newChildren

<span class="token comment">// 当前oldFiber：abc</span>
<span class="token comment">// 当前newChildren abc</span>

key <span class="token operator">===</span> a 在 oldFiber中存在
<span class="token keyword">const</span> oldIndex <span class="token operator">=</span> a（之前）<span class="token punctuation">.</span>index<span class="token punctuation">;</span> <span class="token comment">// 之前节点为 abcd，所以a.index === 0</span>
此时 oldIndex <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">;</span>
比较 oldIndex 与 lastPlacedIndex<span class="token punctuation">;</span>
oldIndex <span class="token number">0</span> <span class="token operator">&lt;</span> lastPlacedIndex <span class="token number">3</span>
则 a节点需要向右移动

继续遍历剩余newChildren

<span class="token comment">// 当前oldFiber：bc</span>
<span class="token comment">// 当前newChildren bc</span>

key <span class="token operator">===</span> b 在 oldFiber中存在
<span class="token keyword">const</span> oldIndex <span class="token operator">=</span> b（之前）<span class="token punctuation">.</span>index<span class="token punctuation">;</span> <span class="token comment">// 之前节点为 abcd，所以b.index === 1</span>
此时 oldIndex <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">;</span>
比较 oldIndex 与 lastPlacedIndex<span class="token punctuation">;</span>
oldIndex <span class="token number">1</span> <span class="token operator">&lt;</span> lastPlacedIndex <span class="token number">3</span>
则 b节点需要向右移动

继续遍历剩余newChildren

<span class="token comment">// 当前oldFiber：c</span>
<span class="token comment">// 当前newChildren c</span>

key <span class="token operator">===</span> c 在 oldFiber中存在
<span class="token keyword">const</span> oldIndex <span class="token operator">=</span> c（之前）<span class="token punctuation">.</span>index<span class="token punctuation">;</span> <span class="token comment">// 之前节点为 abcd，所以c.index === 2</span>
此时 oldIndex <span class="token operator">===</span> <span class="token number">2</span><span class="token punctuation">;</span>
比较 oldIndex 与 lastPlacedIndex<span class="token punctuation">;</span>
oldIndex <span class="token number">2</span> <span class="token operator">&lt;</span> lastPlacedIndex <span class="token number">3</span>
则 c节点需要向右移动

<span class="token operator">===</span>第二轮遍历结束<span class="token operator">===</span>

</code></pre>
    </div>
    <p>可以看到，我们以为从 <code>abcd</code> 变为 <code>dabc</code>，只需要将<code>d</code>移动到前面。</p>
    <p>但实际上React保持<code>d</code>不变，将<code>abc</code>分别移动到了<code>d</code>的后面。</p>
    <p>从这点可以看出，考虑性能，我们要尽量减少将节点从后面移动到前面的操作。</p>
  </div>
  <div class="theme-default-content content__default">
    <p>经过前几章的学习，我们终于有足够的前置知识理解<strong>状态更新</strong>的整个流程。</p>
    <p>这一章我们看看几种常见的触发<strong>状态更新</strong>的方法是如何完成工作的。</p>
    <h2 id="几个关键节点"><a href="#几个关键节点" class="header-anchor">#</a> 几个关键节点</h2>
    <p>在开始学习前，我们先了解源码中几个关键节点（即几个关键函数的调用）。通过这章的学习，我们会将这些关键节点的调用路径串起来。</p>
    <p>先从我们所熟知的概念开始。</p>
    <h3 id="render阶段的开始"><a href="#render阶段的开始" class="header-anchor">#</a> render阶段的开始</h3>
    <p>我们在<a href="/process/reconciler.html">render阶段流程概览一节</a>讲到，</p>
    <p>
      <code>render阶段</code>开始于<code>performSyncWorkOnRoot</code>或<code>performConcurrentWorkOnRoot</code>方法的调用。这取决于本次更新是同步更新还是异步更新。
    </p>
    <h3 id="commit阶段的开始"><a href="#commit阶段的开始" class="header-anchor">#</a> commit阶段的开始</h3>
    <p>我们在<a href="/renderer/prepare.html">commit阶段流程概览一节</a>讲到，</p>
    <p><code>commit阶段</code>开始于<code>commitRoot</code>方法的调用。其中<code>rootFiber</code>会作为传参。</p>
    <p>我们已经知道，<code>render阶段</code>完成后会进入<code>commit阶段</code>。让我们继续补全从<code>触发状态更新</code>到<code>render阶段</code>的路径。</p>
    <div class="language-sh extra-class">
      <pre class="language-sh"><code>触发状态更新（根据场景调用不同方法）

    <span class="token operator">|</span>
    <span class="token operator">|</span>
    <span class="token function">v</span>

    ？

    <span class="token operator">|</span>
    <span class="token operator">|</span>
    <span class="token function">v</span>

render阶段（<span class="token variable"><span class="token variable">`</span>performSyncWorkOnRoot<span class="token variable">`</span></span> 或 <span class="token variable"><span class="token variable">`</span>performConcurrentWorkOnRoot<span class="token variable">`</span></span>）

    <span class="token operator">|</span>
    <span class="token operator">|</span>
    <span class="token function">v</span>

commit阶段（<span class="token variable"><span class="token variable">`</span>commitRoot<span class="token variable">`</span></span>）
</code></pre>
    </div>
    <h3 id="创建update对象"><a href="#创建update对象" class="header-anchor">#</a> 创建Update对象</h3>
    <p>在<code>React</code>中，有如下方法可以触发状态更新（排除<code>SSR</code>相关）：</p>
    <ul>
      <li>
        <p>ReactDOM.render</p>
      </li>
      <li>
        <p>this.setState</p>
      </li>
      <li>
        <p>this.forceUpdate</p>
      </li>
      <li>
        <p>useState</p>
      </li>
      <li>
        <p>useReducer</p>
      </li>
    </ul>
    <p>这些方法调用的场景各不相同，他们是如何接入同一套<strong>状态更新机制</strong>呢？</p>
    <p>
      答案是：每次<code>状态更新</code>都会创建一个保存<strong>更新状态相关内容</strong>的对象，我们叫他<code>Update</code>。在<code>render阶段</code>的<code>beginWork</code>中会根据<code>Update</code>计算新的<code>state</code>。
    </p>
    <p>我们会在下一节详细讲解<code>Update</code>。</p>
    <h3 id="从fiber到root"><a href="#从fiber到root" class="header-anchor">#</a> 从fiber到root</h3>
    <p>现在<code>触发状态更新的fiber</code>上已经包含<code>Update</code>对象。</p>
    <p>我们知道，<code>render阶段</code>是从<code>rootFiber</code>开始向下遍历。那么如何从<code>触发状态更新的fiber</code>得到<code>rootFiber</code>呢？
    </p>
    <p>答案是：调用<code>markUpdateLaneFromFiberToRoot</code>方法。</p>
    <blockquote>
      <p>你可以从<a
          href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L636"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new
              window)</span></span></a>看到<code>markUpdateLaneFromFiberToRoot</code>的源码</p>
    </blockquote>
    <p>该方法做的工作可以概括为：从<code>触发状态更新的fiber</code>一直向上遍历到<code>rootFiber</code>，并返回<code>rootFiber</code>。</p>
    <p>由于不同更新优先级不尽相同，所以过程中还会更新遍历到的<code>fiber</code>的优先级。这对于我们当前属于超纲内容。</p>
    <h3 id="调度更新"><a href="#调度更新" class="header-anchor">#</a> 调度更新</h3>
    <p>
      现在我们拥有一个<code>rootFiber</code>，该<code>rootFiber</code>对应的<code>Fiber树</code>中某个<code>Fiber节点</code>包含一个<code>Update</code>。
    </p>
    <p>接下来通知<code>Scheduler</code>根据<strong>更新</strong>的优先级，决定以<strong>同步</strong>还是<strong>异步</strong>的方式调度本次更新。</p>
    <p>这里调用的方法是<code>ensureRootIsScheduled</code>。</p>
    <p>以下是<code>ensureRootIsScheduled</code>最核心的一段代码：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>newCallbackPriority <span class="token operator">===</span> SyncLanePriority<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 任务已经过期，需要同步执行render阶段</span>
  newCallbackNode <span class="token operator">=</span> <span class="token function">scheduleSyncCallback</span><span class="token punctuation">(</span>
    <span class="token function">performSyncWorkOnRoot</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> root<span class="token punctuation">)</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token comment">// 根据任务优先级异步执行render阶段</span>
  <span class="token keyword">var</span> schedulerPriorityLevel <span class="token operator">=</span> <span class="token function">lanePriorityToSchedulerPriority</span><span class="token punctuation">(</span>
    newCallbackPriority
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
  newCallbackNode <span class="token operator">=</span> <span class="token function">scheduleCallback</span><span class="token punctuation">(</span>
    schedulerPriorityLevel<span class="token punctuation">,</span>
    <span class="token function">performConcurrentWorkOnRoot</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> root<span class="token punctuation">)</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <blockquote>
      <p>你可以从<a
          href="https://github.com/facebook/react/blob/b6df4417c79c11cfb44f965fab55b573882b1d54/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L602"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>看到<code>ensureRootIsScheduled</code>的源码</p>
    </blockquote>
    <p>
      其中，<code>scheduleCallback</code>和<code>scheduleSyncCallback</code>会调用<code>Scheduler</code>提供的调度方法根据<code>优先级</code>调度回调函数执行。
    </p>
    <p>可以看到，这里调度的回调函数为：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token function">performSyncWorkOnRoot</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">performConcurrentWorkOnRoot</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    </div>
    <p>即<code>render阶段</code>的入口函数。</p>
    <p>至此，<code>状态更新</code>就和我们所熟知的<code>render阶段</code>连接上了。</p>
    <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2>
    <p>让我们梳理下<code>状态更新</code>的整个调用路径的关键节点：</p>
    <div class="language-sh extra-class">
      <pre class="language-sh"><code>触发状态更新（根据场景调用不同方法）

    <span class="token operator">|</span>
    <span class="token operator">|</span>
    <span class="token function">v</span>

创建Update对象（接下来三节详解）

    <span class="token operator">|</span>
    <span class="token operator">|</span>
    <span class="token function">v</span>

从fiber到root（<span class="token variable"><span class="token variable">`</span>markUpdateLaneFromFiberToRoot<span class="token variable">`</span></span>）

    <span class="token operator">|</span>
    <span class="token operator">|</span>
    <span class="token function">v</span>

调度更新（<span class="token variable"><span class="token variable">`</span>ensureRootIsScheduled<span class="token variable">`</span></span>）

    <span class="token operator">|</span>
    <span class="token operator">|</span>
    <span class="token function">v</span>

render阶段（<span class="token variable"><span class="token variable">`</span>performSyncWorkOnRoot<span class="token variable">`</span></span> 或 <span class="token variable"><span class="token variable">`</span>performConcurrentWorkOnRoot<span class="token variable">`</span></span>）

    <span class="token operator">|</span>
    <span class="token operator">|</span>
    <span class="token function">v</span>

commit阶段（<span class="token variable"><span class="token variable">`</span>commitRoot<span class="token variable">`</span></span>）
</code></pre>
    </div>
    <h2 id="总结-2"><a href="#总结-2" class="header-anchor">#</a> 总结</h2>
    <p>本节我们了解了<strong>状态更新</strong>的整个流程。</p>
    <p>在接下来三节中，我们会花大量篇幅讲解<code>Update</code>的工作机制，因为他是构成<code>React concurrent mode</code>的核心机制之一。</p>
  </div>
  <div class="theme-default-content content__default">
    <p>在深入源码前，让我们先建立<code>更新机制</code>的<code>心智模型</code>。</p>
    <p>在后面两节讲解源码时，我们会将代码与<code>心智模型</code>联系上，方便你更好理解。</p>
    <h2 id="同步更新的react"><a href="#同步更新的react" class="header-anchor">#</a> 同步更新的React</h2>
    <p>我们可以将<code>更新机制</code>类比<code>代码版本控制</code>。</p>
    <p>在没有<code>代码版本控制</code>前，我们在代码中逐步叠加功能。一切看起来井然有序，直到我们遇到了一个紧急线上bug（红色节点）。</p> <img
      src="https://react.iamkasong.com/img/git1.png" alt="流程1">
    <p>为了修复这个bug，我们需要首先将之前的代码提交。</p>
    <p>在<code>React</code>中，所有通过<code>ReactDOM.render</code>创建的应用（其他创建应用的方式参考<a
        href="/state/reactdom.html#react的其他入口函数">ReactDOM.render一节</a>）都是通过类似的方式<code>更新状态</code>。</p>
    <p>即没有<code>优先级</code>概念，<code>高优更新</code>（红色节点）需要排在其他<code>更新</code>后面执行。</p>
    <h2 id="并发更新的react"><a href="#并发更新的react" class="header-anchor">#</a> 并发更新的React</h2>
    <p>当有了<code>代码版本控制</code>，有紧急线上bug需要修复时，我们暂存当前分支的修改，在<code>master分支</code>修复bug并紧急上线。</p> <img
      src="https://react.iamkasong.com/img/git2.png" alt="流程2">
    <p>bug修复上线后通过<code>git rebase</code>命令和<code>开发分支</code>连接上。<code>开发分支</code>基于<code>修复bug的版本</code>继续开发。</p> <img
      src="https://react.iamkasong.com/img/git3.png" alt="流程3">
    <p>
      在<code>React</code>中，通过<code>ReactDOM.createBlockingRoot</code>和<code>ReactDOM.createRoot</code>创建的应用会采用<code>并发</code>的方式<code>更新状态</code>。
    </p>
    <p><code>高优更新</code>（红色节点）中断正在进行中的<code>低优更新</code>（蓝色节点），先完成<code>render - commit流程</code>。</p>
    <p>待<code>高优更新</code>完成后，<code>低优更新</code>基于<code>高优更新</code>的结果<code>重新更新</code>。</p>
    <p>接下来两节我们会从源码角度讲解这套<code>并发更新</code>是如何实现的。</p>
    <h2 id="参考资料"><a href="#参考资料" class="header-anchor">#</a> 参考资料</h2>
    <p><a href="https://www.youtube.com/watch?v=v6iR3Zk4oDY" target="_blank" rel="noopener noreferrer"><code>外网</code>
        <code>英文</code> React Core Team Dan介绍React未来发展方向<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
            focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a></p>
  </div>
  <div class="theme-default-content content__default">
    <p>通过本章第一节学习，我们知道<code>状态更新</code>流程开始后首先会<code>创建Update对象</code>。</p>
    <p>本节我们学习<code>Update</code>的结构与工作流程。</p>
    <blockquote>
      <p>你可以将<code>Update</code>类比<code>心智模型</code>中的一次<code>commit</code>。</p>
    </blockquote>
    <h2 id="update的分类"><a href="#update的分类" class="header-anchor">#</a> Update的分类</h2>
    <p>我们先来了解<code>Update</code>的结构。</p>
    <p>首先，我们将可以触发更新的方法所隶属的组件分类：</p>
    <ul>
      <li>
        <p>ReactDOM.render —— HostRoot</p>
      </li>
      <li>
        <p>this.setState —— ClassComponent</p>
      </li>
      <li>
        <p>this.forceUpdate —— ClassComponent</p>
      </li>
      <li>
        <p>useState —— FunctionComponent</p>
      </li>
      <li>
        <p>useReducer —— FunctionComponent</p>
      </li>
    </ul>
    <p>可以看到，一共三种组件（<code>HostRoot</code> | <code>ClassComponent</code> | <code>FunctionComponent</code>）可以触发更新。</p>
    <p>
      由于不同类型组件工作方式不同，所以存在两种不同结构的<code>Update</code>，其中<code>ClassComponent</code>与<code>HostRoot</code>共用一套<code>Update</code>结构，<code>FunctionComponent</code>单独使用一种<code>Update</code>结构。
    </p>
    <p>
      虽然他们的结构不同，但是他们工作机制与工作流程大体相同。在本节我们介绍前一种<code>Update</code>，<code>FunctionComponent</code>对应的<code>Update</code>在<code>Hooks</code>章节介绍。
    </p>
    <h2 id="update的结构"><a href="#update的结构" class="header-anchor">#</a> Update的结构</h2>
    <p><code>ClassComponent</code>与<code>HostRoot</code>（即<code>rootFiber.tag</code>对应类型）共用同一种<code>Update结构</code>。</p>
    <p>对应的结构如下：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">const</span> update<span class="token operator">:</span> Update<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  eventTime<span class="token punctuation">,</span>
  lane<span class="token punctuation">,</span>
  suspenseConfig<span class="token punctuation">,</span>
  tag<span class="token operator">:</span> UpdateState<span class="token punctuation">,</span>
  payload<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  callback<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>

  next<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
    </div>
    <blockquote>
      <p><code>Update</code>由<code>createUpdate</code>方法返回，你可以从<a
          href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactUpdateQueue.old.js#L189"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>看到<code>createUpdate</code>的源码</p>
    </blockquote>
    <p>字段意义如下：</p>
    <ul>
      <li>
        <p>eventTime：任务时间，通过<code>performance.now()</code>获取的毫秒数。由于该字段在未来会重构，当前我们不需要理解他。</p>
      </li>
      <li>
        <p>lane：优先级相关字段。当前还不需要掌握他，只需要知道不同<code>Update</code>优先级可能是不同的。</p>
      </li>
    </ul>
    <blockquote>
      <p>你可以将<code>lane</code>类比<code>心智模型</code>中<code>需求的紧急程度</code>。</p>
    </blockquote>
    <ul>
      <li>
        <p>suspenseConfig：<code>Suspense</code>相关，暂不关注。</p>
      </li>
      <li>
        <p>tag：更新的类型，包括<code>UpdateState</code> | <code>ReplaceState</code> | <code>ForceUpdate</code> |
          <code>CaptureUpdate</code>。</p>
      </li>
      <li>
        <p>
          payload：更新挂载的数据，不同类型组件挂载的数据不同。对于<code>ClassComponent</code>，<code>payload</code>为<code>this.setState</code>的第一个传参。对于<code>HostRoot</code>，<code>payload</code>为<code>ReactDOM.render</code>的第一个传参。
        </p>
      </li>
      <li>
        <p>callback：更新的回调函数。即在<a href="/renderer/layout.html#commitlayouteffectonfiber">commit 阶段的 layout
            子阶段一节</a>中提到的<code>回调函数</code>。</p>
      </li>
      <li>
        <p>next：与其他<code>Update</code>连接形成链表。</p>
      </li>
    </ul>
    <h2 id="update与fiber的联系"><a href="#update与fiber的联系" class="header-anchor">#</a> Update与Fiber的联���</h2>
    <p>
      我们发现，<code>Update</code>存在一个连接其他<code>Update</code>形成链表的字段<code>next</code>。联系<code>React</code>中另一种以链表形式组成的结构<code>Fiber</code>，他们之间有什么关联么？
    </p>
    <p>答案是肯定的。</p>
    <p>从<a
        href="/process/doubleBuffer.html">双缓存机制一节</a>我们知道，<code>Fiber节点</code>组成<code>Fiber树</code>，页面中最多同时存在两棵<code>Fiber树</code>：
    </p>
    <ul>
      <li>
        <p>代表当前页面状态的<code>current Fiber树</code></p>
      </li>
      <li>
        <p>代表正在<code>render阶段</code>的<code>workInProgress Fiber树</code></p>
      </li>
    </ul>
    <p>
      类似<code>Fiber节点</code>组成<code>Fiber树</code>，<code>Fiber节点</code>上的多个<code>Update</code>会组成链表并被包含在<code>fiber.updateQueue</code>中。
    </p>
    <div class="custom-block warning">
      <p class="custom-block-title">什么情况下一个Fiber节点会存在多个Update？</p>
      <p>你可能疑惑为什么一个<code>Fiber节点</code>会存在多个<code>Update</code>。这其实是很常见的情况。</p>
      <p>在这里介绍一种最简单的情况：</p>
      <div class="language-js extra-class">
        <pre class="language-js"><code><span class="token function">onClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    a<span class="token operator">:</span> <span class="token number">1</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    b<span class="token operator">:</span> <span class="token number">2</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
      </div>
      <p>
        在一个<code>ClassComponent</code>中触发<code>this.onClick</code>方法，方法内部调用了两次<code>this.setState</code>。这会在该<code>fiber</code>中产生两个<code>Update</code>。
      </p>
    </div>
    <p><code>Fiber节点</code>最多同时存在两个<code>updateQueue</code>：</p>
    <ul>
      <li>
        <p><code>current fiber</code>保存的<code>updateQueue</code>即<code>current updateQueue</code></p>
      </li>
      <li>
        <p><code>workInProgress fiber</code>保存的<code>updateQueue</code>即<code>workInProgress updateQueue</code></p>
      </li>
    </ul>
    <p>
      在<code>commit阶段</code>完成页面渲染后，<code>workInProgress Fiber树</code>变为<code>current Fiber树</code>，<code>workInProgress Fiber树</code>内<code>Fiber节点</code>的<code>updateQueue</code>就变成<code>current updateQueue</code>。
    </p>
    <h2 id="updatequeue"><a href="#updatequeue" class="header-anchor">#</a> updateQueue</h2>
    <p><code>updateQueue</code>有三种类型，其中针对<code>HostComponent</code>的类型我们在<a
        href="/process/completeWork.html#update时">completeWork一节</a>介绍过。</p>
    <p>剩下两种类型和<code>Update</code>的两种类型对应。</p>
    <p><code>ClassComponent</code>与<code>HostRoot</code>使用的<code>UpdateQueue</code>结构如下：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">const</span> queue<span class="token operator">:</span> UpdateQueue<span class="token operator">&lt;</span>State<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    baseState<span class="token operator">:</span> fiber<span class="token punctuation">.</span>memoizedState<span class="token punctuation">,</span>
    firstBaseUpdate<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    lastBaseUpdate<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    shared<span class="token operator">:</span> <span class="token punctuation">{</span>
      pending<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    effects<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
    </div>
    <blockquote>
      <p><code>UpdateQueue</code>由<code>initializeUpdateQueue</code>方法返回，你可以从<a
          href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactUpdateQueue.new.js#L157"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>看到<code>initializeUpdateQueue</code>的源码</p>
    </blockquote>
    <p>字段说明如下：</p>
    <ul>
      <li>
        baseState：本次更新前该<code>Fiber节点</code>的<code>state</code>，<code>Update</code>基于该<code>state</code>计算更新后的<code>state</code>。
      </li>
    </ul>
    <blockquote>
      <p>你可以将<code>baseState</code>类比<code>心智模型</code>中的<code>master分支</code>。</p>
    </blockquote>
    <ul>
      <li>
        <code>firstBaseUpdate</code>与<code>lastBaseUpdate</code>：本次更新前该<code>Fiber节点</code>已保存的<code>Update</code>。以链表形式存在，链表头为<code>firstBaseUpdate</code>，链表尾为<code>lastBaseUpdate</code>。之所以在更新产生前该<code>Fiber节点</code>内就存在<code>Update</code>，是由于某些<code>Update</code>优先级较低所以在上次<code>render阶段</code>由<code>Update</code>计算<code>state</code>时被跳过。
      </li>
    </ul>
    <blockquote>
      <p>你可以将<code>baseUpdate</code>类比<code>心智模型</code>中执行<code>git rebase</code>基于的<code>commit</code>（节点D）。</p>
    </blockquote>
    <ul>
      <li>
        <code>shared.pending</code>：触发更新时，产生的<code>Update</code>会保存在<code>shared.pending</code>中形成单向环状链表。当由<code>Update</code>计算<code>state</code>时这个环会被剪开并连接在<code>lastBaseUpdate</code>后面。
      </li>
    </ul>
    <blockquote>
      <p>你可以将<code>shared.pending</code>类比<code>心智模型</code>中本次需要提交的<code>commit</code>（节点ABC）。</p>
    </blockquote>
    <ul>
      <li>effects：数组。保存<code>update.callback !== null</code>的<code>Update</code>。</li>
    </ul>
    <h2 id="例子"><a href="#例子" class="header-anchor">#</a> 例子</h2>
    <p><code>updateQueue</code>相关代码逻辑涉及到大量链表操作，比较难懂。在此我们举例对<code>updateQueue</code>的工作流程讲解下。</p>
    <p>假设有一个<code>fiber</code>刚经历<code>commit阶段</code>完成渲染。</p>
    <p>
      该<code>fiber</code>上有两个由于优先级过低所以在上次的<code>render阶段</code>并没有处理的<code>Update</code>。他们会成为下次更新的<code>baseUpdate</code>。
    </p>
    <p>我们称其为<code>u1</code>和<code>u2</code>，其中<code>u1.next === u2</code>。</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code>fiber<span class="token punctuation">.</span>updateQueue<span class="token punctuation">.</span>firstBaseUpdate <span class="token operator">===</span> u1<span class="token punctuation">;</span>
fiber<span class="token punctuation">.</span>updateQueue<span class="token punctuation">.</span>lastBaseUpdate <span class="token operator">===</span> u2<span class="token punctuation">;</span>
u1<span class="token punctuation">.</span>next <span class="token operator">===</span> u2<span class="token punctuation">;</span>
</code></pre>
    </div>
    <p>我们用<code>--&gt;</code>表示链表的指向：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code>fiber<span class="token punctuation">.</span>updateQueue<span class="token punctuation">.</span>baseUpdate<span class="token operator">:</span> u1 <span class="token operator">--</span><span class="token operator">&gt;</span> u2
</code></pre>
    </div>
    <p>现在我们在<code>fiber</code>上触发两次状态更新，这会先后产生两个新的<code>Update</code>，我们称为<code>u3</code>和<code>u4</code>。</p>
    <p>每个 <code>update</code> 都会通过 <code>enqueueUpdate</code> 方法插入到 <code>updateQueue</code> 队列上</p>
    <p>当插入<code>u3</code>后：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code>fiber<span class="token punctuation">.</span>updateQueue<span class="token punctuation">.</span>shared<span class="token punctuation">.</span>pending <span class="token operator">===</span> u3<span class="token punctuation">;</span>
u3<span class="token punctuation">.</span>next <span class="token operator">===</span> u3<span class="token punctuation">;</span>
</code></pre>
    </div>
    <p><code>shared.pending</code>的环状链表，用图表示为：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code>fiber<span class="token punctuation">.</span>updateQueue<span class="token punctuation">.</span>shared<span class="token punctuation">.</span>pending<span class="token operator">:</span>   u3 ─────┐ 
                                     <span class="token operator">^</span>      <span class="token operator">|</span>                                    
                                     └──────┘
</code></pre>
    </div>
    <p>接着插入<code>u4</code>之后：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code>fiber<span class="token punctuation">.</span>updateQueue<span class="token punctuation">.</span>shared<span class="token punctuation">.</span>pending <span class="token operator">===</span> u4<span class="token punctuation">;</span>
u4<span class="token punctuation">.</span>next <span class="token operator">===</span> u3<span class="token punctuation">;</span>
u3<span class="token punctuation">.</span>next <span class="token operator">===</span> u4<span class="token punctuation">;</span>
</code></pre>
    </div>
    <p><code>shared.pending</code>是环状链表，用图表示为：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code>fiber<span class="token punctuation">.</span>updateQueue<span class="token punctuation">.</span>shared<span class="token punctuation">.</span>pending<span class="token operator">:</span>   u4 ──<span class="token operator">&gt;</span> u3
                                     <span class="token operator">^</span>      <span class="token operator">|</span>                                    
                                     └──────┘
</code></pre>
    </div>
    <p><code>shared.pending</code> 会保证始终指向最后一个插入的<code>update</code>，你可以在<a
        href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactUpdateQueue.new.js#L208"
        target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
            focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a>看到<code>enqueueUpdate</code>的源码</p>
    <p>更新调度完成后进入<code>render阶段</code>。</p>
    <p>此时<code>shared.pending</code>的环被剪开并连接在<code>updateQueue.lastBaseUpdate</code>后面：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code>fiber<span class="token punctuation">.</span>updateQueue<span class="token punctuation">.</span>baseUpdate<span class="token operator">:</span> u1 <span class="token operator">--</span><span class="token operator">&gt;</span> u2 <span class="token operator">--</span><span class="token operator">&gt;</span> u3 <span class="token operator">--</span><span class="token operator">&gt;</span> u4
</code></pre>
    </div>
    <p>
      接下来遍历<code>updateQueue.baseUpdate</code>链表，以<code>fiber.updateQueue.baseState</code>为<code>初始state</code>，依次与遍历到的每个<code>Update</code>计算并产生新的<code>state</code>（该操作类比<code>Array.prototype.reduce</code>）。
    </p>
    <p>在遍历时如果有优先级低的<code>Update</code>会被跳过。</p>
    <p>当遍历完成后获得的<code>state</code>，就是该<code>Fiber节点</code>在本次更新的<code>state</code>（源码中叫做<code>memoizedState</code>）。</p>
    <blockquote>
      <p><code>render阶段</code>的<code>Update操作</code>由<code>processUpdateQueue</code>完成，你可以从<a
          href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactUpdateQueue.new.js#L405"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>看到<code>processUpdateQueue</code>的源码</p>
    </blockquote>
    <p>
      <code>state</code>的变化在<code>render阶段</code>产生与上次更新不同的<code>JSX</code>对象，通过<code>Diff算法</code>产生<code>effectTag</code>，在<code>commit阶段</code>渲染在页面上。
    </p>
    <p>渲染完成后<code>workInProgress Fiber树</code>变为<code>current Fiber树</code>，整个更新流程结束。</p>
  </div>
  <div class="theme-default-content content__default">
    <p>通过<a href="/state/mental.html">更新的心智模型</a>，我们了解到<code>更新</code>具有<code>优先级</code>。</p>
    <p>那么什么是<code>优先级</code>？<code>优先级</code>以什么为依据？如何通过<code>优先级</code>决定哪个状态应该先被更新？</p>
    <p>本节我们会详细讲解。</p>
    <h2 id="什么是优先级"><a href="#什么是优先级" class="header-anchor">#</a> 什么是优先级</h2>
    <p>在<a
        href="/preparation/idea.html#理解-响应自然">React理念一节</a>我们聊到<code>React</code>将人机交互研究的结果整合到真实的<code>UI</code>中。具体到<code>React</code>运行上这是什么意思呢？
    </p>
    <p>
      <code>状态更新</code>由<code>用户交互</code>产生，用户心里对<code>交互</code>执行顺序有个预期。<code>React</code>根据<code>人机交互研究的结果</code>中用户对<code>交互</code>的预期顺序为<code>交互</code>产生的<code>状态更新</code>赋予不同优先级。
    </p>
    <p>具体如下：</p>
    <ul>
      <li>
        <p>生命周期方法：同步执行。</p>
      </li>
      <li>
        <p>受控的用户输入：比如输入框内输入文字，同步执行。</p>
      </li>
      <li>
        <p>交互事件：比如动画，高优先级执行。</p>
      </li>
      <li>
        <p>其他：比如数据请求，低优先级执行。</p>
      </li>
    </ul>
    <h2 id="如何调度优先级"><a href="#如何调度优先级" class="header-anchor">#</a> 如何调度优先级</h2>
    <p>我们在<a href="/preparation/newConstructure.html">新的React结构一节</a>讲到，<code>React</code>通过<code>Scheduler</code>调度任务。
    </p>
    <p>具体到代码，每当需要调度任务时，<code>React</code>会调用<code>Scheduler</code>提供的方法<code>runWithPriority</code>。</p>
    <p>
      该方法接收一个<code>优先级</code>常量与一个<code>回调函数</code>作为参数。<code>回调函数</code>会以<code>优先级</code>高低为顺序排列在一个<code>定时器</code>中并在合适的时间触发。
    </p>
    <p>对于更新来讲，传递的<code>回调函数</code>一般为<a
        href="/state/prepare.html#render阶段的开始">状态更新流程概览一节</a>讲到的<code>render阶段的入口函数</code>。</p>
    <blockquote>
      <p>你可以在<a
          href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/scheduler/src/Scheduler.js#L217"
          target="_blank" rel="noopener noreferrer">==unstable_runWithPriority== 这里<span><svg
              xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px"
              viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>看到<code>runWithPriority</code>方法的定义。在<a
          href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/scheduler/src/SchedulerPriorities.js"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>看到<code>Scheduler</code>对优先级常量的定义。</p>
    </blockquote>
    <h2 id="例子"><a href="#例子" class="header-anchor">#</a> 例子</h2>
    <p>优先级最终会反映到<code>update.lane</code>变量上。当前我们只需要知道这个变量能够区分<code>Update</code>的优先级。</p>
    <p>接下来我们通过一个例子结合上一节介绍的<code>Update</code>相关字段讲解优先级如何决定更新的顺序。</p>
    <blockquote>
      <p>该例子来自<a href="https://twitter.com/acdlite/status/978412930973687808" target="_blank"
          rel="noopener noreferrer">React Core Team Andrew向网友讲解Update工作流程的推文<span><svg
              xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px"
              viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a></p>
    </blockquote> <img src="https://react.iamkasong.com/img/update-process.png" alt="优先级如何决定更新的顺序">
    <p>
      在这个例子中，有两个<code>Update</code>。我们将“关闭黑夜模式”产生的<code>Update</code>称为<code>u1</code>，输���字母“I”产生的<code>Update</code>称为<code>u2</code>。
    </p>
    <p>其中<code>u1</code>先触发并进入<code>render阶段</code>。其优先级较低，执行时间较长。此时：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code>fiber<span class="token punctuation">.</span>updateQueue <span class="token operator">=</span> <span class="token punctuation">{</span>
  baseState<span class="token operator">:</span> <span class="token punctuation">{</span>
    blackTheme<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    text<span class="token operator">:</span> <span class="token string">'H'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  firstBaseUpdate<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  lastBaseUpdate<span class="token operator">:</span> <span class="token keyword">null</span>
  shared<span class="token operator">:</span> <span class="token punctuation">{</span>
    pending<span class="token operator">:</span> u1
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  effects<span class="token operator">:</span> <span class="token keyword">null</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
    </div>
    <p>
      在<code>u1</code>完成<code>render阶段</code>前用户通过键盘输入字母“I”，产生了<code>u2</code>。<code>u2</code>属于<strong>受控的用户输入</strong>，优先级高于<code>u1</code>，于是中断<code>u1</code>产生的<code>render阶段</code>。
    </p>
    <p>此时：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code>fiber<span class="token punctuation">.</span>updateQueue<span class="token punctuation">.</span>shared<span class="token punctuation">.</span>pending <span class="token operator">===</span> u2 <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">&gt;</span> u1
                                     <span class="token operator">^</span>        <span class="token operator">|</span>
                                     <span class="token operator">|</span>________<span class="token operator">|</span>
<span class="token comment">// 即</span>
u2<span class="token punctuation">.</span>next <span class="token operator">===</span> u1<span class="token punctuation">;</span>
u1<span class="token punctuation">.</span>next <span class="token operator">===</span> u2<span class="token punctuation">;</span>
</code></pre>
    </div>
    <p>其中<code>u2</code>优先级高于<code>u1</code>。</p>
    <p>接下来进入<code>u2</code>产生的<code>render阶段</code>。</p>
    <p>在<code>processUpdateQueue</code>方法中，<code>shared.pending</code>环状链表会被剪开并拼接在<code>baseUpdate</code>后面。</p>
    <p>需要明确一点，<code>shared.pending</code>指向最后一个<code>pending</code>的<code>update</code>，所以实际执行时<code>update</code>的顺序为：
    </p>
    <div class="language-js extra-class">
      <pre class="language-js"><code>u1 <span class="token operator">--</span> u2
</code></pre>
    </div>
    <p>接下来遍历<code>baseUpdate</code>，处理优先级合适的<code>Update</code>（这一次处理的是更高优的<code>u2</code>）。</p>
    <p>由于<code>u2</code>不是<code>baseUpdate</code>中的第一个<code>update</code>，在其之前的<code>u1</code>由于优先级不够被跳过。</p>
    <p>
      <code>update</code>之间可能有依赖关系，所以被跳过的<code>update</code>及其后面所有<code>update</code>会成为下次更新的<code>baseUpdate</code>。（即<code>u1 -- u2</code>）。
    </p>
    <p>最终<code>u2</code>完成<code>render - commit阶段</code>。</p>
    <p>此时：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code>fiber<span class="token punctuation">.</span>updateQueue <span class="token operator">=</span> <span class="token punctuation">{</span>
  baseState<span class="token operator">:</span> <span class="token punctuation">{</span>
    blackTheme<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    text<span class="token operator">:</span> <span class="token string">'HI'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  firstBaseUpdate<span class="token operator">:</span> u1<span class="token punctuation">,</span>
  lastBaseUpdate<span class="token operator">:</span> u2
  shared<span class="token operator">:</span> <span class="token punctuation">{</span>
    pending<span class="token operator">:</span> <span class="token keyword">null</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  effects<span class="token operator">:</span> <span class="token keyword">null</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
    </div>
    <p>
      在<code>commit</code>阶段结尾会再调度一次更新。在该次更新中会基于<code>baseState</code>中<code>firstBaseUpdate</code>保存的<code>u1</code>，开启一次新的<code>render阶段</code>。
    </p>
    <p>最终两次<code>Update</code>都完成后的结果如下：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code>fiber<span class="token punctuation">.</span>updateQueue <span class="token operator">=</span> <span class="token punctuation">{</span>
  baseState<span class="token operator">:</span> <span class="token punctuation">{</span>
    blackTheme<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    text<span class="token operator">:</span> <span class="token string">'HI'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  firstBaseUpdate<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  lastBaseUpdate<span class="token operator">:</span> <span class="token keyword">null</span>
  shared<span class="token operator">:</span> <span class="token punctuation">{</span>
    pending<span class="token operator">:</span> <span class="token keyword">null</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  effects<span class="token operator">:</span> <span class="token keyword">null</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
    </div>
    <p>
      我们可以看见，<code>u2</code>对应的更新执行了两次，相应的<code>render阶段</code>的生命周期勾子<code>componentWillXXX</code>也会触发两次。这也是为什么这些勾子会被标记为<code>unsafe_</code>。
    </p>
    <h2 id="如何保证状态正确"><a href="#如何保证状态正确" class="header-anchor">#</a> 如何保证状态正确</h2>
    <p>现在我们基本掌握了<code>updateQueue</code>的工作流程。还有两个疑问：</p>
    <ul>
      <li>
        <p><code>render阶段</code>可能被中断。如何保证<code>updateQueue</code>中保存的<code>Update</code>不丢失？</p>
      </li>
      <li>
        <p>有时候当前<code>状态</code>需要依赖前一个<code>状态</code>。如何在支持跳过<code>低优先级状态</code>的同时保证<strong>状态依赖的连续性</strong>？</p>
      </li>
    </ul>
    <p>我们分别讲解下。</p>
    <h3 id="如何保证update不丢失"><a href="#如何保证update不丢失" class="header-anchor">#</a> 如何保证<code>Update</code>不丢失</h3>
    <p>在<a
        href="/state/update.html#例子">上一节例子</a>中我们讲到，在<code>render阶段</code>，<code>shared.pending</code>的环被剪开并连接在<code>updateQueue.lastBaseUpdate</code>后面。
    </p>
    <p>
      实际上<code>shared.pending</code>会被同时连接在<code>workInProgress updateQueue.lastBaseUpdate</code>与<code>current updateQueue.lastBaseUpdate</code>后面。
    </p>
    <blockquote>
      <p>具体代码见<a
          href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactUpdateQueue.new.js#L424"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a></p>
    </blockquote>
    <p>
      当<code>render阶段</code>被中断后重新开始时，会基于<code>current updateQueue</code>克隆出<code>workInProgress updateQueue</code>。由于<code>current updateQueue.lastBaseUpdate</code>已经保存了上一次的<code>Update</code>，所以不会丢失。
    </p>
    <p>当<code>commit阶段</code>完成渲染，由于<code>workInProgress updateQueue.lastBaseUpdate</code>中保存了上一次的<code>Update</code>，所以
      <code>workInProgress Fiber树</code>变成<code>current Fiber树</code>后也不会造成<code>Update</code>丢失。</p>
    <h3 id="如何保证状态依赖的连续性"><a href="#如何保证状态依赖的连续性" class="header-anchor">#</a> 如何保证状态依赖的连续性</h3>
    <p>
      当某个<code>Update</code>由于优先级低而被跳过时，保存在<code>baseUpdate</code>中的不仅是该<code>Update</code>，还包括链表中该<code>Update</code>之后的所有<code>Update</code>。
    </p>
    <p>考虑如下例子：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code>baseState<span class="token operator">:</span> <span class="token string">''</span>
shared<span class="token punctuation">.</span>pending<span class="token operator">:</span> <span class="token constant">A1</span> <span class="token operator">--</span><span class="token operator">&gt;</span> <span class="token constant">B2</span> <span class="token operator">--</span><span class="token operator">&gt;</span> <span class="token constant">C1</span> <span class="token operator">--</span><span class="token operator">&gt;</span> <span class="token constant">D2</span>
</code></pre>
    </div>
    <p>其中<code>字母</code>代表该<code>Update</code>要在页面插入的字母，<code>数字</code>代表<code>优先级</code>，值越低<code>优先级</code>越高。</p>
    <p>第一次<code>render</code>，<code>优先级</code>为1。</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code>baseState<span class="token operator">:</span> <span class="token string">''</span>
baseUpdate<span class="token operator">:</span> <span class="token keyword">null</span>
render阶段使用的Update<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token constant">A1</span><span class="token punctuation">,</span> <span class="token constant">C1</span><span class="token punctuation">]</span>
memoizedState<span class="token operator">:</span> <span class="token string">'AC'</span>
</code></pre>
    </div>
    <p>
      其中<code>B2</code>由于优先级为2，低于当前优先级，所以他及其后面的所有<code>Update</code>会被保存在<code>baseUpdate</code>中作为下次更新的<code>Update</code>（即<code>B2 C1 D2</code>）。
    </p>
    <p>这么做是为了保持<code>状态</code>的前后依赖顺序。</p>
    <p>第二次<code>render</code>，<code>优先级</code>为2。</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code>baseState<span class="token operator">:</span> <span class="token string">'A'</span>
baseUpdate<span class="token operator">:</span> <span class="token constant">B2</span> <span class="token operator">--</span><span class="token operator">&gt;</span> <span class="token constant">C1</span> <span class="token operator">--</span><span class="token operator">&gt;</span> <span class="token constant">D2</span>
render阶段使用的Update<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token constant">B2</span><span class="token punctuation">,</span> <span class="token constant">C1</span><span class="token punctuation">,</span> <span class="token constant">D2</span><span class="token punctuation">]</span>
memoizedState<span class="token operator">:</span> <span class="token string">'ABCD'</span>
</code></pre>
    </div>
    <p>注意这里<code>baseState</code>并不是上一次更新的<code>memoizedState</code>。这是由于<code>B2</code>被跳过了。</p>
    <p>即当有<code>Update</code>被跳过时，<code>下次更新的baseState !== 上次更新的memoizedState</code>。</p>
    <blockquote>
      <p>跳过<code>B2</code>的逻辑见<a
          href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactUpdateQueue.new.js#L479"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a></p>
    </blockquote>
    <p>通过以上例子我们可以发现，<code>React</code>保证最终的状态一定和用户触发的<code>交互</code>一致，但是中间过程<code>状态</code>可能由于设备不同而不同。</p>
    <details class="custom-block details">
      <summary>高优先级任务打断低优先级任务Demo</summary>
      <p><a href="/me.html">关注公众号</a>，后台回复<strong>815</strong>获得在线Demo地址</p>
    </details>
    <h2 id="参考资料"><a href="#参考资料" class="header-anchor">#</a> 参考资料</h2>
    <p><a href="https://juejin.im/post/5f05a3e25188252e5c576cdb" target="_blank"
        rel="noopener noreferrer">深入源码剖析componentWillXXX为什么UNSAFE<span><svg xmlns="http://www.w3.org/2000/svg"
            aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"
            class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a></p>
    <p><a
        href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactUpdateQueue.new.js#L10"
        target="_blank" rel="noopener noreferrer">React源码中讲解Update工作流程及优先级的注释<span><svg
            xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px"
            viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a></p>
    <p><a href="https://twitter.com/acdlite/status/978412930973687808" target="_blank" rel="noopener noreferrer">React
        Core Team Andrew向网友讲解Update工作流程的推文<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
            focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a></p>
  </div>
  <div class="theme-default-content content__default">
    <p>经过五章的学习，我们终于回到了<code>React</code>应用的起点。</p>
    <p>这一节我们完整的走通<code>ReactDOM.render</code>完成页面渲染的整个流程。</p>
    <h2 id="创建fiber"><a href="#创建fiber" class="header-anchor">#</a> 创建fiber</h2>
    <p>从<a
        href="/process/doubleBuffer.html#mount时">双缓存机制一节</a>我们知道，首次执行<code>ReactDOM.render</code>会创建<code>fiberRootNode</code>和<code>rootFiber</code>。其中<code>fiberRootNode</code>是整个应用的根节点，<code>rootFiber</code>是要渲染组件所在组件树的<code>根节点</code>。
    </p>
    <p>这一步发生在调用<code>ReactDOM.render</code>后进入的<code>legacyRenderSubtreeIntoContainer</code>方法中。</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token comment">// container指ReactDOM.render的第二个参数（即应用挂载的DOM节点）</span>
root <span class="token operator">=</span> container<span class="token punctuation">.</span>_reactRootContainer <span class="token operator">=</span> <span class="token function">legacyCreateRootFromDOMContainer</span><span class="token punctuation">(</span>
  container<span class="token punctuation">,</span>
  forceHydrate<span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
fiberRoot <span class="token operator">=</span> root<span class="token punctuation">.</span>_internalRoot<span class="token punctuation">;</span>
</code></pre>
    </div>
    <blockquote>
      <p>你可以从<a
          href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-dom/src/client/ReactDOMLegacy.js#L193"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>看到这一步的代码</p>
    </blockquote>
    <p>
      <code>legacyCreateRootFromDOMContainer</code>方法内部会调用<code>createFiberRoot</code>方法完成<code>fiberRootNode</code>和<code>rootFiber</code>的创建以及关联。并初始化<code>updateQueue</code>。
    </p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">createFiberRoot</span><span class="token punctuation">(</span>
  <span class="token parameter">containerInfo<span class="token operator">:</span> any<span class="token punctuation">,</span>
  tag<span class="token operator">:</span> RootTag<span class="token punctuation">,</span>
  hydrate<span class="token operator">:</span> boolean<span class="token punctuation">,</span>
  hydrationCallbacks<span class="token operator">:</span> <span class="token keyword">null</span> <span class="token operator">|</span> SuspenseHydrationCallbacks<span class="token punctuation">,</span></span>
<span class="token punctuation">)</span><span class="token operator">:</span> FiberRoot <span class="token punctuation">{</span>
  <span class="token comment">// 创建fiberRootNode</span>
  <span class="token keyword">const</span> root<span class="token operator">:</span> FiberRoot <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FiberRootNode</span><span class="token punctuation">(</span>containerInfo<span class="token punctuation">,</span> tag<span class="token punctuation">,</span> hydrate<span class="token punctuation">)</span><span class="token operator">:</span> any<span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token comment">// 创建rootFiber</span>
  <span class="token keyword">const</span> uninitializedFiber <span class="token operator">=</span> <span class="token function">createHostRootFiber</span><span class="token punctuation">(</span>tag<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 连接rootFiber与fiberRootNode</span>
  root<span class="token punctuation">.</span>current <span class="token operator">=</span> uninitializedFiber<span class="token punctuation">;</span>
  uninitializedFiber<span class="token punctuation">.</span>stateNode <span class="token operator">=</span> root<span class="token punctuation">;</span>

  <span class="token comment">// 初始化updateQueue</span>
  <span class="token function">initializeUpdateQueue</span><span class="token punctuation">(</span>uninitializedFiber<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> root<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <p>根据以上代码，现在我们可以在<a
        href="/process/doubleBuffer.html#mount时">双缓存机制一节</a>基础上补充上<code>rootFiber</code>到<code>fiberRootNode</code>的引用。
    </p> <img src="https://react.iamkasong.com/img/fiberroot.png" alt="fiberRoot">
    <blockquote>
      <p>你可以从<a
          href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberRoot.new.js#L97"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>看到这一步的代码</p>
    </blockquote>
    <h2 id="创建update"><a href="#创建update" class="header-anchor">#</a> 创建update</h2>
    <p>我们已经做好了组件的初始化工作，接下来就等待创建<code>Update</code>来开启一次更新。</p>
    <p>这一步发生在<code>updateContainer</code>方法中。</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">updateContainer</span><span class="token punctuation">(</span>
  <span class="token parameter">element<span class="token operator">:</span> ReactNodeList<span class="token punctuation">,</span>
  container<span class="token operator">:</span> OpaqueRoot<span class="token punctuation">,</span>
  parentComponent<span class="token operator">:</span> <span class="token operator">?</span>React$Component<span class="token operator">&lt;</span>any<span class="token punctuation">,</span> any<span class="token operator">&gt;</span><span class="token punctuation">,</span>
  callback<span class="token operator">:</span> <span class="token operator">?</span>Function<span class="token punctuation">,</span></span>
<span class="token punctuation">)</span><span class="token operator">:</span> Lane <span class="token punctuation">{</span>
  <span class="token comment">// ...省略与逻辑不相关代码</span>

  <span class="token comment">// 创建update</span>
  <span class="token keyword">const</span> update <span class="token operator">=</span> <span class="token function">createUpdate</span><span class="token punctuation">(</span>eventTime<span class="token punctuation">,</span> lane<span class="token punctuation">,</span> suspenseConfig<span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token comment">// update.payload为需要挂载在根节点的组件</span>
  update<span class="token punctuation">.</span>payload <span class="token operator">=</span> <span class="token punctuation">{</span>element<span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token comment">// callback为ReactDOM.render的第三个参数 —— 回调函数</span>
  callback <span class="token operator">=</span> callback <span class="token operator">===</span> <span class="token keyword">undefined</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> callback<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>callback <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    update<span class="token punctuation">.</span>callback <span class="token operator">=</span> callback<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 将生成的update加入updateQueue</span>
  <span class="token function">enqueueUpdate</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> update<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 调度更新</span>
  <span class="token function">scheduleUpdateOnFiber</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> lane<span class="token punctuation">,</span> eventTime<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// ...省略与逻辑不相关代码</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <blockquote>
      <p>你可以从<a
          href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberReconciler.new.js#L255"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>看到<code>updateContainer</code>的代码</p>
    </blockquote>
    <p>值得注意的是其中<code>update.payload = {element};</code></p>
    <p>这就是我们在<a
        href="/state/update.html#update的结构">Update一节</a>介绍的，对于<code>HostRoot</code>，<code>payload</code>为<code>ReactDOM.render</code>的第一个传参。
    </p>
    <h2 id="流程概览"><a href="#流程概览" class="header-anchor">#</a> 流程概览</h2>
    <p>至此，<code>ReactDOM.render</code>的流程就和我们已知的流程连接上了。</p>
    <p>整个流程如下：</p>
    <div class="language-sh extra-class">
      <pre class="language-sh"><code>创建fiberRootNode、rootFiber、updateQueue（<span class="token variable"><span class="token variable">`</span>legacyCreateRootFromDOMContainer<span class="token variable">`</span></span>）

    <span class="token operator">|</span>
    <span class="token operator">|</span>
    <span class="token function">v</span>

创建Update对象（<span class="token variable"><span class="token variable">`</span>updateContainer<span class="token variable">`</span></span>）

    <span class="token operator">|</span>
    <span class="token operator">|</span>
    <span class="token function">v</span>

从fiber到root（<span class="token variable"><span class="token variable">`</span>markUpdateLaneFromFiberToRoot<span class="token variable">`</span></span>）

    <span class="token operator">|</span>
    <span class="token operator">|</span>
    <span class="token function">v</span>

调度更新（<span class="token variable"><span class="token variable">`</span>ensureRootIsScheduled<span class="token variable">`</span></span>）

    <span class="token operator">|</span>
    <span class="token operator">|</span>
    <span class="token function">v</span>

render阶段（<span class="token variable"><span class="token variable">`</span>performSyncWorkOnRoot<span class="token variable">`</span></span> 或 <span class="token variable"><span class="token variable">`</span>performConcurrentWorkOnRoot<span class="token variable">`</span></span>）

    <span class="token operator">|</span>
    <span class="token operator">|</span>
    <span class="token function">v</span>

commit阶段（<span class="token variable"><span class="token variable">`</span>commitRoot<span class="token variable">`</span></span>）
</code></pre>
    </div>
    <h2 id="react的其他入口函数"><a href="#react的其他入口函数" class="header-anchor">#</a> React的其他入口函数</h2>
    <p>当前<code>React</code>共有三种模式：</p>
    <ul>
      <li>
        <p><code>legacy</code>，这是当前<code>React</code>使用的方式。当前没有计划删除本模式，但是这个模式可能不支持一些新功能。</p>
      </li>
      <li>
        <p><code>blocking</code>，开启部分<code>concurrent</code>模式特性的中间模式。目前正在实验中。作为迁移到<code>concurrent</code>模式的第一个步骤。</p>
      </li>
      <li>
        <p><code>concurrent</code>，面向未来的开发模式。我们之前讲的<code>任务中断/任务优先级</code>都是针对<code>concurrent</code>模式。</p>
      </li>
    </ul>
    <p>你可以从下表看出各种模式对特性的支持：</p>
    <table>
      <thead>
        <tr>
          <th></th>
          <th>legacy 模式</th>
          <th>blocking 模式</th>
          <th>concurrent 模式</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><a href="https://zh-hans.reactjs.org/docs/refs-and-the-dom.html#legacy-api-string-refs" target="_blank"
              rel="noopener noreferrer">String Refs<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
                  focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
                  <path fill="currentColor"
                    d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
                  </path>
                  <polygon fill="currentColor"
                    points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
                  </polygon>
                </svg> <span class="sr-only">(opens new window)</span></span></a></td>
          <td>✅</td>
          <td>🚫**</td>
          <td>🚫**</td>
        </tr>
        <tr>
          <td><a href="https://zh-hans.reactjs.org/docs/legacy-context.html" target="_blank"
              rel="noopener noreferrer">Legacy Context<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
                  focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
                  <path fill="currentColor"
                    d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
                  </path>
                  <polygon fill="currentColor"
                    points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
                  </polygon>
                </svg> <span class="sr-only">(opens new window)</span></span></a></td>
          <td>✅</td>
          <td>🚫**</td>
          <td>🚫**</td>
        </tr>
        <tr>
          <td><a href="https://zh-hans.reactjs.org/docs/strict-mode.html#warning-about-deprecated-finddomnode-usage"
              target="_blank" rel="noopener noreferrer">findDOMNode<span><svg xmlns="http://www.w3.org/2000/svg"
                  aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"
                  class="icon outbound">
                  <path fill="currentColor"
                    d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
                  </path>
                  <polygon fill="currentColor"
                    points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
                  </polygon>
                </svg> <span class="sr-only">(opens new window)</span></span></a></td>
          <td>✅</td>
          <td>🚫**</td>
          <td>🚫**</td>
        </tr>
        <tr>
          <td><a href="https://zh-hans.reactjs.org/docs/concurrent-mode-suspense.html#what-is-suspense-exactly"
              target="_blank" rel="noopener noreferrer">Suspense<span><svg xmlns="http://www.w3.org/2000/svg"
                  aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"
                  class="icon outbound">
                  <path fill="currentColor"
                    d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
                  </path>
                  <polygon fill="currentColor"
                    points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
                  </polygon>
                </svg> <span class="sr-only">(opens new window)</span></span></a></td>
          <td>✅</td>
          <td>✅</td>
          <td>✅</td>
        </tr>
        <tr>
          <td><a href="https://zh-hans.reactjs.org/docs/concurrent-mode-patterns.html#suspenselist" target="_blank"
              rel="noopener noreferrer">SuspenseList<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
                  focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
                  <path fill="currentColor"
                    d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
                  </path>
                  <polygon fill="currentColor"
                    points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
                  </polygon>
                </svg> <span class="sr-only">(opens new window)</span></span></a></td>
          <td>🚫</td>
          <td>✅</td>
          <td>✅</td>
        </tr>
        <tr>
          <td>Suspense SSR + Hydration</td>
          <td>🚫</td>
          <td>✅</td>
          <td>✅</td>
        </tr>
        <tr>
          <td>Progressive Hydration</td>
          <td>🚫</td>
          <td>✅</td>
          <td>✅</td>
        </tr>
        <tr>
          <td>Selective Hydration</td>
          <td>🚫</td>
          <td>🚫</td>
          <td>✅</td>
        </tr>
        <tr>
          <td>Cooperative Multitasking</td>
          <td>🚫</td>
          <td>🚫</td>
          <td>✅</td>
        </tr>
        <tr>
          <td>Automatic batching of multiple setStates</td>
          <td>🚫*</td>
          <td>✅</td>
          <td>✅</td>
        </tr>
        <tr>
          <td><a
              href="https://zh-hans.reactjs.org/docs/concurrent-mode-patterns.html#splitting-high-and-low-priority-state"
              target="_blank" rel="noopener noreferrer">Priority-based Rendering<span><svg
                  xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px"
                  viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
                  <path fill="currentColor"
                    d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
                  </path>
                  <polygon fill="currentColor"
                    points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
                  </polygon>
                </svg> <span class="sr-only">(opens new window)</span></span></a></td>
          <td>🚫</td>
          <td>🚫</td>
          <td>✅</td>
        </tr>
        <tr>
          <td><a href="https://zh-hans.reactjs.org/docs/concurrent-mode-intro.html#interruptible-rendering"
              target="_blank" rel="noopener noreferrer">Interruptible Prerendering<span><svg
                  xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px"
                  viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
                  <path fill="currentColor"
                    d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
                  </path>
                  <polygon fill="currentColor"
                    points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
                  </polygon>
                </svg> <span class="sr-only">(opens new window)</span></span></a></td>
          <td>🚫</td>
          <td>🚫</td>
          <td>✅</td>
        </tr>
        <tr>
          <td><a href="https://zh-hans.reactjs.org/docs/concurrent-mode-patterns.html#transitions" target="_blank"
              rel="noopener noreferrer">useTransition<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
                  focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
                  <path fill="currentColor"
                    d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
                  </path>
                  <polygon fill="currentColor"
                    points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
                  </polygon>
                </svg> <span class="sr-only">(opens new window)</span></span></a></td>
          <td>🚫</td>
          <td>🚫</td>
          <td>✅</td>
        </tr>
        <tr>
          <td><a href="https://zh-hans.reactjs.org/docs/concurrent-mode-patterns.html#deferring-a-value" target="_blank"
              rel="noopener noreferrer">useDeferredValue<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
                  focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
                  <path fill="currentColor"
                    d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
                  </path>
                  <polygon fill="currentColor"
                    points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
                  </polygon>
                </svg> <span class="sr-only">(opens new window)</span></span></a></td>
          <td>🚫</td>
          <td>🚫</td>
          <td>✅</td>
        </tr>
        <tr>
          <td><a href="https://zh-hans.reactjs.org/docs/concurrent-mode-patterns.html#suspense-reveal-train"
              target="_blank" rel="noopener noreferrer">Suspense Reveal "Train"<span><svg
                  xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px"
                  viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
                  <path fill="currentColor"
                    d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
                  </path>
                  <polygon fill="currentColor"
                    points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
                  </polygon>
                </svg> <span class="sr-only">(opens new window)</span></span></a></td>
          <td>🚫</td>
          <td>🚫</td>
          <td>✅</td>
        </tr>
      </tbody>
    </table>
    <p>*：<code>legacy</code>模式在合成事件中有自动批处理的功能，但仅限于一个浏览器任务。非<code>React</code>事件想使用这个功能必须使用
      <code>unstable_batchedUpdates</code>。在<code>blocking</code>模式和<code>concurrent</code>模式下，所有的<code>setState</code>在默认情况下都是批处理的。
    </p>
    <p>**：会在开发中发出警告。</p>
    <p>模式的变化影响整个应用的工作方式，所以无法只针对某个组件开启不同模式。</p>
    <p>基于此原因，可以通过不同的<code>入口函数</code>开启不同模式：</p>
    <ul>
      <li><code>legacy</code> -- <code>ReactDOM.render(&lt;App /&gt;, rootNode)</code></li>
      <li><code>blocking</code> -- <code>ReactDOM.createBlockingRoot(rootNode).render(&lt;App /&gt;)</code></li>
      <li><code>concurrent</code> -- <code>ReactDOM.createRoot(rootNode).render(&lt;App /&gt;)</code></li>
    </ul>
    <blockquote>
      <p>你可以在<a href="https://zh-hans.reactjs.org/docs/concurrent-mode-adoption.html#why-so-many-modes" target="_blank"
          rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false"
              x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>看到<code>React</code>团队解释为什么会有这么多模式</p>
    </blockquote>
    <p>虽然不同模式的<code>入口函数</code>不同，但是他们仅对<code>fiber.mode</code>变量产生影响，对我们在<a
        href="/state/reactdom.html#流程概览">流程概览</a>中描述的流程并无影响。</p>
  </div>
  <div class="theme-default-content content__default">
    <p>当我们有了前面知识的铺垫，就很容易理解<code>this.setState</code>的工作流程。</p>
    <h2 id="流程概览"><a href="#流程概览" class="header-anchor">#</a> 流程概览</h2>
    <p>可以看到，<code>this.setState</code>内会调用<code>this.updater.enqueueSetState</code>方法。</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token class-name">Component</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">setState</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">partialState<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> partialState <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">||</span> <span class="token keyword">typeof</span> partialState <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">||</span> partialState <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">{</span>
      <span class="token keyword">throw</span> <span class="token function">Error</span><span class="token punctuation">(</span> <span class="token string">"setState(...): takes an object of state variables to update or a function which returns an object of state variables."</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>updater<span class="token punctuation">.</span><span class="token function">enqueueSetState</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> partialState<span class="token punctuation">,</span> callback<span class="token punctuation">,</span> <span class="token string">'setState'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
    </div>
    <blockquote>
      <p>你可以在<a
          href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react/src/ReactBaseClasses.js#L57"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>看到这段代码</p>
    </blockquote>
    <p>在<code>enqueueSetState</code>方法中就是我们熟悉的从<code>创建update</code>到<code>调度update</code>的流程了。</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token function">enqueueSetState</span><span class="token punctuation">(</span><span class="token parameter">inst<span class="token punctuation">,</span> payload<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 通过组件实例获取对应fiber</span>
  <span class="token keyword">const</span> fiber <span class="token operator">=</span> <span class="token function">getInstance</span><span class="token punctuation">(</span>inst<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">const</span> eventTime <span class="token operator">=</span> <span class="token function">requestEventTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> suspenseConfig <span class="token operator">=</span> <span class="token function">requestCurrentSuspenseConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 获取优先级</span>
  <span class="token keyword">const</span> lane <span class="token operator">=</span> <span class="token function">requestUpdateLane</span><span class="token punctuation">(</span>fiber<span class="token punctuation">,</span> suspenseConfig<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 创建update</span>
  <span class="token keyword">const</span> update <span class="token operator">=</span> <span class="token function">createUpdate</span><span class="token punctuation">(</span>eventTime<span class="token punctuation">,</span> lane<span class="token punctuation">,</span> suspenseConfig<span class="token punctuation">)</span><span class="token punctuation">;</span>

  update<span class="token punctuation">.</span>payload <span class="token operator">=</span> payload<span class="token punctuation">;</span>

  <span class="token comment">// 赋值回调函数</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>callback <span class="token operator">!==</span> <span class="token keyword">undefined</span> <span class="token operator">&amp;&amp;</span> callback <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    update<span class="token punctuation">.</span>callback <span class="token operator">=</span> callback<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 将update插入updateQueue</span>
  <span class="token function">enqueueUpdate</span><span class="token punctuation">(</span>fiber<span class="token punctuation">,</span> update<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 调度update</span>
  <span class="token function">scheduleUpdateOnFiber</span><span class="token punctuation">(</span>fiber<span class="token punctuation">,</span> lane<span class="token punctuation">,</span> eventTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <blockquote>
      <p>你可以在<a
          href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberClassComponent.old.js#L196"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>看到<code>enqueueSetState</code>代码</p>
    </blockquote>
    <p>
      这里值得注意的是对于<code>ClassComponent</code>，<code>update.payload</code>为<code>this.setState</code>的第一个传参（即要改变的<code>state</code>）。
    </p>
    <h2 id="this-forceupdate"><a href="#this-forceupdate" class="header-anchor">#</a> this.forceUpdate</h2>
    <p>
      在<code>this.updater</code>上，除了<code>enqueueSetState</code>外，还存在<code>enqueueForceUpdate</code>，当我们调用<code>this.forceUpdate</code>时会调用他。
    </p>
    <p>可以看到，除了赋值<code>update.tag = ForceUpdate;</code>以及没有<code>payload</code>外，其他逻辑与<code>this.setState</code>一致。</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token function">enqueueForceUpdate</span><span class="token punctuation">(</span><span class="token parameter">inst<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> fiber <span class="token operator">=</span> <span class="token function">getInstance</span><span class="token punctuation">(</span>inst<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> eventTime <span class="token operator">=</span> <span class="token function">requestEventTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> suspenseConfig <span class="token operator">=</span> <span class="token function">requestCurrentSuspenseConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> lane <span class="token operator">=</span> <span class="token function">requestUpdateLane</span><span class="token punctuation">(</span>fiber<span class="token punctuation">,</span> suspenseConfig<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">const</span> update <span class="token operator">=</span> <span class="token function">createUpdate</span><span class="token punctuation">(</span>eventTime<span class="token punctuation">,</span> lane<span class="token punctuation">,</span> suspenseConfig<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 赋值tag为ForceUpdate</span>
    update<span class="token punctuation">.</span>tag <span class="token operator">=</span> ForceUpdate<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>callback <span class="token operator">!==</span> <span class="token keyword">undefined</span> <span class="token operator">&amp;&amp;</span> callback <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      update<span class="token punctuation">.</span>callback <span class="token operator">=</span> callback<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">enqueueUpdate</span><span class="token punctuation">(</span>fiber<span class="token punctuation">,</span> update<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">scheduleUpdateOnFiber</span><span class="token punctuation">(</span>fiber<span class="token punctuation">,</span> lane<span class="token punctuation">,</span> eventTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
    </div>
    <blockquote>
      <p>你可以在<a
          href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberClassComponent.old.js#L260"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>看到<code>enqueueForceUpdate</code>代码</p>
    </blockquote>
    <p>那么赋值<code>update.tag = ForceUpdate;</code>有何作用呢？</p>
    <p>在判断<code>ClassComponent</code>是否需要更新时有两个条件需要满足：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code> <span class="token keyword">const</span> shouldUpdate <span class="token operator">=</span>
  <span class="token function">checkHasForceUpdateAfterProcessing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span>
  <span class="token function">checkShouldComponentUpdate</span><span class="token punctuation">(</span>
    workInProgress<span class="token punctuation">,</span>
    ctor<span class="token punctuation">,</span>
    oldProps<span class="token punctuation">,</span>
    newProps<span class="token punctuation">,</span>
    oldState<span class="token punctuation">,</span>
    newState<span class="token punctuation">,</span>
    nextContext<span class="token punctuation">,</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    </div>
    <blockquote>
      <p>你可以在<a
          href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberClassComponent.old.js#L1137"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>看到这段代码</p>
    </blockquote>
    <ul>
      <li>
        <p>
          checkHasForceUpdateAfterProcessing：内部会判断本次更新的<code>Update</code>是否为<code>ForceUpdate</code>。即如果本次更新的<code>Update</code>中存在<code>tag</code>为<code>ForceUpdate</code>，则返回<code>true</code>。
        </p>
      </li>
      <li>
        <p>
          checkShouldComponentUpdate：内部会调用<code>shouldComponentUpdate</code>方法。以及当该<code>ClassComponent</code>为<code>PureComponent</code>时会浅比较<code>state</code>与<code>props</code>。
        </p>
      </li>
    </ul>
    <blockquote>
      <p>你可以在<a
          href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberClassComponent.old.js#L294"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>看到<code>checkShouldComponentUpdate</code>代码
      </p>
    </blockquote>
    <p>
      所以，当某次更新含有<code>tag</code>为<code>ForceUpdate</code>的<code>Update</code>，那么当前<code>ClassComponent</code>不会受其他<code>性能优化手段</code>（<code>shouldComponentUpdate</code>|<code>PureComponent</code>）影响，一定会更新。
    </p>
    <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2>
    <p>至此，我们学习完了<code>HostRoot | ClassComponent</code>所使用的<code>Update</code>的更新流程。</p>
    <p>在下一章我们会学习另一种数据结构的<code>Update</code> —— 用于<code>Hooks</code>的<code>Update</code>。</p>
  </div>
  <div class="theme-default-content content__default">
    <div class="custom-block warning">
      <p class="custom-block-title">注意</p>
      <p>在开始本章学习前，你需要了解<code>Hooks</code>的基本用法。</p>
      <p>如果你还未使用过<code>Hooks</code>，可以从<a href="https://zh-hans.reactjs.org/docs/hooks-intro.html" target="_blank"
          rel="noopener noreferrer">官方文档<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>开始。</p>
    </div>
    <p>你可以从<a href="https://zh-hans.reactjs.org/docs/hooks-intro.html#motivation" target="_blank"
        rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false"
            x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new
            window)</span></span></a>了解<code>Hooks</code>的设计动机。作为一名<code>框架使用者</code>，了解<code>设计动机</code>对于我们日常开发就足够了。
    </p>
    <p>
      但是，为了更好的理解<code>Hooks</code>的<code>源码架构</code>，我们需要转换身份，以<code>框架开发者</code>的角度来看待<code>Hooks</code>的<code>设计理念</code>。
    </p>
    <h2 id="从logo聊起"><a href="#从logo聊起" class="header-anchor">#</a> 从LOGO聊起</h2> <img
      src="https://react.iamkasong.com/img/logo.png" alt="LOGO">
    <p><code>React</code>
      <code>LOGO</code>的图案是代表<code>原子</code>（<code>atom</code>）的符号。世间万物由<code>原子</code>组成，<code>原子</code>的<code>类型</code>与<code>属性</code>决定了事物的外观与表现。
    </p>
    <p>
      同样，在<code>React</code>中，我们可以将<code>UI</code>拆分为很多独立的单元，每个单元被称为<code>Component</code>。这些<code>Component</code>的<code>属性</code>与<code>类型</code>决定了<code>UI</code>的外观与表现。
    </p>
    <p>讽刺的是，<code>原子</code>在希腊语中的意思为<code>不可分割的</code>（<code>indivisible</code>），但随后科学家在原子中发现了更小的粒子 ——
      电子（<code>electron</code>）。电子可以很好的解释<code>原子</code>是如何工作的。</p>
    <p>在<code>React</code>中，我们可以说<code>ClassComponent</code>是一类<code>原子</code>。</p>
    <p>但对于<code>Hooks</code>来说，与其说是一类<code>原子</code>，不如说他是更贴近事物<code>运行规律</code>的<code>电子</code>。</p>
    <p>
      我们知道，<code>React</code>的架构遵循<code>schedule - render - commit</code>的运行流程，这个流程是<code>React</code>世界最底层的<code>运行规律</code>。
    </p>
    <p>
      <code>ClassComponent</code>作为<code>React</code>世界的<code>原子</code>，他的<code>生命周期</code>（<code>componentWillXXX</code>/<code>componentDidXXX</code>）是为了介入<code>React</code>的运行流程而实现的更上层抽象，这么做是为了方便<code>框架使用者</code>更容易上手。
    </p>
    <p>相比于<code>ClassComponent</code>的更上层抽象，<code>Hooks</code>则更贴近<code>React</code>内部运行的各种概念（<code>state</code> |
      <code>context</code> | <code>life-cycle</code>）。</p>
    <p>
      作为使用<code>React</code>技术栈的开发者，当我们初次学习<code>Hooks</code>时，不管是官方文档还是身边有经验的同事，总会拿<code>ClassComponent</code>的生命周期来类比<code>Hooks API</code>的执行时机。
    </p>
    <p>这固然是很好的上手方式，但是当我们熟练运用<code>Hooks</code>时，就会发现，这两者的概念有很多割裂感，并不是同一抽象层次可以互相替代的概念。</p>
    <p>比如：替代<code>componentWillReceiveProps</code>的<code>Hooks</code>是什么呢？</p>
    <p>可能有些同学会回答，是<code>useEffect</code>：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code>  <span class="token function">useEffect</span><span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'something updated'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>props<span class="token punctuation">.</span>something<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre>
    </div>
    <p>
      但是<code>componentWillReceiveProps</code>是在<code>render阶段</code>执行，而<code>useEffect</code>是在<code>commit阶段</code>完成渲染后异步执行。
    </p>
    <blockquote>
      <p>这篇文章可以帮你更好理解<code>componentWillReceiveProps</code>：<a href="https://juejin.im/post/5f05a3e25188252e5c576cdb"
          target="_blank" rel="noopener noreferrer">深入源码剖析componentWillXXX为什么UNSAFE<span><svg
              xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px"
              viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a></p>
    </blockquote>
    <p>
      所以，从源码运行规律的角度看待<code>Hooks</code>，可能是更好的角度。这也是为什么上文说<code>Hooks</code>是<code>React</code>世界的<code>电子</code>而不是<code>原子</code>的原因。
    </p>
    <blockquote>
      <p>以上见解参考自<a href="https://www.youtube.com/watch?v=dpw9EHDh2bM&amp;feature=youtu.be" target="_blank"
          rel="noopener noreferrer">React Core Team Dan在 React Conf2018的演讲<span><svg xmlns="http://www.w3.org/2000/svg"
              aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"
              class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a></p>
    </blockquote>
    <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2>
    <p>
      <code>Concurrent Mode</code>是<code>React</code>未来的发展方向，而<code>Hooks</code>是能够最大限度发挥<code>Concurrent Mode</code>潜力的<code>Component</code>构建方式。
    </p>
    <p>
      正如Dan在<code>React Conf 2018</code>演讲结尾所说：你可以从<code>React</code>的<code>LOGO</code>中看到这些围绕着<code>核心</code>的<code>电子飞行轨道</code>，<code>Hooks</code>可能一直就在其中。
    </p>
  </div>
  <div class="theme-default-content content__default">
    <p>
      为了更好理解<code>Hooks</code>原理，这一节我们遵循<code>React</code>的运行流程，实现一个不到100行代码的极简<code>useState Hook</code>。建议对照着代码来看本节内容。
    </p>
    <h2 id="工作原理"><a href="#工作原理" class="header-anchor">#</a> 工作原理</h2>
    <p>对于<code>useState Hook</code>，考虑如下例子：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>num<span class="token punctuation">,</span> updateNum<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token operator">&lt;</span>p onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">updateNum</span><span class="token punctuation">(</span><span class="token parameter">num</span> <span class="token operator">=&gt;</span> num <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>num<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <p>可以将工作分为两部分：</p>
    <ol>
      <li>
        <p>通过一些途径产生<code>更新</code>，<code>更新</code>会造成组件<code>render</code>。</p>
      </li>
      <li>
        <p>组件<code>render</code>时<code>useState</code>返回的<code>num</code>为更新后的结果。</p>
      </li>
    </ol>
    <p>其中<code>步骤1</code>的<code>更新</code>可以分为<code>mount</code>和<code>update</code>：</p>
    <ol>
      <li>
        <p>
          调用<code>ReactDOM.render</code>会产生<code>mount</code>的<code>更新</code>，<code>更新</code>内容为<code>useState</code>的<code>initialValue</code>（即<code>0</code>）。
        </p>
      </li>
      <li>
        <p>
          点击<code>p</code>标签触发<code>updateNum</code>会产生一次<code>update</code>的<code>更新</code>，<code>更新</code>内容为<code>num =&gt; num + 1</code>。
        </p>
      </li>
    </ol>
    <p>接下来讲解这两个步骤如何实现。</p>
    <h2 id="更新是什么"><a href="#更新是什么" class="header-anchor">#</a> 更新是什么</h2>
    <blockquote>
      <ol>
        <li>通过一些途径产生<code>更新</code>，<code>更新</code>会造成组件<code>render</code>。</li>
      </ol>
    </blockquote>
    <p>首先我们要明确<code>更新</code>是什么。</p>
    <p>在我们的极简例子中，<code>更新</code>就是如下数据结构：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">const</span> update <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// 更新执行的函数</span>
  action<span class="token punctuation">,</span>
  <span class="token comment">// 与同一个Hook的其他更新形成链表</span>
  next<span class="token operator">:</span> <span class="token keyword">null</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <p>对于<code>App</code>来说，点击<code>p</code>标签产生的<code>update</code>的<code>action</code>为<code>num =&gt; num + 1</code>。
    </p>
    <p>如果我们改写下<code>App</code>的<code>onClick</code>：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token comment">// 之前</span>
<span class="token keyword">return</span> <span class="token operator">&lt;</span>p onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">updateNum</span><span class="token punctuation">(</span><span class="token parameter">num</span> <span class="token operator">=&gt;</span> num <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>num<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span><span class="token punctuation">;</span>

<span class="token comment">// 之后</span>
<span class="token keyword">return</span> <span class="token operator">&lt;</span>p onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">updateNum</span><span class="token punctuation">(</span><span class="token parameter">num</span> <span class="token operator">=&gt;</span> num <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">updateNum</span><span class="token punctuation">(</span><span class="token parameter">num</span> <span class="token operator">=&gt;</span> num <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">updateNum</span><span class="token punctuation">(</span><span class="token parameter">num</span> <span class="token operator">=&gt;</span> num <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>num<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span><span class="token punctuation">;</span>
</code></pre>
    </div>
    <p>那么点击<code>p</code>标签会产生三个<code>update</code>。</p>
    <h2 id="update数据结构"><a href="#update数据结构" class="header-anchor">#</a> update数据结构</h2>
    <p>这些<code>update</code>是如何组合在一起呢？</p>
    <p>答案是：他们会形成<code>环状单向链表</code>。</p>
    <p>调用<code>updateNum</code>实际调用的是<code>dispatchAction.bind(null, hook.queue)</code>，我们先来了解下这个函数：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">dispatchAction</span><span class="token punctuation">(</span><span class="token parameter">queue<span class="token punctuation">,</span> action</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 创建update</span>
  <span class="token keyword">const</span> update <span class="token operator">=</span> <span class="token punctuation">{</span>
    action<span class="token punctuation">,</span>
    next<span class="token operator">:</span> <span class="token keyword">null</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 环状单向链表操作</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>queue<span class="token punctuation">.</span>pending <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    update<span class="token punctuation">.</span>next <span class="token operator">=</span> update<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    update<span class="token punctuation">.</span>next <span class="token operator">=</span> queue<span class="token punctuation">.</span>pending<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    queue<span class="token punctuation">.</span>pending<span class="token punctuation">.</span>next <span class="token operator">=</span> update<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  queue<span class="token punctuation">.</span>pending <span class="token operator">=</span> update<span class="token punctuation">;</span>

  <span class="token comment">// 模拟React开始调度更新</span>
  <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <p>环状链表操作不太容易理解，这里我们详细讲解下。</p>
    <p>当产生第一个<code>update</code>（我们叫他<code>u0</code>），此时<code>queue.pending === null</code>。</p>
    <p><code>update.next = update;</code>即<code>u0.next = u0</code>，他会和自己首尾相连形成<code>单向环状链表</code>。</p>
    <p>然后<code>queue.pending = update;</code>即<code>queue.pending = u0</code></p>
    <div class="language-js extra-class">
      <pre class="language-js"><code>queue<span class="token punctuation">.</span>pending <span class="token operator">=</span> u0 <span class="token operator">--</span><span class="token operator">-</span><span class="token operator">&gt;</span> u0
                <span class="token operator">^</span>       <span class="token operator">|</span>
                <span class="token operator">|</span>       <span class="token operator">|</span>
                <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>
</code></pre>
    </div>
    <p>
      当产生第二个<code>update</code>（我们叫他<code>u1</code>），<code>update.next = queue.pending.next;</code>，此时<code>queue.pending.next === u0</code>，
      即<code>u1.next = u0</code>。</p>
    <p><code>queue.pending.next = update;</code>，即<code>u0.next = u1</code>。</p>
    <p>然后<code>queue.pending = update;</code>即<code>queue.pending = u1</code></p>
    <div class="language-js extra-class">
      <pre class="language-js"><code>queue<span class="token punctuation">.</span>pending <span class="token operator">=</span> u1 <span class="token operator">--</span><span class="token operator">-</span><span class="token operator">&gt;</span> u0   
                <span class="token operator">^</span>       <span class="token operator">|</span>
                <span class="token operator">|</span>       <span class="token operator">|</span>
                <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>
</code></pre>
    </div>
    <p>你可以照着这个例子模拟插入多个<code>update</code>的情况，会发现<code>queue.pending</code>始终指向最后一个插入的<code>update</code>。</p>
    <p>这样做的好处是，当我们要遍历<code>update</code>时，<code>queue.pending.next</code>指向第一个插入的<code>update</code>。</p>
    <h2 id="状态如何保存"><a href="#状态如何保存" class="header-anchor">#</a> 状态如何保存</h2>
    <p>现在我们知道，<code>更新</code>产生的<code>update</code>对象会保存在<code>queue</code>中。</p>
    <p>不同于<code>ClassComponent</code>的实例可以存储数据，对于<code>FunctionComponent</code>，<code>queue</code>存储在哪里呢？</p>
    <p>答案是：<code>FunctionComponent</code>对应的<code>fiber</code>中。</p>
    <p>我们使用如下精简的<code>fiber</code>结构：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token comment">// App组件对应的fiber对象</span>
<span class="token keyword">const</span> fiber <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// 保存该FunctionComponent对应的Hooks链表</span>
  memoizedState<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token comment">// 指向App函数</span>
  stateNode<span class="token operator">:</span> App
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
    </div>
    <h2 id="hook数据结构"><a href="#hook数据结构" class="header-anchor">#</a> Hook数据结构</h2>
    <p>接下来我们关注<code>fiber.memoizedState</code>中保存的<code>Hook</code>的数据结构。</p>
    <p>
      可以看到，<code>Hook</code>与<code>update</code>类似，都通过<code>链表</code>连接。不过<code>Hook</code>是<code>无环</code>的<code>单向链表</code>。
    </p>
    <div class="language-js extra-class">
      <pre class="language-js"><code>hook <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// 保存update的queue，即上文介绍的queue</span>
  queue<span class="token operator">:</span> <span class="token punctuation">{</span>
    pending<span class="token operator">:</span> <span class="token keyword">null</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token comment">// 保存hook对应的state</span>
  memoizedState<span class="token operator">:</span> initialState<span class="token punctuation">,</span>
  <span class="token comment">// 与下一个Hook连接形成单向无环链表</span>
  next<span class="token operator">:</span> <span class="token keyword">null</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <div class="custom-block warning">
      <p class="custom-block-title">注意</p>
      <p>注意区分<code>update</code>与<code>hook</code>的所属关系：</p>
      <p>每个<code>useState</code>对应一个<code>hook</code>对象。</p>
      <p>
        调用<code>const [num, updateNum] = useState(0);</code>时<code>updateNum</code>（即上文介绍的<code>dispatchAction</code>）产生的<code>update</code>保存在<code>useState</code>对应的<code>hook.queue</code>中。
      </p>
    </div>
    <h2 id="模拟react调度更新流程"><a href="#模拟react调度更新流程" class="header-anchor">#</a> 模拟React调度更新流程</h2>
    <p>在上文<code>dispatchAction</code>末尾我们通过<code>schedule</code>方法模拟<code>React</code>调度更新流程。</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">dispatchAction</span><span class="token punctuation">(</span><span class="token parameter">queue<span class="token punctuation">,</span> action</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...创建update</span>
  
  <span class="token comment">// ...环状单向链表操作</span>

  <span class="token comment">// 模拟React开始调度更新</span>
  <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <p>现在我们来实现他。</p>
    <p>我们用<code>isMount</code>变量指代是<code>mount</code>还是<code>update</code>。</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token comment">// 首次render时是mount</span>
isMount <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 更新前将workInProgressHook重置为fiber保存的第一个Hook</span>
  workInProgressHook <span class="token operator">=</span> fiber<span class="token punctuation">.</span>memoizedState<span class="token punctuation">;</span>
  <span class="token comment">// 触发组件render</span>
  fiber<span class="token punctuation">.</span><span class="token function">stateNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 组件首次render为mount，以后再触发的更新为update</span>
  isMount <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <p>通过<code>workInProgressHook</code>变量指向当前正在工作的<code>hook</code>。</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code>workInProgressHook <span class="token operator">=</span> fiber<span class="token punctuation">.</span>memoizedState<span class="token punctuation">;</span>
</code></pre>
    </div>
    <p>在组件<code>render</code>时，每当遇到下一个<code>useState</code>，我们移动<code>workInProgressHook</code>的指针。</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code>workInProgressHook <span class="token operator">=</span> workInProgressHook<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
</code></pre>
    </div>
    <p>
      这样，只要每次组件<code>render</code>时<code>useState</code>的调用顺序及数量保持一致，那么始终可以通过<code>workInProgressHook</code>找到当前<code>useState</code>对应的<code>hook</code>对象。
    </p>
    <p>到此为止，我们已经完成第一步。</p>
    <blockquote>
      <ol>
        <li>通过一些途径产生<code>更新</code>，<code>更新</code>会造成组件<code>render</code>。</li>
      </ol>
    </blockquote>
    <p>接下来实现第二步。</p>
    <blockquote>
      <ol start="2">
        <li>组件<code>render</code>时<code>useState</code>返回的<code>num</code>为更新后的结果。</li>
      </ol>
    </blockquote>
    <h2 id="计算state"><a href="#计算state" class="header-anchor">#</a> 计算state</h2>
    <p>组件<code>render</code>时会调用<code>useState</code>，他的大体逻辑如下：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token parameter">initialState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 当前useState使用的hook会被赋值该该变量</span>
  <span class="token keyword">let</span> hook<span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>isMount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...mount时需要生成hook对象</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...update时从workInProgressHook中取出该useState对应的hook</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">let</span> baseState <span class="token operator">=</span> hook<span class="token punctuation">.</span>memoizedState<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>hook<span class="token punctuation">.</span>queue<span class="token punctuation">.</span>pending<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...根据queue.pending中保存的update更新state</span>
  <span class="token punctuation">}</span>
  hook<span class="token punctuation">.</span>memoizedState <span class="token operator">=</span> baseState<span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">[</span>baseState<span class="token punctuation">,</span> <span class="token function">dispatchAction</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> hook<span class="token punctuation">.</span>queue<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <p>我们首先关注如何获取<code>hook</code>对象：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>isMount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// mount时为该useState生成hook</span>
  hook <span class="token operator">=</span> <span class="token punctuation">{</span>
    queue<span class="token operator">:</span> <span class="token punctuation">{</span>
      pending<span class="token operator">:</span> <span class="token keyword">null</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    memoizedState<span class="token operator">:</span> initialState<span class="token punctuation">,</span>
    next<span class="token operator">:</span> <span class="token keyword">null</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 将hook插入fiber.memoizedState链表末尾</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>fiber<span class="token punctuation">.</span>memoizedState<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    fiber<span class="token punctuation">.</span>memoizedState <span class="token operator">=</span> hook<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    workInProgressHook<span class="token punctuation">.</span>next <span class="token operator">=</span> hook<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 移动workInProgressHook指针</span>
  workInProgressHook <span class="token operator">=</span> hook<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token comment">// update时找到对应hook</span>
  hook <span class="token operator">=</span> workInProgressHook<span class="token punctuation">;</span>
  <span class="token comment">// 移动workInProgressHook指针</span>
  workInProgressHook <span class="token operator">=</span> workInProgressHook<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre>
    </div>
    <p>
      当找到该<code>useState</code>对应的<code>hook</code>后，如果该<code>hook.queue.pending</code>不为空（即存在<code>update</code>），则更新其<code>state</code>。
    </p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token comment">// update执行前的初始state</span>
<span class="token keyword">let</span> baseState <span class="token operator">=</span> hook<span class="token punctuation">.</span>memoizedState<span class="token punctuation">;</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span>hook<span class="token punctuation">.</span>queue<span class="token punctuation">.</span>pending<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 获取update环状单向链表中第一个update</span>
  <span class="token keyword">let</span> firstUpdate <span class="token operator">=</span> hook<span class="token punctuation">.</span>queue<span class="token punctuation">.</span>pending<span class="token punctuation">.</span>next<span class="token punctuation">;</span>

  <span class="token keyword">do</span> <span class="token punctuation">{</span>
    <span class="token comment">// 执行update action</span>
    <span class="token keyword">const</span> action <span class="token operator">=</span> firstUpdate<span class="token punctuation">.</span>action<span class="token punctuation">;</span>
    baseState <span class="token operator">=</span> <span class="token function">action</span><span class="token punctuation">(</span>baseState<span class="token punctuation">)</span><span class="token punctuation">;</span>
    firstUpdate <span class="token operator">=</span> firstUpdate<span class="token punctuation">.</span>next<span class="token punctuation">;</span>

    <span class="token comment">// 最后一个update执行完后跳出循环</span>
  <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>firstUpdate <span class="token operator">!==</span> hook<span class="token punctuation">.</span>queue<span class="token punctuation">.</span>pending<span class="token punctuation">.</span>next<span class="token punctuation">)</span>

  <span class="token comment">// 清空queue.pending</span>
  hook<span class="token punctuation">.</span>queue<span class="token punctuation">.</span>pending <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 将update action执行完后的state作为memoizedState</span>
hook<span class="token punctuation">.</span>memoizedState <span class="token operator">=</span> baseState<span class="token punctuation">;</span>
</code></pre>
    </div>
    <p>完整代码如下：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token parameter">initialState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> hook<span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>isMount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    hook <span class="token operator">=</span> <span class="token punctuation">{</span>
      queue<span class="token operator">:</span> <span class="token punctuation">{</span>
        pending<span class="token operator">:</span> <span class="token keyword">null</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      memoizedState<span class="token operator">:</span> initialState<span class="token punctuation">,</span>
      next<span class="token operator">:</span> <span class="token keyword">null</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>fiber<span class="token punctuation">.</span>memoizedState<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      fiber<span class="token punctuation">.</span>memoizedState <span class="token operator">=</span> hook<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      workInProgressHook<span class="token punctuation">.</span>next <span class="token operator">=</span> hook<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    workInProgressHook <span class="token operator">=</span> hook<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    hook <span class="token operator">=</span> workInProgressHook<span class="token punctuation">;</span>
    workInProgressHook <span class="token operator">=</span> workInProgressHook<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">let</span> baseState <span class="token operator">=</span> hook<span class="token punctuation">.</span>memoizedState<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>hook<span class="token punctuation">.</span>queue<span class="token punctuation">.</span>pending<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> firstUpdate <span class="token operator">=</span> hook<span class="token punctuation">.</span>queue<span class="token punctuation">.</span>pending<span class="token punctuation">.</span>next<span class="token punctuation">;</span>

    <span class="token keyword">do</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> action <span class="token operator">=</span> firstUpdate<span class="token punctuation">.</span>action<span class="token punctuation">;</span>
      baseState <span class="token operator">=</span> <span class="token function">action</span><span class="token punctuation">(</span>baseState<span class="token punctuation">)</span><span class="token punctuation">;</span>
      firstUpdate <span class="token operator">=</span> firstUpdate<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>firstUpdate <span class="token operator">!==</span> hook<span class="token punctuation">.</span>queue<span class="token punctuation">.</span>pending<span class="token punctuation">.</span>next<span class="token punctuation">)</span>

    hook<span class="token punctuation">.</span>queue<span class="token punctuation">.</span>pending <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  hook<span class="token punctuation">.</span>memoizedState <span class="token operator">=</span> baseState<span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">[</span>baseState<span class="token punctuation">,</span> <span class="token function">dispatchAction</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> hook<span class="token punctuation">.</span>queue<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <h2 id="对触发事件进行抽象"><a href="#对触发事件进行抽象" class="header-anchor">#</a> 对触发事件进行抽象</h2>
    <p>最后，让我们抽象一下<code>React</code>的事件触发方式。</p>
    <p>通过调用<code>App</code>返回的<code>click</code>方法模拟组件<code>click</code>的行为。</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>num<span class="token punctuation">,</span> updateNum<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>isMount <span class="token operator">?</span> <span class="token string">'mount'</span> <span class="token operator">:</span> <span class="token string">'update'</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> num: </span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    <span class="token function">click</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">updateNum</span><span class="token punctuation">(</span><span class="token parameter">num</span> <span class="token operator">=&gt;</span> num <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <h2 id="在线demo"><a href="#在线demo" class="header-anchor">#</a> 在线Demo</h2>
    <p>至此，我们完成了一个不到100行代码的<code>Hooks</code>。重要的是，他与<code>React</code>的运行逻辑相同。</p>
    <details class="custom-block details">
      <summary>精简Hooks的在线Demo</summary>
      <p>调用<code>window.app.click()</code>模拟组件点击事件。</p>
      <p>你也可以使用多个<code>useState</code>。</p>
      <div class="language-js extra-class">
        <pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>num<span class="token punctuation">,</span> updateNum<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>num1<span class="token punctuation">,</span> updateNum1<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>isMount <span class="token operator">?</span> <span class="token string">'mount'</span> <span class="token operator">:</span> <span class="token string">'update'</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> num: </span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>isMount <span class="token operator">?</span> <span class="token string">'mount'</span> <span class="token operator">:</span> <span class="token string">'update'</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> num1: </span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> num1<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    <span class="token function">click</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">updateNum</span><span class="token punctuation">(</span><span class="token parameter">num</span> <span class="token operator">=&gt;</span> num <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">updateNum1</span><span class="token punctuation">(</span><span class="token parameter">num</span> <span class="token operator">=&gt;</span> num <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
      </div>
      <p><a href="/me.html">关注公众号</a>，后台回复<strong>616</strong>获得在线Demo地址</p>
    </details>
    <h2 id="与react的区别"><a href="#与react的区别" class="header-anchor">#</a> 与React的区别</h2>
    <p>我们用尽可能少的代码模拟了<code>Hooks</code>的运行，但是相比<code>React Hooks</code>，他还有很多不足。以下是他与<code>React Hooks</code>的区别：</p>
    <ol>
      <li>
        <p>
          <code>React Hooks</code>没有使用<code>isMount</code>变量，而是在不同时机使用不同的<code>dispatcher</code>。换言之，<code>mount</code>时的<code>useState</code>与<code>update</code>时的<code>useState</code>不是同一个函数。
        </p>
      </li>
      <li>
        <p><code>React Hooks</code>有中途跳过<code>更新</code>的优化手段。</p>
      </li>
      <li>
        <p>
          <code>React Hooks</code>有<code>batchedUpdates</code>，当在<code>click</code>中触发三次<code>updateNum</code>，<code>精简React</code>会触发三次更新，而<code>React</code>只会触发一次。
        </p>
      </li>
      <li>
        <p><code>React Hooks</code>的<code>update</code>有<code>优先级</code>概念，可以跳过不高优先的<code>update</code>。</p>
      </li>
    </ol>
    <p>更多的细节，我们会在本章后续小节讲解。</p>
  </div>
  <div class="theme-default-content content__default">
    <p>在上一节我们实现了一个极简的<code>useState</code>，了解了<code>Hooks</code>的运行原理。</p>
    <p>本节我们讲解<code>Hooks</code>的数据结构，为后面介绍具体的<code>hook</code>打下基础。</p>
    <h2 id="dispatcher"><a href="#dispatcher" class="header-anchor">#</a> dispatcher</h2>
    <p>在上一节的极简<code>useState</code>实现中，使用<code>isMount</code>变量区分<code>mount</code>与<code>update</code>。</p>
    <p>
      在真实的<code>Hooks</code>中，组件<code>mount</code>时的<code>hook</code>与<code>update</code>时的<code>hook</code>来源于不同的对象，这类对象在源码中被称为<code>dispatcher</code>。
    </p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token comment">// mount时的Dispatcher</span>
<span class="token keyword">const</span> HooksDispatcherOnMount<span class="token operator">:</span> Dispatcher <span class="token operator">=</span> <span class="token punctuation">{</span>
  useCallback<span class="token operator">:</span> mountCallback<span class="token punctuation">,</span>
  useContext<span class="token operator">:</span> readContext<span class="token punctuation">,</span>
  useEffect<span class="token operator">:</span> mountEffect<span class="token punctuation">,</span>
  useImperativeHandle<span class="token operator">:</span> mountImperativeHandle<span class="token punctuation">,</span>
  useLayoutEffect<span class="token operator">:</span> mountLayoutEffect<span class="token punctuation">,</span>
  useMemo<span class="token operator">:</span> mountMemo<span class="token punctuation">,</span>
  useReducer<span class="token operator">:</span> mountReducer<span class="token punctuation">,</span>
  useRef<span class="token operator">:</span> mountRef<span class="token punctuation">,</span>
  useState<span class="token operator">:</span> mountState<span class="token punctuation">,</span>
  <span class="token comment">// ...省略</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// update时的Dispatcher</span>
<span class="token keyword">const</span> HooksDispatcherOnUpdate<span class="token operator">:</span> Dispatcher <span class="token operator">=</span> <span class="token punctuation">{</span>
  useCallback<span class="token operator">:</span> updateCallback<span class="token punctuation">,</span>
  useContext<span class="token operator">:</span> readContext<span class="token punctuation">,</span>
  useEffect<span class="token operator">:</span> updateEffect<span class="token punctuation">,</span>
  useImperativeHandle<span class="token operator">:</span> updateImperativeHandle<span class="token punctuation">,</span>
  useLayoutEffect<span class="token operator">:</span> updateLayoutEffect<span class="token punctuation">,</span>
  useMemo<span class="token operator">:</span> updateMemo<span class="token punctuation">,</span>
  useReducer<span class="token operator">:</span> updateReducer<span class="token punctuation">,</span>
  useRef<span class="token operator">:</span> updateRef<span class="token punctuation">,</span>
  useState<span class="token operator">:</span> updateState<span class="token punctuation">,</span>
  <span class="token comment">// ...省略</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
    </div>
    <p>可见，<code>mount</code>时调用的<code>hook</code>和<code>update</code>时调用的<code>hook</code>其实是两个不同的函数。</p>
    <p>在<code>FunctionComponent</code>
      <code>render</code>前，会根据<code>FunctionComponent</code>对应<code>fiber</code>的以下条件区分<code>mount</code>与<code>update</code>。
    </p>
    <div class="language-js extra-class">
      <pre class="language-js"><code>current <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> current<span class="token punctuation">.</span>memoizedState <span class="token operator">===</span> <span class="token keyword">null</span>
</code></pre>
    </div>
    <p>并将不同情况对应的<code>dispatcher</code>赋值给全局变量<code>ReactCurrentDispatcher</code>的<code>current</code>属性。</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code>ReactCurrentDispatcher<span class="token punctuation">.</span>current <span class="token operator">=</span>
      current <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> current<span class="token punctuation">.</span>memoizedState <span class="token operator">===</span> <span class="token keyword">null</span>
        <span class="token operator">?</span> HooksDispatcherOnMount
        <span class="token operator">:</span> HooksDispatcherOnUpdate<span class="token punctuation">;</span>  
</code></pre>
    </div>
    <blockquote>
      <p>你可以在<a
          href="https://github.com/acdlite/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberHooks.new.js#L409"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>看到这行代码</p>
    </blockquote>
    <p>在<code>FunctionComponent</code>
      <code>render</code>时，会从<code>ReactCurrentDispatcher.current</code>（即当前<code>dispatcher</code>）中寻找需要的<code>hook</code>。
    </p>
    <p>
      换言之，不同的调用栈上下文为<code>ReactCurrentDispatcher.current</code>赋值不同的<code>dispatcher</code>，则<code>FunctionComponent</code>
      <code>render</code>时调用的<code>hook</code>也是不同的函数。</p>
    <blockquote>
      <p>除了这两个<code>dispatcher</code>，你可以在<a
          href="https://github.com/acdlite/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberHooks.new.js#L1775"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>看到其他<code>dispatcher</code>定义</p>
    </blockquote>
    <h2 id="一个dispatcher使用场景"><a href="#一个dispatcher使用场景" class="header-anchor">#</a> 一个dispatcher使用场景</h2>
    <p>当错误的书写了嵌套形式的<code>hook</code>，如：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre>
    </div>
    <p>
      此时<code>ReactCurrentDispatcher.current</code>已经指向<code>ContextOnlyDispatcher</code>，所以调用<code>useState</code>实际会调用<code>throwInvalidHookError</code>，直接抛出异常。
    </p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">const</span> ContextOnlyDispatcher<span class="token operator">:</span> Dispatcher <span class="token operator">=</span> <span class="token punctuation">{</span>
  useCallback<span class="token operator">:</span> throwInvalidHookError<span class="token punctuation">,</span>
  useContext<span class="token operator">:</span> throwInvalidHookError<span class="token punctuation">,</span>
  useEffect<span class="token operator">:</span> throwInvalidHookError<span class="token punctuation">,</span>
  useImperativeHandle<span class="token operator">:</span> throwInvalidHookError<span class="token punctuation">,</span>
  useLayoutEffect<span class="token operator">:</span> throwInvalidHookError<span class="token punctuation">,</span>
  <span class="token comment">// ...省略</span>
</code></pre>
    </div>
    <blockquote>
      <p>你可以在<a
          href="https://github.com/acdlite/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberHooks.new.js#L458"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>看到这段逻辑</p>
    </blockquote>
    <h2 id="hook的数据结构"><a href="#hook的数据结构" class="header-anchor">#</a> Hook的数据结构</h2>
    <p>接下来我们学习<code>hook</code>的数据结构。</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">const</span> hook<span class="token operator">:</span> Hook <span class="token operator">=</span> <span class="token punctuation">{</span>
  memoizedState<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>

  baseState<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  baseQueue<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  queue<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>

  next<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
    </div>
    <blockquote>
      <p>你可以在<a
          href="https://github.com/acdlite/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberHooks.new.js#L546"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>看到创建<code>hook</code>的逻辑</p>
    </blockquote>
    <p>其中除<code>memoizedState</code>以外字段的意义与上一章介绍的<a href="/state/update.html#updatequeue">updateQueue</a>类似。</p>
    <h2 id="memoizedstate"><a href="#memoizedstate" class="header-anchor">#</a> memoizedState</h2>
    <div class="custom-block warning">
      <p class="custom-block-title">注意</p>
      <p><code>hook</code>与<code>FunctionComponent fiber</code>都存在<code>memoizedState</code>属性，不要混淆他们的概念。</p>
      <ul>
        <li>
          <p><code>fiber.memoizedState</code>：<code>FunctionComponent</code>对应<code>fiber</code>保存的<code>Hooks</code>链表。
          </p>
        </li>
        <li>
          <p><code>hook.memoizedState</code>：<code>Hooks</code>链表中保存的单一<code>hook</code>对应的数据。</p>
        </li>
      </ul>
    </div>
    <p>不同类型<code>hook</code>的<code>memoizedState</code>保存不同类型数据，具体如下：</p>
    <ul>
      <li>
        <p>
          useState：对于<code>const [state, updateState] = useState(initialState)</code>，<code>memoizedState</code>保存<code>state</code>的值
        </p>
      </li>
      <li>
        <p>
          useReducer：对于<code>const [state, dispatch] = useReducer(reducer, {});</code>，<code>memoizedState</code>保存<code>state</code>的值
        </p>
      </li>
      <li>
        <p>
          useEffect：<code>memoizedState</code>保存包含<code>useEffect回调函数</code>、<code>依赖项</code>等的链表数据结构<code>effect</code>，你可以在<a
            href="https://github.com/acdlite/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberHooks.new.js#L1181"
            target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
                focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
                <path fill="currentColor"
                  d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
                </path>
                <polygon fill="currentColor"
                  points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
                </polygon>
              </svg> <span class="sr-only">(opens new
                window)</span></span></a>看到<code>effect</code>的创建过程。<code>effect</code>链表同时会保存在<code>fiber.updateQueue</code>中
        </p>
      </li>
      <li>
        <p>useRef：对于<code>useRef(1)</code>，<code>memoizedState</code>保存<code>{current: 1}</code></p>
      </li>
      <li>
        <p>useMemo：对于<code>useMemo(callback, [depA])</code>，<code>memoizedState</code>保存<code>[callback(), depA]</code>
        </p>
      </li>
      <li>
        <p>
          useCallback：对于<code>useCallback(callback, [depA])</code>，<code>memoizedState</code>保存<code>[callback, depA]</code>。与<code>useMemo</code>的区别是，<code>useCallback</code>保存的是<code>callback</code>函数本身，而<code>useMemo</code>保存的是<code>callback</code>函数的执行结果
        </p>
      </li>
    </ul>
    <p>有些<code>hook</code>是没有<code>memoizedState</code>的，比如：</p>
    <ul>
      <li>useContext</li>
    </ul>
  </div>
  <div class="theme-default-content content__default">
    <p>
      <code>Redux</code>的作者<code>Dan</code>加入<code>React</code>核心团队后的一大贡献就是“将<code>Redux</code>的理念带入<code>React</code>”。
    </p>
    <p>
      这里面最显而易见的影响莫过于<code>useState</code>与<code>useReducer</code>这两个<code>Hook</code>。本质来说，<code>useState</code>只是预置了<code>reducer</code>的<code>useReducer</code>。
    </p>
    <p>本节我们来学习<code>useState</code>与<code>useReducer</code>的实现。</p>
    <h2 id="流程概览"><a href="#流程概览" class="header-anchor">#</a> 流程概览</h2>
    <p>我们将这两个<code>Hook</code>的工作流程分为<code>声明阶段</code>和<code>调用阶段</code>，对于：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span> dispatch<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useReducer</span><span class="token punctuation">(</span>reducer<span class="token punctuation">,</span> <span class="token punctuation">{</span>a<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">const</span> <span class="token punctuation">[</span>num<span class="token punctuation">,</span> updateNum<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token punctuation">{</span>type<span class="token operator">:</span> <span class="token string">'a'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>state<span class="token punctuation">.</span>a<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>  
      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">updateNum</span><span class="token punctuation">(</span><span class="token parameter">num</span> <span class="token operator">=&gt;</span> num <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>num<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>  
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <p><code>声明阶段</code>即<code>App</code>调用时，会依次执行<code>useReducer</code>与<code>useState</code>方法。</p>
    <p><code>调用阶段</code>即点击按钮后，<code>dispatch</code>或<code>updateNum</code>被调用时。</p>
    <h2 id="声明阶段"><a href="#声明阶段" class="header-anchor">#</a> 声明阶段</h2>
    <p>当<code>FunctionComponent</code>进入<code>render阶段</code>的<code>beginWork</code>时，会调用<a
        href="https://github.com/acdlite/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L1419"
        target="_blank" rel="noopener noreferrer">renderWithHooks<span><svg xmlns="http://www.w3.org/2000/svg"
            aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"
            class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a>方法。</p>
    <p>该方法内部会执行<code>FunctionComponent</code>对应函数（即<code>fiber.type</code>）。</p>
    <blockquote>
      <p>你可以在<a
          href="https://github.com/acdlite/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberHooks.new.js#L415"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>看到这段逻辑</p>
    </blockquote>
    <p>对于这两个<code>Hook</code>，他们的源码如下：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token parameter">initialState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> dispatcher <span class="token operator">=</span> <span class="token function">resolveDispatcher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> dispatcher<span class="token punctuation">.</span><span class="token function">useState</span><span class="token punctuation">(</span>initialState<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">useReducer</span><span class="token punctuation">(</span><span class="token parameter">reducer<span class="token punctuation">,</span> initialArg<span class="token punctuation">,</span> init</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> dispatcher <span class="token operator">=</span> <span class="token function">resolveDispatcher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> dispatcher<span class="token punctuation">.</span><span class="token function">useReducer</span><span class="token punctuation">(</span>reducer<span class="token punctuation">,</span> initialArg<span class="token punctuation">,</span> init<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <p>正如上一节<a href="/hooks/structure.html#dispatcher">dispatcher</a>所说，在不同场景下，同一个<code>Hook</code>会调用不同处理函数。</p>
    <p>我们分别讲解<code>mount</code>与<code>update</code>两个场景。</p>
    <h3 id="mount时"><a href="#mount时" class="header-anchor">#</a> mount时</h3>
    <p><code>mount</code>时，<code>useReducer</code>会调用<a
        href="https://github.com/acdlite/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberHooks.new.js#L638"
        target="_blank" rel="noopener noreferrer">mountReducer<span><svg xmlns="http://www.w3.org/2000/svg"
            aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"
            class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a>，<code>useState</code>会调用<a
        href="https://github.com/acdlite/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberHooks.new.js#L1143"
        target="_blank" rel="noopener noreferrer">mountState<span><svg xmlns="http://www.w3.org/2000/svg"
            aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"
            class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a>。</p>
    <p>我们来简单对比这这两个方法：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">function</span> mountState<span class="token operator">&lt;</span><span class="token constant">S</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>
  initialState<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">S</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token constant">S</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token constant">S</span><span class="token punctuation">,</span> Dispatch<span class="token operator">&lt;</span>BasicStateAction<span class="token operator">&lt;</span><span class="token constant">S</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
  <span class="token comment">// 创建并返回当前的hook</span>
  <span class="token keyword">const</span> hook <span class="token operator">=</span> <span class="token function">mountWorkInProgressHook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// ...赋值初始state</span>

  <span class="token comment">// 创建queue</span>
  <span class="token keyword">const</span> queue <span class="token operator">=</span> <span class="token punctuation">(</span>hook<span class="token punctuation">.</span>queue <span class="token operator">=</span> <span class="token punctuation">{</span>
    pending<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    dispatch<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    lastRenderedReducer<span class="token operator">:</span> basicStateReducer<span class="token punctuation">,</span>
    lastRenderedState<span class="token operator">:</span> <span class="token punctuation">(</span>initialState<span class="token operator">:</span> any<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// ...创建dispatch</span>
  <span class="token keyword">return</span> <span class="token punctuation">[</span>hook<span class="token punctuation">.</span>memoizedState<span class="token punctuation">,</span> dispatch<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> mountReducer<span class="token operator">&lt;</span><span class="token constant">S</span><span class="token punctuation">,</span> <span class="token constant">I</span><span class="token punctuation">,</span> <span class="token constant">A</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>
  <span class="token function-variable function">reducer</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token constant">S</span><span class="token punctuation">,</span> <span class="token constant">A</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">S</span><span class="token punctuation">,</span>
  initialArg<span class="token operator">:</span> <span class="token constant">I</span><span class="token punctuation">,</span>
  init<span class="token operator">?</span><span class="token operator">:</span> <span class="token parameter"><span class="token constant">I</span></span> <span class="token operator">=&gt;</span> <span class="token constant">S</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token constant">S</span><span class="token punctuation">,</span> Dispatch<span class="token operator">&lt;</span><span class="token constant">A</span><span class="token operator">&gt;</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
  <span class="token comment">// 创建并返回当前的hook</span>
  <span class="token keyword">const</span> hook <span class="token operator">=</span> <span class="token function">mountWorkInProgressHook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// ...赋值初始state</span>

  <span class="token comment">// 创建queue</span>
  <span class="token keyword">const</span> queue <span class="token operator">=</span> <span class="token punctuation">(</span>hook<span class="token punctuation">.</span>queue <span class="token operator">=</span> <span class="token punctuation">{</span>
    pending<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    dispatch<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    lastRenderedReducer<span class="token operator">:</span> reducer<span class="token punctuation">,</span>
    lastRenderedState<span class="token operator">:</span> <span class="token punctuation">(</span>initialState<span class="token operator">:</span> any<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// ...创建dispatch</span>
  <span class="token keyword">return</span> <span class="token punctuation">[</span>hook<span class="token punctuation">.</span>memoizedState<span class="token punctuation">,</span> dispatch<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <p>
      其中<code>mountWorkInProgressHook</code>方法会创建并返回对应<code>hook</code>，对应<code>极简Hooks实现</code>中<code>useState</code>方法的<code>isMount</code>逻辑部分。
    </p>
    <p>可以看到，<code>mount</code>时这两个<code>Hook</code>的唯一区别为<code>queue</code>参数的<code>lastRenderedReducer</code>字段。</p>
    <p><code>queue</code>的数据结构如下：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">const</span> queue <span class="token operator">=</span> <span class="token punctuation">(</span>hook<span class="token punctuation">.</span>queue <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// 与极简实现中的同名字段意义相同，保存update对象</span>
  pending<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token comment">// 保存dispatchAction.bind()的值</span>
  dispatch<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token comment">// 上一次render时使用的reducer</span>
  lastRenderedReducer<span class="token operator">:</span> reducer<span class="token punctuation">,</span>
  <span class="token comment">// 上一次render时的state</span>
  lastRenderedState<span class="token operator">:</span> <span class="token punctuation">(</span>initialState<span class="token operator">:</span> any<span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    </div>
    <p>
      其中，<code>useReducer</code>的<code>lastRenderedReducer</code>为传入的<code>reducer</code>参数。<code>useState</code>的<code>lastRenderedReducer</code>为<code>basicStateReducer</code>。
    </p>
    <p><code>basicStateReducer</code>方法如下：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">function</span> basicStateReducer<span class="token operator">&lt;</span><span class="token constant">S</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>state<span class="token operator">:</span> <span class="token constant">S</span><span class="token punctuation">,</span> action<span class="token operator">:</span> BasicStateAction<span class="token operator">&lt;</span><span class="token constant">S</span><span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">S</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">typeof</span> action <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">?</span> <span class="token function">action</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token operator">:</span> action<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <p>可见，<code>useState</code>即<code>reducer</code>参数为<code>basicStateReducer</code>的<code>useReducer</code>。</p>
    <p><code>mount</code>时的整体运行逻辑与<code>极简实现</code>的<code>isMount</code>逻辑类似，你可以对照着看。</p>
    <h3 id="update时"><a href="#update时" class="header-anchor">#</a> update时</h3>
    <p>如果说<code>mount</code>时这两者还有区别，那<code>update</code>时，<code>useReducer</code>与<code>useState</code>调用的则是同一个函数<a
        href="https://github.com/acdlite/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberHooks.new.js#L665"
        target="_blank" rel="noopener noreferrer">updateReducer<span><svg xmlns="http://www.w3.org/2000/svg"
            aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"
            class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a>。</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">function</span> updateReducer<span class="token operator">&lt;</span><span class="token constant">S</span><span class="token punctuation">,</span> <span class="token constant">I</span><span class="token punctuation">,</span> <span class="token constant">A</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>
  <span class="token function-variable function">reducer</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token constant">S</span><span class="token punctuation">,</span> <span class="token constant">A</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">S</span><span class="token punctuation">,</span>
  initialArg<span class="token operator">:</span> <span class="token constant">I</span><span class="token punctuation">,</span>
  init<span class="token operator">?</span><span class="token operator">:</span> <span class="token parameter"><span class="token constant">I</span></span> <span class="token operator">=&gt;</span> <span class="token constant">S</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token constant">S</span><span class="token punctuation">,</span> Dispatch<span class="token operator">&lt;</span><span class="token constant">A</span><span class="token operator">&gt;</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
  <span class="token comment">// 获取当前hook</span>
  <span class="token keyword">const</span> hook <span class="token operator">=</span> <span class="token function">updateWorkInProgressHook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> queue <span class="token operator">=</span> hook<span class="token punctuation">.</span>queue<span class="token punctuation">;</span>
  
  queue<span class="token punctuation">.</span>lastRenderedReducer <span class="token operator">=</span> reducer<span class="token punctuation">;</span>

  <span class="token comment">// ...同update与updateQueue类似的更新逻辑</span>

  <span class="token keyword">const</span> dispatch<span class="token operator">:</span> Dispatch<span class="token operator">&lt;</span><span class="token constant">A</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">(</span>queue<span class="token punctuation">.</span>dispatch<span class="token operator">:</span> any<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">[</span>hook<span class="token punctuation">.</span>memoizedState<span class="token punctuation">,</span> dispatch<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <p>整个流程可以概括为一句话：</p>
    <blockquote>
      <p>找到对应的<code>hook</code>，根据<code>update</code>计算该<code>hook</code>的新<code>state</code>并返回。</p>
    </blockquote>
    <p>
      <code>mount</code>时获取当前<code>hook</code>使用的是<code>mountWorkInProgressHook</code>，而<code>update</code>时使用的是<code>updateWorkInProgressHook</code>，这里的原因是：
    </p>
    <ul>
      <li>
        <p><code>mount</code>时可以确定是调用<code>ReactDOM.render</code>或相关初始化<code>API</code>产生的<code>更新</code>，只会执行一次。</p>
      </li>
      <li>
        <p>
          <code>update</code>可能是在事件回调或副作用中触发的<code>更新</code>或者是<code>render阶段</code>触发的<code>更新</code>，为了避免组件无限循环<code>更新</code>，后者需要区别对待。
        </p>
      </li>
    </ul>
    <p>举个<code>render阶段</code>触发的<code>更新</code>的例子：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>num<span class="token punctuation">,</span> updateNum<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token function">updateNum</span><span class="token punctuation">(</span>num <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">updateNum</span><span class="token punctuation">(</span><span class="token parameter">num</span> <span class="token operator">=&gt;</span> num <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>num<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>  
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <p>在这个例子中，<code>App</code>调用时，代表已经进入<code>render阶段</code>执行<code>renderWithHooks</code>。</p>
    <p>
      在<code>App</code>内部，调用<code>updateNum</code>会触发一次<code>更新</code>。如果不对这种情况下触发的更新作出限制，那么这次<code>更新</code>会开启一次新的<code>render阶段</code>，最终会无限循环更新。
    </p>
    <p>基于这个原因，<code>React</code>用一个标记变量<code>didScheduleRenderPhaseUpdate</code>判断是否是<code>render阶段</code>触发的更新。</p>
    <p><code>updateWorkInProgressHook</code>方法也会区分这两种情况来获取对应<code>hook</code>。</p>
    <p>获取对应<code>hook</code>，接下来会根据<code>hook</code>中保存的<code>state</code>计算新的<code>state</code>，这个步骤同<a
        href="/state/update.html">Update一节</a>一致。</p>
    <h2 id="调用阶段"><a href="#调用阶段" class="header-anchor">#</a> 调用阶段</h2>
    <p>调用阶段会执行<a
        href="https://github.com/acdlite/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberHooks.new.js#L1662"
        target="_blank" rel="noopener noreferrer">dispatchAction<span><svg xmlns="http://www.w3.org/2000/svg"
            aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"
            class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new
            window)</span></span></a>，此时该<code>FunctionComponent</code>对应的<code>fiber</code>以及<code>hook.queue</code>已经通过调用<code>bind</code>方法预先作为参数传入。
    </p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">dispatchAction</span><span class="token punctuation">(</span><span class="token parameter">fiber<span class="token punctuation">,</span> queue<span class="token punctuation">,</span> action</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

  <span class="token comment">// ...创建update</span>
  <span class="token keyword">var</span> update <span class="token operator">=</span> <span class="token punctuation">{</span>
    eventTime<span class="token operator">:</span> eventTime<span class="token punctuation">,</span>
    lane<span class="token operator">:</span> lane<span class="token punctuation">,</span>
    suspenseConfig<span class="token operator">:</span> suspenseConfig<span class="token punctuation">,</span>
    action<span class="token operator">:</span> action<span class="token punctuation">,</span>
    eagerReducer<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    eagerState<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    next<span class="token operator">:</span> <span class="token keyword">null</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span> 

  <span class="token comment">// ...将update加入queue.pending</span>
  
  <span class="token keyword">var</span> alternate <span class="token operator">=</span> fiber<span class="token punctuation">.</span>alternate<span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>fiber <span class="token operator">===</span> currentlyRenderingFiber$<span class="token number">1</span> <span class="token operator">||</span> alternate <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> alternate <span class="token operator">===</span> currentlyRenderingFiber$<span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// render阶段触发的更新</span>
    didScheduleRenderPhaseUpdateDuringThisPass <span class="token operator">=</span> didScheduleRenderPhaseUpdate <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>fiber<span class="token punctuation">.</span>lanes <span class="token operator">===</span> NoLanes <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>alternate <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> alternate<span class="token punctuation">.</span>lanes <span class="token operator">===</span> NoLanes<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// ...fiber的updateQueue为空，优化路径</span>
    <span class="token punctuation">}</span>

    <span class="token function">scheduleUpdateOnFiber</span><span class="token punctuation">(</span>fiber<span class="token punctuation">,</span> lane<span class="token punctuation">,</span> eventTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <p>整个过程可以概括为：</p>
    <blockquote>
      <p>创建<code>update</code>，将<code>update</code>加入<code>queue.pending</code>中，并开启调度。</p>
    </blockquote>
    <p>这里值得注意的是<code>if...else...</code>逻辑，其中：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>fiber <span class="token operator">===</span> currentlyRenderingFiber$<span class="token number">1</span> <span class="token operator">||</span> alternate <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> alternate <span class="token operator">===</span> currentlyRenderingFiber$<span class="token number">1</span><span class="token punctuation">)</span>
</code></pre>
    </div>
    <p>
      <code>currentlyRenderingFiber</code>即<code>workInProgress</code>，<code>workInProgress</code>存在代表当前处于<code>render阶段</code>。
    </p>
    <p>
      触发<code>更新</code>时通过<code>bind</code>预先保存的<code>fiber</code>与<code>workInProgress</code>全等，代表本次<code>更新</code>发生于<code>FunctionComponent</code>对应<code>fiber</code>的<code>render阶段</code>。
    </p>
    <p>所以这是一个<code>render阶段</code>触发的<code>更新</code>，需要标记变量<code>didScheduleRenderPhaseUpdate</code>，后续单独处理。</p>
    <p>再来关注：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>fiber<span class="token punctuation">.</span>lanes <span class="token operator">===</span> NoLanes <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>alternate <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> alternate<span class="token punctuation">.</span>lanes <span class="token operator">===</span> NoLanes<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
    </div>
    <p><code>fiber.lanes</code>保存<code>fiber</code>上存在的<code>update</code>的<code>优先级</code>。</p>
    <p><code>fiber.lanes === NoLanes</code>意味着<code>fiber</code>上不存在<code>update</code>。</p>
    <p>
      我们已经知道，通过<code>update</code>计算<code>state</code>发生在<code>声明阶段</code>，这是因为该<code>hook</code>上可能存在多个不同<code>优先级</code>的<code>update</code>，最终<code>state</code>的值由多个<code>update</code>共同决定。
    </p>
    <p>
      但是当<code>fiber</code>上不存在<code>update</code>，则<code>调用阶段</code>创建的<code>update</code>为该<code>hook</code>上第一个<code>update</code>，在<code>声明阶段</code>计算<code>state</code>时也只依赖于该<code>update</code>，完全不需要进入<code>声明阶段</code>再计算<code>state</code>。
    </p>
    <p>
      这样做的好处是：如果计算出的<code>state</code>与该<code>hook</code>之前保存的<code>state</code>一致，那么完全不需要开启一次调度。即使计算出的<code>state</code>与该<code>hook</code>之前保存的<code>state</code>不一致，在<code>声明阶段</code>也可以直接使用<code>调用阶段</code>已经计算出的<code>state</code>。
    </p>
    <blockquote>
      <p>你可以在<a
          href="https://github.com/acdlite/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberHooks.new.js#L1727"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>看到这段提前计算<code>state</code>的逻辑</p>
    </blockquote>
    <h2 id="小tip"><a href="#小tip" class="header-anchor">#</a> 小Tip</h2>
    <p>我们通常认为，<code>useReducer(reducer, initialState)</code>的传参为初始化参数，在以后的调用中都不可变。</p>
    <p>但是在<code>updateReducer</code>方法中，可以看到<code>lastRenderedReducer</code>在每次调用时都会重新赋值。</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">updateReducer</span><span class="token punctuation">(</span><span class="token parameter">reducer<span class="token punctuation">,</span> initialArg<span class="token punctuation">,</span> init</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>

  queue<span class="token punctuation">.</span>lastRenderedReducer <span class="token operator">=</span> reducer<span class="token punctuation">;</span>

  <span class="token comment">// ...</span>
</code></pre>
    </div>
    <p>也就是说，<code>reducer</code>参数是随时可变的。</p>
    <details class="custom-block details">
      <summary>reducer可变Demo</summary>
      <p>每秒<code>useReducer</code>使用的<code>reducer</code>会改变一次</p>
      <p>点击按钮后会随时间不同会出现<code>+1</code>或<code>-1</code>的效果</p>
      <p><a href="/me.html">关注公众号</a>，后台回复<strong>582</strong>获得在线Demo地址</p>
    </details>
  </div>
  <div class="theme-default-content content__default">
    <p>在<a href="/renderer/prepare.html">架构篇commit阶段流程概览</a>我们讲解了<code>useEffect</code>的工作流程。</p>
    <p>其中我们谈到</p>
    <blockquote>
      <p>在<code>flushPassiveEffects</code>方法内部会从全局变量<code>rootWithPendingPassiveEffects</code>获取<code>effectList</code>。
      </p>
    </blockquote>
    <p>本节我们深入<code>flushPassiveEffects</code>方法内部探索<code>useEffect</code>的工作原理。</p>
    <h2 id="flushpassiveeffectsimpl"><a href="#flushpassiveeffectsimpl" class="header-anchor">#</a>
      flushPassiveEffectsImpl</h2>
    <p><code>flushPassiveEffects</code>内部会设置<code>优先级</code>，并执行<code>flushPassiveEffectsImpl</code>。</p>
    <blockquote>
      <p>你可以从<a
          href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.old.js#L2458"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>看到<code>flushPassiveEffects</code>的代码</p>
    </blockquote>
    <p><code>flushPassiveEffectsImpl</code>主要做三件事：</p>
    <ul>
      <li>
        <p>调用该<code>useEffect</code>在上一次<code>render</code>时的销毁函数</p>
      </li>
      <li>
        <p>调用该<code>useEffect</code>在本次<code>render</code>时的回调函数</p>
      </li>
      <li>
        <p>如果存在同步任务，不需要等待下次<code>事件循环</code>的<code>宏任务</code>，提前执行他</p>
      </li>
    </ul>
    <p>本节我们关注前两步。</p>
    <p>在<code>v16</code>中第一步是同步执行的，在<a
        href="https://zh-hans.reactjs.org/blog/2020/08/10/react-v17-rc.html#effect-cleanup-timing" target="_blank"
        rel="noopener noreferrer">官方博客<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false"
            x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a>中提到：</p>
    <blockquote>
      <p>副作用清理函数（如果存在）在 React 16 中同步运行。我们发现，对于大型应用程序来说，这不是理想选择，因为同步会减缓屏幕的过渡（例如，切换标签）。</p>
    </blockquote>
    <p>基于这个原因，在<code>v17.0.0</code>中，<code>useEffect</code>的两个阶段会在页面渲染后（<code>layout</code>阶段后）异步执行。</p>
    <blockquote>
      <p>事实上，从代码中看，<code>v16.13.1</code>中已经是异步执行了</p>
    </blockquote>
    <p>接下来我们详细讲解这两个步骤。</p>
    <h2 id="阶段一-销毁函数的执行"><a href="#阶段一-销毁函数的执行" class="header-anchor">#</a> 阶段一：销毁函数的执行</h2>
    <p>
      <code>useEffect</code>的执行需要保证所有组件<code>useEffect</code>的<code>销毁函数</code>必须都执行完后才能执行任意一个组件的<code>useEffect</code>的<code>回调函数</code>。
    </p>
    <p>这是因为多个<code>组件</code>间可能共用同一个<code>ref</code>。</p>
    <p>
      如果不是按照“全部销毁”再“全部执行”的顺序，那么在某个组件<code>useEffect</code>的<code>销毁函数</code>中修改的<code>ref.current</code>可能影响另一个组件<code>useEffect</code>的<code>回调函数</code>中的同一个<code>ref</code>的<code>current</code>属性。
    </p>
    <p>在<code>useLayoutEffect</code>中也有同样的问题，所以他们都遵循“全部销毁”再“全部执行”的顺序。</p>
    <p>在阶段一，会遍历并执行所有<code>useEffect</code>的<code>销毁函数</code>。</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token comment">// pendingPassiveHookEffectsUnmount中保存了所有需要执行销毁的useEffect</span>
<span class="token keyword">const</span> unmountEffects <span class="token operator">=</span> pendingPassiveHookEffectsUnmount<span class="token punctuation">;</span>
  pendingPassiveHookEffectsUnmount <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> unmountEffects<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> effect <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>unmountEffects<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">:</span> any<span class="token punctuation">)</span><span class="token operator">:</span> HookEffect<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> fiber <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>unmountEffects<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">:</span> any<span class="token punctuation">)</span><span class="token operator">:</span> Fiber<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> destroy <span class="token operator">=</span> effect<span class="token punctuation">.</span>destroy<span class="token punctuation">;</span>
    effect<span class="token punctuation">.</span>destroy <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> destroy <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 销毁函数存在则执行</span>
      <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">captureCommitPhaseError</span><span class="token punctuation">(</span>fiber<span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre>
    </div>
    <p>
      其中<code>pendingPassiveHookEffectsUnmount</code>数组的索引<code>i</code>保存需要销毁的<code>effect</code>，<code>i+1</code>保存该<code>effect</code>对应的<code>fiber</code>。
    </p>
    <p>向<code>pendingPassiveHookEffectsUnmount</code>数组内<code>push</code>数据的操作发生在<code>layout阶段</code>
      <code>commitLayoutEffectOnFiber</code>方法内部的<code>schedulePassiveEffects</code>方法中。</p>
    <blockquote>
      <p><code>commitLayoutEffectOnFiber</code>方法我们在<a
          href="/renderer/layout.html#commitlayouteffectonfiber">Layout阶段</a>已经介绍</p>
    </blockquote>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">schedulePassiveEffects</span><span class="token punctuation">(</span><span class="token parameter">finishedWork<span class="token operator">:</span> Fiber</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> updateQueue<span class="token operator">:</span> FunctionComponentUpdateQueue <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">=</span> <span class="token punctuation">(</span>finishedWork<span class="token punctuation">.</span>updateQueue<span class="token operator">:</span> any<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> lastEffect <span class="token operator">=</span> updateQueue <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">?</span> updateQueue<span class="token punctuation">.</span>lastEffect <span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>lastEffect <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> firstEffect <span class="token operator">=</span> lastEffect<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token keyword">let</span> effect <span class="token operator">=</span> firstEffect<span class="token punctuation">;</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> <span class="token punctuation">{</span>next<span class="token punctuation">,</span> tag<span class="token punctuation">}</span> <span class="token operator">=</span> effect<span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>
        <span class="token punctuation">(</span>tag <span class="token operator">&amp;</span> HookPassive<span class="token punctuation">)</span> <span class="token operator">!==</span> NoHookEffect <span class="token operator">&amp;&amp;</span>
        <span class="token punctuation">(</span>tag <span class="token operator">&amp;</span> HookHasEffect<span class="token punctuation">)</span> <span class="token operator">!==</span> NoHookEffect
      <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 向`pendingPassiveHookEffectsUnmount`数组内`push`要销毁的effect</span>
        <span class="token function">enqueuePendingPassiveHookEffectUnmount</span><span class="token punctuation">(</span>finishedWork<span class="token punctuation">,</span> effect<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 向`pendingPassiveHookEffectsMount`数组内`push`要执行回调的effect</span>
        <span class="token function">enqueuePendingPassiveHookEffectMount</span><span class="token punctuation">(</span>finishedWork<span class="token punctuation">,</span> effect<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      effect <span class="token operator">=</span> next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>effect <span class="token operator">!==</span> firstEffect<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <h2 id="阶段二-回调函数的执行"><a href="#阶段二-回调函数的执行" class="header-anchor">#</a> 阶段二：回调函数的执行</h2>
    <p>与阶段一类似，同样遍历数组，执行对应<code>effect</code>的<code>回调函数</code>。</p>
    <p>其中向<code>pendingPassiveHookEffectsMount</code>中<code>push</code>数据的操作同样发生在<code>schedulePassiveEffects</code>中。
    </p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token comment">// pendingPassiveHookEffectsMount中保存了所有需要执行回调的useEffect</span>
<span class="token keyword">const</span> mountEffects <span class="token operator">=</span> pendingPassiveHookEffectsMount<span class="token punctuation">;</span>
pendingPassiveHookEffectsMount <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> mountEffects<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> effect <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>mountEffects<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">:</span> any<span class="token punctuation">)</span><span class="token operator">:</span> HookEffect<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> fiber <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>mountEffects<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">:</span> any<span class="token punctuation">)</span><span class="token operator">:</span> Fiber<span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> create <span class="token operator">=</span> effect<span class="token punctuation">.</span>create<span class="token punctuation">;</span>
   effect<span class="token punctuation">.</span>destroy <span class="token operator">=</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">captureCommitPhaseError</span><span class="token punctuation">(</span>fiber<span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
  </div>
  <div class="theme-default-content content__default">
    <p><code>ref</code>是<code>reference</code>（引用）的缩写。在<code>React</code>中，我们习惯用<code>ref</code>保存<code>DOM</code>。</p>
    <p>事实上，任何需要被"引用"的数据都可以保存在<code>ref</code>中，<code>useRef</code>的出现将这种思想进一步发扬光大。</p>
    <p>在<a href="/hooks/structure.html#memoizedstate">Hooks数据结构一节</a>我们讲到：</p>
    <blockquote>
      <p>对于<code>useRef(1)</code>，<code>memoizedState</code>保存<code>{current: 1}</code></p>
    </blockquote>
    <p>本节我们会介绍<code>useRef</code>的实现，以及<code>ref</code>的工作流程。</p>
    <p>由于<code>string</code>类型的<code>ref</code>已不推荐使用，所以本节针对<code>function | {current: any}</code>类型的<code>ref</code>。
    </p>
    <h2 id="useref"><a href="#useref" class="header-anchor">#</a> useRef</h2>
    <p>与其他<code>Hook</code>一样，对于<code>mount</code>与<code>update</code>，<code>useRef</code>对应两个不同<code>dispatcher</code>。
    </p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">function</span> mountRef<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>initialValue<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token operator">|</span>current<span class="token operator">:</span> <span class="token constant">T</span><span class="token operator">|</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>
  <span class="token comment">// 获取当前useRef hook</span>
  <span class="token keyword">const</span> hook <span class="token operator">=</span> <span class="token function">mountWorkInProgressHook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 创建ref</span>
  <span class="token keyword">const</span> ref <span class="token operator">=</span> <span class="token punctuation">{</span>current<span class="token operator">:</span> initialValue<span class="token punctuation">}</span><span class="token punctuation">;</span>
  hook<span class="token punctuation">.</span>memoizedState <span class="token operator">=</span> ref<span class="token punctuation">;</span>
  <span class="token keyword">return</span> ref<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> updateRef<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>initialValue<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token operator">|</span>current<span class="token operator">:</span> <span class="token constant">T</span><span class="token operator">|</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>
  <span class="token comment">// 获取当前useRef hook</span>
  <span class="token keyword">const</span> hook <span class="token operator">=</span> <span class="token function">updateWorkInProgressHook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 返回保存的数据</span>
  <span class="token keyword">return</span> hook<span class="token punctuation">.</span>memoizedState<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <blockquote>
      <p>你可以在<a
          href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberHooks.old.js#L1208-L1221"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>看到这段代码</p>
    </blockquote>
    <p>可见，<code>useRef</code>仅仅是返回一个包含<code>current</code>属性的对象。</p>
    <p>为了验证这个观点，我们再看下<code>React.createRef</code>方法的实现：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">createRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> RefObject <span class="token punctuation">{</span>
  <span class="token keyword">const</span> refObject <span class="token operator">=</span> <span class="token punctuation">{</span>
    current<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> refObject<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <blockquote>
      <p>你可以从<a
          href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react/src/ReactCreateRef.js"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>看到这段代码</p>
    </blockquote>
    <p>了解了<code>ref</code>的数据结构后，我们再来看看<code>ref</code>的工作流程。</p>
    <h2 id="ref的工作流程"><a href="#ref的工作流程" class="header-anchor">#</a> ref的工作流程</h2>
    <p>
      在<code>React</code>中，<code>HostComponent</code>、<code>ClassComponent</code>、<code>ForwardRef</code>可以赋值<code>ref</code>属性。
    </p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token comment">// HostComponent</span>
<span class="token operator">&lt;</span>div ref<span class="token operator">=</span><span class="token punctuation">{</span>domRef<span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token comment">// ClassComponent / ForwardRef</span>
<span class="token operator">&lt;</span>App ref<span class="token operator">=</span><span class="token punctuation">{</span>cpnRef<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
</code></pre>
    </div>
    <p>其中，<code>ForwardRef</code>只是将<code>ref</code>作为第二个参数传递下去，不会进入<code>ref</code>的工作流程。</p>
    <p>所以接下来讨论<code>ref</code>的工作流程时会排除<code>ForwardRef</code>。</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token comment">// 对于ForwardRef，secondArg为传递下去的ref</span>
<span class="token keyword">let</span> children <span class="token operator">=</span> <span class="token function">Component</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span> secondArg<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    </div>
    <blockquote>
      <p>你可以在<a
          href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberHooks.old.js#L415"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>看到这段代码</p>
    </blockquote>
    <p>我们知道<code>HostComponent</code>在<code>commit阶段</code>的<code>mutaion阶段</code>执行<code>DOM</code>操作。</p>
    <p>所以，对应<code>ref</code>的更新也是发生在<code>mutaion阶段</code>。</p>
    <p>再进一步，<code>mutaion阶段</code>执行<code>DOM</code>操作的依据为<code>effectTag</code>。</p>
    <p>
      所以，对于<code>HostComponent</code>、<code>ClassComponent</code>如果包含<code>ref</code>操作，那么也会赋值相应的<code>effectTag</code>。
    </p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token comment">// ...</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> Placement <span class="token operator">=</span> <span class="token comment">/*                    */</span> <span class="token number">0b0000000000000010</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> Update <span class="token operator">=</span> <span class="token comment">/*                       */</span> <span class="token number">0b0000000000000100</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> Deletion <span class="token operator">=</span> <span class="token comment">/*                     */</span> <span class="token number">0b0000000000001000</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> Ref <span class="token operator">=</span> <span class="token comment">/*                          */</span> <span class="token number">0b0000000010000000</span><span class="token punctuation">;</span>
<span class="token comment">// ...</span>
</code></pre>
    </div>
    <blockquote>
      <p>你可以在<a
          href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactSideEffectTags.js#L24"
          target="_blank" rel="noopener noreferrer">ReactSideEffectTags文件<span><svg xmlns="http://www.w3.org/2000/svg"
              aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"
              class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new
              window)</span></span></a>中看到<code>ref</code>对应的<code>effectTag</code></p>
    </blockquote>
    <p>所以，<code>ref</code>的工作流程可以分为两部分：</p>
    <ul>
      <li>
        <p><code>render阶段</code>为含有<code>ref</code>属性的<code>fiber</code>添加<code>Ref effectTag</code></p>
      </li>
      <li>
        <p><code>commit阶段</code>为包含<code>Ref effectTag</code>的<code>fiber</code>执行对应操作</p>
      </li>
    </ul>
    <h2 id="render阶段"><a href="#render阶段" class="header-anchor">#</a> render阶段</h2>
    <p>
      在<code>render阶段</code>的<code>beginWork</code>与<code>completeWork</code>中有个同名方法<code>markRef</code>用于为含有<code>ref</code>属性的<code>fiber</code>增加<code>Ref effectTag</code>。
    </p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token comment">// beginWork的markRef</span>
<span class="token keyword">function</span> <span class="token function">markRef</span><span class="token punctuation">(</span><span class="token parameter">current<span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span> workInProgress<span class="token operator">:</span> Fiber</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> ref <span class="token operator">=</span> workInProgress<span class="token punctuation">.</span>ref<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>
    <span class="token punctuation">(</span>current <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> ref <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">||</span>
    <span class="token punctuation">(</span>current <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> current<span class="token punctuation">.</span>ref <span class="token operator">!==</span> ref<span class="token punctuation">)</span>
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Schedule a Ref effect</span>
    workInProgress<span class="token punctuation">.</span>effectTag <span class="token operator">|=</span> Ref<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// completeWork的markRef</span>
<span class="token keyword">function</span> <span class="token function">markRef</span><span class="token punctuation">(</span><span class="token parameter">workInProgress<span class="token operator">:</span> Fiber</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  workInProgress<span class="token punctuation">.</span>effectTag <span class="token operator">|=</span> Ref<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <blockquote>
      <p>你可以在<a
          href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberBeginWork.old.js#L693"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new
              window)</span></span></a>看到<code>beginWork</code>的<code>markRef</code>、<a
          href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberCompleteWork.old.js#L153"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new
              window)</span></span></a>看到<code>completeWork</code>的<code>markRef</code></p>
    </blockquote>
    <p>在<code>beginWork</code>中，如下两处调用了<code>markRef</code>：</p>
    <ul>
      <li><code>updateClassComponent</code>内的<a
          href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberBeginWork.old.js#L958"
          target="_blank" rel="noopener noreferrer">finishClassComponent<span><svg xmlns="http://www.w3.org/2000/svg"
              aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"
              class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>，对应<code>ClassComponent</code></li>
    </ul>
    <p>注意<code>ClassComponent</code>即使<code>shouldComponentUpdate</code>为<code>false</code>该组件也会调用<code>markRef</code>
    </p>
    <ul>
      <li><a
          href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberBeginWork.old.js#L1156"
          target="_blank" rel="noopener noreferrer">updateHostComponent<span><svg xmlns="http://www.w3.org/2000/svg"
              aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"
              class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>，对应<code>HostComponent</code></li>
    </ul>
    <p>在<code>completeWork</code>中，如下两处调用了<code>markRef</code>：</p>
    <ul>
      <li>
        <p><code>completeWork</code>中的<a
            href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberCompleteWork.old.js#L728"
            target="_blank" rel="noopener noreferrer">HostComponent<span><svg xmlns="http://www.w3.org/2000/svg"
                aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"
                class="icon outbound">
                <path fill="currentColor"
                  d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
                </path>
                <polygon fill="currentColor"
                  points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
                </polygon>
              </svg> <span class="sr-only">(opens new window)</span></span></a>类型</p>
      </li>
      <li>
        <p><code>completeWork</code>中的<a
            href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberCompleteWork.old.js#L1278"
            target="_blank" rel="noopener noreferrer">ScopeComponent<span><svg xmlns="http://www.w3.org/2000/svg"
                aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"
                class="icon outbound">
                <path fill="currentColor"
                  d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
                </path>
                <polygon fill="currentColor"
                  points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
                </polygon>
              </svg> <span class="sr-only">(opens new window)</span></span></a>类型</p>
      </li>
    </ul>
    <blockquote>
      <p><code>ScopeComponent</code>是一种用于管理<code>focus</code>的测试特性，详见<a
          href="https://github.com/facebook/react/pull/16587" target="_blank" rel="noopener noreferrer">PR<span><svg
              xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px"
              viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a></p>
    </blockquote>
    <p>总结下<code>组件</code>对应<code>fiber</code>被赋值<code>Ref effectTag</code>需要满足的条件：</p>
    <ul>
      <li>
        <p>
          <code>fiber</code>类型为<code>HostComponent</code>、<code>ClassComponent</code>、<code>ScopeComponent</code>（这种情况我们不讨论）
        </p>
      </li>
      <li>
        <p>对于<code>mount</code>，<code>workInProgress.ref !== null</code>，即存在<code>ref</code>属性</p>
      </li>
      <li>
        <p>对于<code>update</code>，<code>current.ref !== workInProgress.ref</code>，即<code>ref</code>属性改变</p>
      </li>
    </ul>
    <h2 id="commit阶段"><a href="#commit阶段" class="header-anchor">#</a> commit阶段</h2>
    <p>在<code>commit阶段</code>���<code>mutation阶段</code>中，对于<code>ref</code>属性改变的情况，需要先移除之前的<code>ref</code>。</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">commitMutationEffects</span><span class="token punctuation">(</span><span class="token parameter">root<span class="token operator">:</span> FiberRoot<span class="token punctuation">,</span> renderPriorityLevel</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>nextEffect <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">const</span> effectTag <span class="token operator">=</span> nextEffect<span class="token punctuation">.</span>effectTag<span class="token punctuation">;</span>
    <span class="token comment">// ...</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>effectTag <span class="token operator">&amp;</span> Ref<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> current <span class="token operator">=</span> nextEffect<span class="token punctuation">.</span>alternate<span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 移除之前的ref</span>
        <span class="token function">commitDetachRef</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// ...</span>
</code></pre>
    </div>
    <blockquote>
      <p>你可以在<a
          href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.old.js#L2342"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>看到这段代码</p>
    </blockquote>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">commitDetachRef</span><span class="token punctuation">(</span><span class="token parameter">current<span class="token operator">:</span> Fiber</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> currentRef <span class="token operator">=</span> current<span class="token punctuation">.</span>ref<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>currentRef <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> currentRef <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// function类型ref，调用他，传参为null</span>
      <span class="token function">currentRef</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 对象类型ref，current赋值为null</span>
      currentRef<span class="token punctuation">.</span>current <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <p>
      接下来，在<code>mutation阶段</code>，对于<code>Deletion effectTag</code>的<code>fiber</code>（对应需要删除的<code>DOM节点</code>），需要递归他的子树，对子孙<code>fiber</code>的<code>ref</code>执行类似<code>commitDetachRef</code>的操作。
    </p>
    <p>在<a href="/hooks/renderer/mutation.html#commitmutationeffects">mutation阶段一节</a>我们讲到</p>
    <blockquote>
      <p>对于<code>Deletion effectTag</code>的<code>fiber</code>，会执行<code>commitDeletion</code>。</p>
    </blockquote>
    <p>
      在<code>commitDeletion</code>——<code>unmountHostComponents</code>——<code>commitUnmount</code>——<code>ClassComponent | HostComponent</code>类型<code>case</code>中调用的<code>safelyDetachRef</code>方法负责执行类似<code>commitDetachRef</code>的操作。
    </p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">safelyDetachRef</span><span class="token punctuation">(</span><span class="token parameter">current<span class="token operator">:</span> Fiber</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> ref <span class="token operator">=</span> current<span class="token punctuation">.</span>ref<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>ref <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> ref <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token function">ref</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>refError<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">captureCommitPhaseError</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> refError<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      ref<span class="token punctuation">.</span>current <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <blockquote>
      <p>你可以在<a
          href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberCommitWork.old.js#L183"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>看到这段代码</p>
    </blockquote>
    <p>接下来进入<code>ref</code>的赋值阶段。我们在<a href="/renderer/layout.html#commitlayouteffects">Layout阶段一节</a>讲到</p>
    <blockquote>
      <p><code>commitLayoutEffect</code>会执行<code>commitAttachRef</code>（赋值<code>ref</code>）</p>
    </blockquote>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">commitAttachRef</span><span class="token punctuation">(</span><span class="token parameter">finishedWork<span class="token operator">:</span> Fiber</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> ref <span class="token operator">=</span> finishedWork<span class="token punctuation">.</span>ref<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>ref <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获取ref属性对应的Component实例</span>
    <span class="token keyword">const</span> instance <span class="token operator">=</span> finishedWork<span class="token punctuation">.</span>stateNode<span class="token punctuation">;</span>
    <span class="token keyword">let</span> instanceToUse<span class="token punctuation">;</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>finishedWork<span class="token punctuation">.</span>tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">case</span> HostComponent<span class="token operator">:</span>
        instanceToUse <span class="token operator">=</span> <span class="token function">getPublicInstance</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token keyword">default</span><span class="token operator">:</span>
        instanceToUse <span class="token operator">=</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 赋值ref</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> ref <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">ref</span><span class="token punctuation">(</span>instanceToUse<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      ref<span class="token punctuation">.</span>current <span class="token operator">=</span> instanceToUse<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <p>至此，<code>ref</code>的工作流程完毕。</p>
    <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2>
    <p>本节我们学习了<code>ref</code>的工作流程。</p>
    <ul>
      <li>
        <p>对于<code>FunctionComponent</code>，<code>useRef</code>负责创建并返回对应的<code>ref</code>。</p>
      </li>
      <li>
        <p>
          对于赋值了<code>ref</code>属性的<code>HostComponent</code>与<code>ClassComponent</code>，会在<code>render阶段</code>经历赋值<code>Ref effectTag</code>，在<code>commit阶段</code>执行对应<code>ref</code>操作。
        </p>
      </li>
    </ul>
  </div>
  <div class="theme-default-content content__default">
    <p>在了解其他<code>hook</code>的实现后，理解<code>useMemo</code>与<code>useCallback</code>的实现非常容易。</p>
    <p>本节我们以<code>mount</code>与<code>update</code>两种情况分别讨论这两个<code>hook</code>。</p>
    <h2 id="mount"><a href="#mount" class="header-anchor">#</a> mount</h2>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">function</span> mountMemo<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>
  <span class="token function-variable function">nextCreate</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">T</span><span class="token punctuation">,</span>
  deps<span class="token operator">:</span> Array<span class="token operator">&lt;</span>mixed<span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token keyword">void</span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span>
  <span class="token comment">// 创建并返回当前hook</span>
  <span class="token keyword">const</span> hook <span class="token operator">=</span> <span class="token function">mountWorkInProgressHook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> nextDeps <span class="token operator">=</span> deps <span class="token operator">===</span> <span class="token keyword">undefined</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> deps<span class="token punctuation">;</span>
  <span class="token comment">// 计算value</span>
  <span class="token keyword">const</span> nextValue <span class="token operator">=</span> <span class="token function">nextCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 将value与deps保存在hook.memoizedState</span>
  hook<span class="token punctuation">.</span>memoizedState <span class="token operator">=</span> <span class="token punctuation">[</span>nextValue<span class="token punctuation">,</span> nextDeps<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> nextValue<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> mountCallback<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>callback<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> deps<span class="token operator">:</span> Array<span class="token operator">&lt;</span>mixed<span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token keyword">void</span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span>
  <span class="token comment">// 创建并返回当前hook</span>
  <span class="token keyword">const</span> hook <span class="token operator">=</span> <span class="token function">mountWorkInProgressHook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> nextDeps <span class="token operator">=</span> deps <span class="token operator">===</span> <span class="token keyword">undefined</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> deps<span class="token punctuation">;</span>
  <span class="token comment">// 将value与deps保存在hook.memoizedState</span>
  hook<span class="token punctuation">.</span>memoizedState <span class="token operator">=</span> <span class="token punctuation">[</span>callback<span class="token punctuation">,</span> nextDeps<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> callback<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <p>可以看到，与<code>mountCallback</code>这两个唯一的区别是</p>
    <ul>
      <li>
        <p><code>mountMemo</code>会将<code>回调函数</code>(nextCreate)的执行结果作为<code>value</code>保存</p>
      </li>
      <li>
        <p><code>mountCallback</code>会保存<code>回调函数</code>果作为<code>value</code>保存</p>
      </li>
    </ul>
    <h2 id="update"><a href="#update" class="header-anchor">#</a> update</h2>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">function</span> updateMemo<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>
  <span class="token function-variable function">nextCreate</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">T</span><span class="token punctuation">,</span>
  deps<span class="token operator">:</span> Array<span class="token operator">&lt;</span>mixed<span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token keyword">void</span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span>
  <span class="token comment">// 返回当前hook</span>
  <span class="token keyword">const</span> hook <span class="token operator">=</span> <span class="token function">updateWorkInProgressHook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> nextDeps <span class="token operator">=</span> deps <span class="token operator">===</span> <span class="token keyword">undefined</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> deps<span class="token punctuation">;</span>
  <span class="token keyword">const</span> prevState <span class="token operator">=</span> hook<span class="token punctuation">.</span>memoizedState<span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>prevState <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>nextDeps <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> prevDeps<span class="token operator">:</span> Array<span class="token operator">&lt;</span>mixed<span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">=</span> prevState<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token comment">// 判断update前后value是否变化</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">areHookInputsEqual</span><span class="token punctuation">(</span>nextDeps<span class="token punctuation">,</span> prevDeps<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 未变化</span>
        <span class="token keyword">return</span> prevState<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 变化，重新计算value</span>
  <span class="token keyword">const</span> nextValue <span class="token operator">=</span> <span class="token function">nextCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  hook<span class="token punctuation">.</span>memoizedState <span class="token operator">=</span> <span class="token punctuation">[</span>nextValue<span class="token punctuation">,</span> nextDeps<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> nextValue<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> updateCallback<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>callback<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> deps<span class="token operator">:</span> Array<span class="token operator">&lt;</span>mixed<span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token keyword">void</span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span>
  <span class="token comment">// 返回当前hook</span>
  <span class="token keyword">const</span> hook <span class="token operator">=</span> <span class="token function">updateWorkInProgressHook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> nextDeps <span class="token operator">=</span> deps <span class="token operator">===</span> <span class="token keyword">undefined</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> deps<span class="token punctuation">;</span>
  <span class="token keyword">const</span> prevState <span class="token operator">=</span> hook<span class="token punctuation">.</span>memoizedState<span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>prevState <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>nextDeps <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> prevDeps<span class="token operator">:</span> Array<span class="token operator">&lt;</span>mixed<span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">=</span> prevState<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token comment">// 判断update前后value是否变化</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">areHookInputsEqual</span><span class="token punctuation">(</span>nextDeps<span class="token punctuation">,</span> prevDeps<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 未变化</span>
        <span class="token keyword">return</span> prevState<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 变化，将新的callback作为value</span>
  hook<span class="token punctuation">.</span>memoizedState <span class="token operator">=</span> <span class="token punctuation">[</span>callback<span class="token punctuation">,</span> nextDeps<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> callback<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <p>可见，对于<code>update</code>，这两个<code>hook</code>的唯一区别也是<strong>是回调函数本身还是回调函数的执行结果作为value</strong>。</p>
  </div>
  <div class="theme-default-content content__default">
    <p>在<a
        href="/state/reactdom.html#react的其他入口函数">ReactDOM.render</a>一节我们介绍了<code>React</code>当前的三种入口函数。日常开发主要使用的是<code>Legacy Mode</code>（通过<code>ReactDOM.render</code>创建）。
    </p>
    <p>从<a href="https://mp.weixin.qq.com/s/zrrqldzRbcPApga_Cp2b8A" target="_blank" rel="noopener noreferrer">React
        v17.0 正式发布！<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px"
            viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new
            window)</span></span></a>一文可以看到，<code>v17.0</code>没有包含新特性。究其原因，<code>v17.0</code>主要的工作在于源码内部对<code>Concurrent Mode</code>的支持。所以<code>v17</code>版本也被称为“垫脚石”版本。
    </p>
    <p>你可以从官网<a href="https://zh-hans.reactjs.org/docs/concurrent-mode-intro.html" target="_blank"
        rel="noopener noreferrer">Concurrent 模式介绍<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
            focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a>了解其基本概念。</p>
    <p>一句话概括：</p>
    <blockquote>
      <p>Concurrent 模式是一组 React 的新功能，可帮助应用保持响应，并根据用户的设备性能和网速进行适当的调整。</p>
    </blockquote>
    <p><code>Concurrent Mode</code>是<code>React</code>过去2年重构<code>Fiber架构</code>的源动力，也是<code>React</code>未来的发展方向。</p>
    <p>可以预见，当<code>v17</code>完美支持<code>Concurrent Mode</code>后，<code>v18</code>会迎来一大波基于<code>Concurrent Mode</code>的库。
    </p>
    <p>底层基础决定了上层<code>API</code>的实现，接下来让我们了解下，<code>Concurrent Mode</code>自底向上都包含哪些组成部分，能够发挥哪些能力？</p>
    <h2 id="底层架构-fiber架构"><a href="#底层架构-fiber架构" class="header-anchor">#</a> 底层架构 —— Fiber架构</h2>
    <p>从<a href="/preparation/idea.html">设计理念</a>我们了解到要实现<code>Concurrent Mode</code>，最关键的一点是：实现异步可中断的更新。</p>
    <p>基于这个前提，<code>React</code>花费2年时间重构完成了<code>Fiber</code>架构。</p>
    <p><code>Fiber</code>架构的意义在于，他将单个<code>组件</code>作为<code>工作单元</code>，使以<code>组件</code>为粒度的“异步可中断的更新”成为可能。</p>
    <h2 id="架构的驱动力-scheduler"><a href="#架构的驱动力-scheduler" class="header-anchor">#</a> 架构的驱动力 —— Scheduler</h2>
    <p>如果我们同步运行<code>Fiber</code>架构（通过<code>ReactDOM.render</code>），则<code>Fiber</code>架构与重构前并无区别。</p>
    <p>但是当我们配合<code>时间切片</code>，就能根据宿主环境性能，为每个<code>工作单元</code>分配一个<code>可运行时间</code>，实现“异步可中断的更新”。</p>
    <p>于是，<a href="https://github.com/facebook/react/tree/master/packages/scheduler" target="_blank"
        rel="noopener noreferrer">scheduler<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
            focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a>（调度器）产生了。</p>
    <h2 id="架构运行策略-lane模型"><a href="#架构运行策略-lane模型" class="header-anchor">#</a> 架构运行策略 —— lane模型</h2>
    <p>到目前为止，<code>React</code>可以控制<code>更新</code>在<code>Fiber</code>架构中运行/中断/继续运行。</p>
    <p>基于当前的架构，当一次<code>更新</code>在运行过程中被中断，过段时间再继续运行，这就是“异步可中断的更新”。</p>
    <p>当一次<code>更新</code>在运行过程中被中断，转而重新开始一次新的<code>更新</code>，我们可以说：后一次<code>更新</code>打断了前一次<code>更新</code>。</p>
    <p>这就是<code>优先级</code>的概念：后一次<code>更新</code>的<code>优先级</code>更高，他打断了正在进行的前一次<code>更新</code>。</p>
    <p>多个<code>优先级</code>之间如何互相打断？<code>优先级</code>能否升降？本次<code>更新</code>应该赋予什么<code>优先级</code>？</p>
    <p>这就需要一个模型控制不同<code>优先级</code>之间的关系与行为，于是<code>lane</code>模型诞生了。</p>
    <h2 id="上层实现"><a href="#上层实现" class="header-anchor">#</a> 上层实现</h2>
    <p>现在，我们可以说：</p>
    <blockquote>
      <p>从源码层面讲，Concurrent Mode是一套可控的“多优先级更新架构”。</p>
    </blockquote>
    <p>那么基于该架构之上可以实现哪些有意思的功能？我们举几个例子：</p>
    <h3 id="batchedupdates"><a href="#batchedupdates" class="header-anchor">#</a> batchedUpdates</h3>
    <p>如果我们在一次事件回调中触发多次<code>更新</code>，他们会被合并为一次<code>更新</code>进行处理。</p>
    <p>如下代码执行只会触发一次<code>更新</code>：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token function">onClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>stateA<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>stateB<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>stateA<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <p>这种合并多个<code>更新</code>的优化方式被称为<code>batchedUpdates</code>。</p>
    <p><code>batchedUpdates</code>在很早的版本就存在了，不过之前的实现局限很多（脱离当前上下文环境的<code>更新</code>不会被合并）。</p>
    <p>在<code>Concurrent Mode</code>中，是以<code>优先级</code>为依据对更新进行合并的，使用范围更广。</p>
    <h3 id="suspense"><a href="#suspense" class="header-anchor">#</a> Suspense</h3>
    <p><a href="https://zh-hans.reactjs.org/docs/concurrent-mode-suspense.html" target="_blank"
        rel="noopener noreferrer">Suspense<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
            focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new
            window)</span></span></a>可以在组件请求数据时展示一个<code>pending</code>状态。请求成功后渲染数据。</p>
    <p>本质上讲<code>Suspense</code>内的组件子树比组件树的其他部分拥有更低的<code>优先级</code>。</p>
    <h3 id="usedeferredvalue"><a href="#usedeferredvalue" class="header-anchor">#</a> useDeferredValue</h3>
    <p><a href="https://zh-hans.reactjs.org/docs/concurrent-mode-reference.html#usedeferredvalue" target="_blank"
        rel="noopener noreferrer">useDeferredValue<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
            focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new
            window)</span></span></a>返回一个延迟响应的值，该值可能“延后”的最长时间为<code>timeoutMs</code>。</p>
    <p>例子：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">const</span> deferredValue <span class="token operator">=</span> <span class="token function">useDeferredValue</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> <span class="token punctuation">{</span> timeoutMs<span class="token operator">:</span> <span class="token number">2000</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    </div>
    <p>在<code>useDeferredValue</code>内部会调用<code>useState</code>并触发一次<code>更新</code>。</p>
    <p>
      这次<code>更新</code>的<code>优先级</code>很低，所以当前如果有正在进行中的<code>更新</code>，不会受<code>useDeferredValue</code>产生的<code>更新</code>影响。所以<code>useDeferredValue</code>能够返回延迟的值。
    </p>
    <p>
      当超过<code>timeoutMs</code>后<code>useDeferredValue</code>产生的<code>更新</code>还没进行（由于<code>优先级</code>太低一直被打断），则会再触发一次高优先级<code>更新</code>。
    </p>
    <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2>
    <p>除了以上介绍的实现，相信未来<code>React</code>还会开发更多基于<code>Concurrent Mode</code>的玩法。</p>
    <p><code>Fiber</code>架构在之前的章节已经学习了。所以，在本章接下来的部分，我们会按照上文的脉络，自底向上，从架构到实现讲解<code>Concurrent Mode</code>。</p>
  </div>
  <div class="theme-default-content content__default">
    <p>在<a href="/preparation/newConstructure.html#react16架构">新的React架构</a>一节我们介绍了<code>Scheduler</code>，他包含两个功能：</p>
    <ol>
      <li>
        <p>时间切片</p>
      </li>
      <li>
        <p>优先级调度</p>
      </li>
    </ol>
    <p>本节我们学习这个两个功能是如何在<code>Scheduler</code>中实现的。</p>
    <h2 id="时间切片原理"><a href="#时间切片原理" class="header-anchor">#</a> 时间切片原理</h2>
    <p><code>时间切片</code>的本质是模拟实现<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback"
        target="_blank" rel="noopener noreferrer">requestIdleCallback<span><svg xmlns="http://www.w3.org/2000/svg"
            aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"
            class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a>。</p>
    <p>除去“浏览器重排/重绘”，下图是浏览器一帧中可以用于执行<code>JS</code>的时机。</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token function">一个task</span><span class="token punctuation">(</span>宏任务<span class="token punctuation">)</span> <span class="token operator">--</span> <span class="token function">队列中全部job</span><span class="token punctuation">(</span>微任务<span class="token punctuation">)</span> <span class="token operator">--</span> requestAnimationFrame <span class="token operator">--</span> 浏览器重排<span class="token operator">/</span>重绘 <span class="token operator">--</span> requestIdleCallback
</code></pre>
    </div>
    <p><code>requestIdleCallback</code>是在“浏览器重排/重绘”后如果当前帧还有空余时间时被调用的。</p>
    <p>浏览器并没有提供其他<code>API</code>能够在同样的时机（浏览器重排/重绘后）调用以模拟其实现。</p>
    <p>唯一能精准控制调用时机的<code>API</code>是<code>requestAnimationFrame</code>，他能让我们在“浏览器重排/重绘”之前执行<code>JS</code>。</p>
    <p>这也是为什么我们通常用这个<code>API</code>实现<code>JS</code>动画 —— 这是浏览器渲染前的最后时机，所以动画能快速被渲染。</p>
    <p>所以，退而求其次，<code>Scheduler</code>的<code>时间切片</code>功能是通过<code>task</code>（宏任务）实现的。</p>
    <p>最常见的<code>task</code>当属<code>setTimeout</code>了。但是有个<code>task</code>比<code>setTimeout</code>执行时机更靠前，那就是<a
        href="https://developer.mozilla.org/zh-CN/docs/Web/API/MessageChannel" target="_blank"
        rel="noopener noreferrer">MessageChannel<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
            focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a>。</p>
    <p>
      所以<code>Scheduler</code>将需要被执行的回调函数作为<code>MessageChannel</code>的回调执行。如果当前宿主环境不支持<code>MessageChannel</code>，则使用<code>setTimeout</code>。
    </p>
    <blockquote>
      <p>你可以在<a
          href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/scheduler/src/forks/SchedulerHostConfig.default.js#L228-L234"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>看到<code>MessageChannel</code>的实现。<a
          href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/scheduler/src/forks/SchedulerHostConfig.default.js#L47-L55"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>看到<code>setTimeout</code>的实现</p>
    </blockquote>
    <p>
      在<code>React</code>的<code>render</code>阶段，开启<code>Concurrent Mode</code>时，每次遍历前，都会通过<code>Scheduler</code>提供的<code>shouldYield</code>方法判断是否需要中断遍历，使浏览器有时间渲染：
    </p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">workLoopConcurrent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Perform work until Scheduler asks us to yield</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>workInProgress <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">shouldYield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">performUnitOfWork</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <p>是否中断的依据，最重要的一点便是每个任务的剩余时间是否用完。</p>
    <p>在<code>Schdeduler</code>中，为任务分配的初始剩余时间为<code>5ms</code>。</p>
    <blockquote>
      <p>你可以从<a
          href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/scheduler/src/forks/SchedulerHostConfig.default.js#L119"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>看到初始剩余时间的定义</p>
    </blockquote>
    <p>随着应用运行，会通过<code>fps</code>动态调整分配给任务的可执行时间。</p>
    <blockquote>
      <p>你可以从<a
          href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/scheduler/src/forks/SchedulerHostConfig.default.js#L172-L187"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>看到动态分配任务时间</p>
    </blockquote>
    <p>这也解释了为什么<a href="/preparation/idea.html#cpu的瓶颈">设计理念</a>一节启用<code>Concurrent Mode</code>后每个任务的执行时间大体都是多于5ms的一小段时间
      —— 每个时间切片被设定为5ms，任务本身再执行一小段时间，所以整体时间是多于5ms的时间</p> <img src="https://react.iamkasong.com/img/time-slice.png"
      alt="长任务">
    <p>那么当<code>shouldYield</code>为<code>true</code>，以至于<code>performUnitOfWork</code>被中断后是如何重新启动的呢？我们会在介绍完"优先级调度"后解答。
    </p>
    <h2 id="优先级调度"><a href="#优先级调度" class="header-anchor">#</a> 优先级调度</h2>
    <p>
      首先我们来了解<code>优先级</code>的来源。需要明确的一点是，<code>Scheduler</code>是独立于<code>React</code>的包，所以他的<code>优先级</code>也是独立于<code>React</code>的<code>优先级</code>的。
    </p>
    <p><code>Scheduler</code>对外暴露了一个方法<a
        href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/scheduler/src/Scheduler.js#L217-L237"
        target="_blank" rel="noopener noreferrer">unstable_runWithPriority<span><svg xmlns="http://www.w3.org/2000/svg"
            aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"
            class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a>。</p>
    <p>
      这个方法接受一个<code>优先级</code>与一个<code>回调函数</code>，在<code>回调函数</code>内部调用获取<code>优先级</code>的方法都会取得第一个参数对应的<code>优先级</code>：
    </p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">unstable_runWithPriority</span><span class="token punctuation">(</span><span class="token parameter">priorityLevel<span class="token punctuation">,</span> eventHandler</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>priorityLevel<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> ImmediatePriority<span class="token operator">:</span>
    <span class="token keyword">case</span> UserBlockingPriority<span class="token operator">:</span>
    <span class="token keyword">case</span> NormalPriority<span class="token operator">:</span>
    <span class="token keyword">case</span> LowPriority<span class="token operator">:</span>
    <span class="token keyword">case</span> IdlePriority<span class="token operator">:</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">default</span><span class="token operator">:</span>
      priorityLevel <span class="token operator">=</span> NormalPriority<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">var</span> previousPriorityLevel <span class="token operator">=</span> currentPriorityLevel<span class="token punctuation">;</span>
  currentPriorityLevel <span class="token operator">=</span> priorityLevel<span class="token punctuation">;</span>

  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">eventHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    currentPriorityLevel <span class="token operator">=</span> previousPriorityLevel<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <p>可以看到，<code>Scheduler</code>内部存在5种优先级。</p>
    <p>在<code>React</code>内部凡是涉及到<code>优先级</code>调度的地方，都会使用<code>unstable_runWithPriority</code>。</p>
    <p>
      比如，我们知道<code>commit</code>阶段是同步执行的。可以看到，<code>commit</code>阶段的起点<code>commitRoot</code>方法的优先级为<code>ImmediateSchedulerPriority</code>。
    </p>
    <p><code>ImmediateSchedulerPriority</code>即<code>ImmediatePriority</code>的别名，为最高优先级，会立即执行。</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">commitRoot</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> renderPriorityLevel <span class="token operator">=</span> <span class="token function">getCurrentPriorityLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">runWithPriority</span><span class="token punctuation">(</span>
    ImmediateSchedulerPriority<span class="token punctuation">,</span>
    <span class="token function">commitRootImpl</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> root<span class="token punctuation">,</span> renderPriorityLevel<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <h2 id="优先级的意义"><a href="#优先级的意义" class="header-anchor">#</a> 优先级的意义</h2>
    <p><code>Scheduler</code>对外暴露最重要的方法便是<a
        href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/scheduler/src/Scheduler.js#L279-L359"
        target="_blank" rel="noopener noreferrer">unstable_scheduleCallback<span><svg xmlns="http://www.w3.org/2000/svg"
            aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"
            class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a>。该方法用于以某个<code>优先级</code>注册回调函数。</p>
    <p>比如在<code>React</code>中，之前讲过在<code>commit</code>阶段的<code>beforeMutation</code>阶段会调度<code>useEffect</code>的回调：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>rootDoesHavePassiveEffects<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  rootDoesHavePassiveEffects <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token function">scheduleCallback</span><span class="token punctuation">(</span>NormalSchedulerPriority<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">flushPassiveEffects</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <p>这里的回调便是通过<code>scheduleCallback</code>调度的，优先级为<code>NormalSchedulerPriority</code>，即<code>NormalPriority</code>。
    </p>
    <p>不同<code>优先级</code>意味着什么？不同<code>优先级</code>意味着不同时长的任务过期时间：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">var</span> timeout<span class="token punctuation">;</span>
<span class="token keyword">switch</span> <span class="token punctuation">(</span>priorityLevel<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">case</span> ImmediatePriority<span class="token operator">:</span>
    timeout <span class="token operator">=</span> <span class="token constant">IMMEDIATE_PRIORITY_TIMEOUT</span><span class="token punctuation">;</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span>
  <span class="token keyword">case</span> UserBlockingPriority<span class="token operator">:</span>
    timeout <span class="token operator">=</span> <span class="token constant">USER_BLOCKING_PRIORITY_TIMEOUT</span><span class="token punctuation">;</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span>
  <span class="token keyword">case</span> IdlePriority<span class="token operator">:</span>
    timeout <span class="token operator">=</span> <span class="token constant">IDLE_PRIORITY_TIMEOUT</span><span class="token punctuation">;</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span>
  <span class="token keyword">case</span> LowPriority<span class="token operator">:</span>
    timeout <span class="token operator">=</span> <span class="token constant">LOW_PRIORITY_TIMEOUT</span><span class="token punctuation">;</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span>
  <span class="token keyword">case</span> NormalPriority<span class="token operator">:</span>
  <span class="token keyword">default</span><span class="token operator">:</span>
    timeout <span class="token operator">=</span> <span class="token constant">NORMAL_PRIORITY_TIMEOUT</span><span class="token punctuation">;</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> expirationTime <span class="token operator">=</span> startTime <span class="token operator">+</span> timeout<span class="token punctuation">;</span>
</code></pre>
    </div>
    <p>其中：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token comment">// Times out immediately</span>
<span class="token keyword">var</span> <span class="token constant">IMMEDIATE_PRIORITY_TIMEOUT</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token comment">// Eventually times out</span>
<span class="token keyword">var</span> <span class="token constant">USER_BLOCKING_PRIORITY_TIMEOUT</span> <span class="token operator">=</span> <span class="token number">250</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> <span class="token constant">NORMAL_PRIORITY_TIMEOUT</span> <span class="token operator">=</span> <span class="token number">5000</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> <span class="token constant">LOW_PRIORITY_TIMEOUT</span> <span class="token operator">=</span> <span class="token number">10000</span><span class="token punctuation">;</span>
<span class="token comment">// Never times out</span>
<span class="token keyword">var</span> <span class="token constant">IDLE_PRIORITY_TIMEOUT</span> <span class="token operator">=</span> maxSigned31BitInt<span class="token punctuation">;</span>
</code></pre>
    </div>
    <p>
      可以看到，如果一个任务的<code>优先级</code>是<code>ImmediatePriority</code>，对应<code>IMMEDIATE_PRIORITY_TIMEOUT</code>为<code>-1</code>，那么
    </p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">var</span> expirationTime <span class="token operator">=</span> startTime <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre>
    </div>
    <p>则该任务的过期时间比当前时间还短，表示他已经过期了，需要立即被执行。</p>
    <h2 id="不同优先级任务的排序"><a href="#不同优先级任务的排序" class="header-anchor">#</a> 不同优先级任务的排序</h2>
    <p>
      我们已经知道<code>优先级</code>意味着任务的过期时间。设想一个大型<code>React</code>项目，在某一刻，存在很多不同<code>优先级</code>的<code>任务</code>，对应不同的过期时间。
    </p>
    <p>同时，又因为任务可以被延迟，所以我们可以将这些任务按是否被延迟分为：</p>
    <ul>
      <li>
        <p>已就绪任务</p>
      </li>
      <li>
        <p>未就绪任务</p>
      </li>
    </ul>
    <div class="language-js extra-class">
      <pre class="language-js"><code>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> options <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">&amp;&amp;</span> options <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> delay <span class="token operator">=</span> options<span class="token punctuation">.</span>delay<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> delay <span class="token operator">===</span> <span class="token string">'number'</span> <span class="token operator">&amp;&amp;</span> delay <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 任务被延迟</span>
      startTime <span class="token operator">=</span> currentTime <span class="token operator">+</span> delay<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      startTime <span class="token operator">=</span> currentTime<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    startTime <span class="token operator">=</span> currentTime<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre>
    </div>
    <p>所以，<code>Scheduler</code>存在两个队列：</p>
    <ul>
      <li>
        <p>timerQueue：保存未就绪任务</p>
      </li>
      <li>
        <p>taskQueue：保存已就绪任务</p>
      </li>
    </ul>
    <p>每当有新的未就绪的任务被注册，我们将其插入<code>timerQueue</code>并根据开始时间重新排列<code>timerQueue</code>中任务的顺序。</p>
    <p>当<code>timerQueue</code>中有任务就绪，即<code>startTime &lt;= currentTime</code>，我们将其取出并加入<code>taskQueue</code>。</p>
    <p>取出<code>taskQueue</code>中最早过期的任务并执行他。</p>
    <p>为了能在O(1)复杂度找到两个队列中时间最早的那个任务，<code>Scheduler</code>使用<a href="https://www.cnblogs.com/lanhaicode/p/10546257.html"
        target="_blank" rel="noopener noreferrer">小顶堆<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
            focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a>实现了<code>优先级队列</code>。</p>
    <blockquote>
      <p>你可以在<a
          href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/scheduler/src/SchedulerMinHeap.js"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>看到<code>优先级队列</code>的实现</p>
    </blockquote>
    <p>至此，我们了解了<code>Scheduler</code>的实现。现在可以回答介绍<code>时间切片</code>时提到的问题：</p>
    <blockquote>
      <p>那么当shouldYield为true，以至于performUnitOfWork被中断后是如何重新启动的呢？</p>
    </blockquote>
    <p>在“取出<code>taskQueue</code>中最早过期的任务并执行他”这一步中有如下关键步骤：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">const</span> continuationCallback <span class="token operator">=</span> <span class="token function">callback</span><span class="token punctuation">(</span>didUserCallbackTimeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
currentTime <span class="token operator">=</span> <span class="token function">getCurrentTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> continuationCallback <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// continuationCallback是函数</span>
  currentTask<span class="token punctuation">.</span>callback <span class="token operator">=</span> continuationCallback<span class="token punctuation">;</span>
  <span class="token function">markTaskYield</span><span class="token punctuation">(</span>currentTask<span class="token punctuation">,</span> currentTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>enableProfiling<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">markTaskCompleted</span><span class="token punctuation">(</span>currentTask<span class="token punctuation">,</span> currentTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
    currentTask<span class="token punctuation">.</span>isQueued <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>currentTask <span class="token operator">===</span> <span class="token function">peek</span><span class="token punctuation">(</span>taskQueue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 将当前任务清除</span>
    <span class="token function">pop</span><span class="token punctuation">(</span>taskQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token function">advanceTimers</span><span class="token punctuation">(</span>currentTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    </div>
    <p>
      当注册的回调函数执行后的返回值<code>continuationCallback</code>为<code>function</code>，会将<code>continuationCallback</code>作为当前任务的回调函数。
    </p>
    <p>如果返回值不是<code>function</code>，则将当前被执行的任务清除出<code>taskQueue</code>。</p>
    <p><code>render</code>阶段被调度的函数为<code>performConcurrentWorkOnRoot</code>，在该函数末尾有这样一段代码：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>callbackNode <span class="token operator">===</span> originalCallbackNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// The task node scheduled for this root is the same one that's</span>
  <span class="token comment">// currently executed. Need to return a continuation.</span>
  <span class="token keyword">return</span> <span class="token function">performConcurrentWorkOnRoot</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <p>可以看到，在满足一定条件时，该函数会将自己作为返回值。</p>
    <blockquote>
      <p>你可以在<a
          href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.old.js#L850-L854"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>看到这段代码</p>
    </blockquote>
    <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2>
    <p>
      刚才我们讲到，<code>Scheduler</code>与<code>React</code>是两套<code>优先级</code>机制。那么<code>React</code>中的<code>优先级</code>是如何运转的？我们会在下一节介绍。
    </p>
  </div>
  <div class="theme-default-content content__default">
    <p>
      上一节我们提到<code>Scheduler</code>与<code>React</code>是两套<code>优先级</code>机制。在<code>React</code>中，存在多种使用不同<code>优先级</code>的情况，比如：
    </p>
    <p>注：以下例子皆为<code>Concurrent Mode</code>开启情况</p>
    <ul>
      <li>
        <p>过期任务或者同步任务使用<code>同步</code>优先级</p>
      </li>
      <li>
        <p>用户交互产生的更新（比如点击事件）使用高优先级</p>
      </li>
      <li>
        <p>网络请求产生的更新使用一般优先级</p>
      </li>
      <li>
        <p><code>Suspense</code>使用低优先级</p>
      </li>
    </ul>
    <p><code>React</code>需要设计一套满足如下需要的<code>优先级</code>机制：</p>
    <ul>
      <li>
        <p>可以表示<code>优先级</code>的不同</p>
      </li>
      <li>
        <p>可能同时存在几个同<code>优先级</code>的<code>更新</code>，所以还得能表示<code>批</code>的概念</p>
      </li>
      <li>
        <p>方便进行<code>优先级</code>相关计算</p>
      </li>
    </ul>
    <p>为了满足如上需求，<code>React</code>设计了<code>lane</code>模型。接下来我们来看<code>lane</code>模型如何满足以上3个条件。</p>
    <h2 id="表示优先级的不同"><a href="#表示优先级的不同" class="header-anchor">#</a> 表示优先级的不同</h2>
    <p>想象你身处赛车场。</p> <img src="https://react.iamkasong.com/img/lane.jpeg" alt="30sec">
    <p>不同的赛车疾驰在不同的赛道。内圈的赛道总长度更短，外圈更长。某几个临近的赛道的长度可以看作差不多长。</p>
    <p><code>lane</code>模型借鉴了同样的概念，使用31位的二进制表示31条赛道，位数越小的赛道<code>优先级</code>越高，某些相邻的赛道拥有相同<code>优先级</code>。</p>
    <p>如下：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">const</span> NoLanes<span class="token operator">:</span> Lanes <span class="token operator">=</span> <span class="token comment">/*                        */</span> <span class="token number">0b0000000000000000000000000000000</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> NoLane<span class="token operator">:</span> Lane <span class="token operator">=</span> <span class="token comment">/*                          */</span> <span class="token number">0b0000000000000000000000000000000</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> SyncLane<span class="token operator">:</span> Lane <span class="token operator">=</span> <span class="token comment">/*                        */</span> <span class="token number">0b0000000000000000000000000000001</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> SyncBatchedLane<span class="token operator">:</span> Lane <span class="token operator">=</span> <span class="token comment">/*                 */</span> <span class="token number">0b0000000000000000000000000000010</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> InputDiscreteHydrationLane<span class="token operator">:</span> Lane <span class="token operator">=</span> <span class="token comment">/*      */</span> <span class="token number">0b0000000000000000000000000000100</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> InputDiscreteLanes<span class="token operator">:</span> Lanes <span class="token operator">=</span> <span class="token comment">/*                    */</span> <span class="token number">0b0000000000000000000000000011000</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> InputContinuousHydrationLane<span class="token operator">:</span> Lane <span class="token operator">=</span> <span class="token comment">/*           */</span> <span class="token number">0b0000000000000000000000000100000</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> InputContinuousLanes<span class="token operator">:</span> Lanes <span class="token operator">=</span> <span class="token comment">/*                  */</span> <span class="token number">0b0000000000000000000000011000000</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> DefaultHydrationLane<span class="token operator">:</span> Lane <span class="token operator">=</span> <span class="token comment">/*            */</span> <span class="token number">0b0000000000000000000000100000000</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> DefaultLanes<span class="token operator">:</span> Lanes <span class="token operator">=</span> <span class="token comment">/*                   */</span> <span class="token number">0b0000000000000000000111000000000</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> TransitionHydrationLane<span class="token operator">:</span> Lane <span class="token operator">=</span> <span class="token comment">/*                */</span> <span class="token number">0b0000000000000000001000000000000</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> TransitionLanes<span class="token operator">:</span> Lanes <span class="token operator">=</span> <span class="token comment">/*                       */</span> <span class="token number">0b0000000001111111110000000000000</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> RetryLanes<span class="token operator">:</span> Lanes <span class="token operator">=</span> <span class="token comment">/*                            */</span> <span class="token number">0b0000011110000000000000000000000</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> SomeRetryLane<span class="token operator">:</span> Lanes <span class="token operator">=</span> <span class="token comment">/*                  */</span> <span class="token number">0b0000010000000000000000000000000</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> SelectiveHydrationLane<span class="token operator">:</span> Lane <span class="token operator">=</span> <span class="token comment">/*          */</span> <span class="token number">0b0000100000000000000000000000000</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> NonIdleLanes <span class="token operator">=</span> <span class="token comment">/*                                 */</span> <span class="token number">0b0000111111111111111111111111111</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> IdleHydrationLane<span class="token operator">:</span> Lane <span class="token operator">=</span> <span class="token comment">/*               */</span> <span class="token number">0b0001000000000000000000000000000</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> IdleLanes<span class="token operator">:</span> Lanes <span class="token operator">=</span> <span class="token comment">/*                             */</span> <span class="token number">0b0110000000000000000000000000000</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> OffscreenLane<span class="token operator">:</span> Lane <span class="token operator">=</span> <span class="token comment">/*                   */</span> <span class="token number">0b1000000000000000000000000000000</span><span class="token punctuation">;</span>
</code></pre>
    </div>
    <blockquote>
      <p>你可以在<a
          href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberLane.js#L77-L107"
          target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a>看到<code>lane</code>的定义</p>
    </blockquote>
    <p>其中，同步优先级占用的赛道为第一位：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">const</span> SyncLane<span class="token operator">:</span> Lane <span class="token operator">=</span> <span class="token comment">/*                        */</span> <span class="token number">0b0000000000000000000000000000001</span><span class="token punctuation">;</span>
</code></pre>
    </div>
    <p>从<code>SyncLane</code>往下一直到<code>SelectiveHydrationLane</code>，赛道的<code>优先级</code>逐步降低。</p>
    <h2 id="表示-批-的概念"><a href="#表示-批-的概念" class="header-anchor">#</a> 表示“批”的概念</h2>
    <p>可以看到其中有几个变量占用了几条赛道，比如：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">const</span> InputDiscreteLanes<span class="token operator">:</span> Lanes <span class="token operator">=</span> <span class="token comment">/*                    */</span> <span class="token number">0b0000000000000000000000000011000</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> DefaultLanes<span class="token operator">:</span> Lanes <span class="token operator">=</span> <span class="token comment">/*                   */</span> <span class="token number">0b0000000000000000000111000000000</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> TransitionLanes<span class="token operator">:</span> Lanes <span class="token operator">=</span> <span class="token comment">/*                       */</span> <span class="token number">0b0000000001111111110000000000000</span><span class="token punctuation">;</span>
</code></pre>
    </div>
    <p>这就是<code>批</code>的概念，被称作<code>lanes</code>（区别于<code>优先级</code>的<code>lane</code>）。</p>
    <p>其中<code>InputDiscreteLanes</code>是“用户交互”触发更新会拥有的<code>优先级</code>范围。</p>
    <p><code>DefaultLanes</code>是“请求数据返回后触发更新”拥有的<code>优先级</code>范围。</p>
    <p>
      <code>TransitionLanes</code>是<code>Suspense</code>、<code>useTransition</code>、<code>useDeferredValue</code>拥有的<code>优先级</code>范围。
    </p>
    <p>
      这其中有个细节，越低<code>优先级</code>的<code>lanes</code>占用的位越多。比如<code>InputDiscreteLanes</code>占了2个位，<code>TransitionLanes</code>占了9个位。
    </p>
    <p>
      原因在于：越低<code>优先级</code>的<code>更新</code>越容易被打断，导致积压下来，所以需要更多的位。相反，最高优的同步更新的<code>SyncLane</code>不需要多余的<code>lanes</code>。
    </p>
    <h2 id="方便进行优先级相关计算"><a href="#方便进行优先级相关计算" class="header-anchor">#</a> 方便进行优先级相关计算</h2>
    <p>既然<code>lane</code>对应了二进制的位，那么<code>优先级</code>相关计算其实就是位运算。</p>
    <p>比如：</p>
    <p>
      计算<code>a</code>、<code>b</code>两个<code>lane</code>是否存在交集，只需要判断<code>a</code>与<code>b</code>按位与的结果是否为<code>0</code>：
    </p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">includesSomeLane</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token operator">:</span> Lanes <span class="token operator">|</span> Lane<span class="token punctuation">,</span> b<span class="token operator">:</span> Lanes <span class="token operator">|</span> Lane</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>a <span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token operator">!==</span> NoLanes<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <p>
      计算<code>b</code>这个<code>lanes</code>是否是<code>a</code>对应的<code>lanes</code>的子集，只需要判断<code>a</code>与<code>b</code>按位与的结果是否为<code>b</code>：
    </p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">isSubsetOfLanes</span><span class="token punctuation">(</span><span class="token parameter">set<span class="token operator">:</span> Lanes<span class="token punctuation">,</span> subset<span class="token operator">:</span> Lanes <span class="token operator">|</span> Lane</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>set <span class="token operator">&amp;</span> subset<span class="token punctuation">)</span> <span class="token operator">===</span> subset<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <p>将两个<code>lane</code>或<code>lanes</code>的位合并只需要执行按位或操作：</p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">mergeLanes</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token operator">:</span> Lanes <span class="token operator">|</span> Lane<span class="token punctuation">,</span> b<span class="token operator">:</span> Lanes <span class="token operator">|</span> Lane</span><span class="token punctuation">)</span><span class="token operator">:</span> Lanes <span class="token punctuation">{</span>
  <span class="token keyword">return</span> a <span class="token operator">|</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <p>
      从<code>set</code>对应<code>lanes</code>中移除<code>subset</code>对应<code>lane</code>（或<code>lanes</code>），只需要对<code>subset</code>的<code>lane</code>（或<code>lanes</code>）执行按位非，结果再对<code>set</code>执行按位与。
    </p>
    <div class="language-js extra-class">
      <pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">removeLanes</span><span class="token punctuation">(</span><span class="token parameter">set<span class="token operator">:</span> Lanes<span class="token punctuation">,</span> subset<span class="token operator">:</span> Lanes <span class="token operator">|</span> Lane</span><span class="token punctuation">)</span><span class="token operator">:</span> Lanes <span class="token punctuation">{</span>
  <span class="token keyword">return</span> set <span class="token operator">&amp;</span> <span class="token operator">~</span>subset<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    </div>
    <blockquote>
      <p>更多位运算参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators"
          target="_blank" rel="noopener noreferrer">MDN<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"
              focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
              <path fill="currentColor"
                d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
              </path>
              <polygon fill="currentColor"
                points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
              </polygon>
            </svg> <span class="sr-only">(opens new window)</span></span></a></p>
    </blockquote>
    <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2>
    <p>这就是<code>React</code>的优先级模型<code>lane</code>模型。</p>
    <p>
      至此，我们已经了解<code>Fiber</code>架构、<code>更新</code>的<code>优先级</code>、<code>Scheduler</code>的实现、<code>lane</code>模型。从下一节开始，我们会逐步讲解<code>Concurrent Mode</code>的各种应用。
    </p>
  </div>
  <div class="theme-default-content content__default">
    <p>施工中...</p>
    <p>后续三节内容<a href="https://ke.sifou.com/course/1650000023864436" target="_blank"
        rel="noopener noreferrer">视频课程<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false"
            x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
            <path fill="currentColor"
              d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
            </path>
            <polygon fill="currentColor"
              points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
            </polygon>
          </svg> <span class="sr-only">(opens new window)</span></span></a>已更新。</p>
  </div>
</body>

</html>